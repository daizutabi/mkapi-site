{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MkApi Documentation MkApi plugin for MkDocs generates API documentation for Python code. MkApi supports two styles of docstrings: Google and NumPy . Features of MkApi are: Type annotation : If you write your function such as def func(x: int) -> str: , you don't need write type(s) in Parameters, Returns, or Yields section again. You can overwrite the type annotation in the corresponding docstring. Object type inspection : MkApi plugin creates class , dataclass , function , or generator prefix for each object. Attribute inspection : If you write attributes with description as comment in module or class, Attributes section is automatically created. Docstring inheritance : Docstring of a subclass can inherit parameters and attributes description from its superclasses. Table of Contents : Table of contents are inserted into the documentation of each package, module, and class. Page mode : Comprehensive API documentation for your project, in which objects are linked to each other by type annotation. Bidirectional Link : Using the Page mode, bidirectional links are created between documentation and source code. Installation Install the plugin using pip: pip install mkapi Configuration Add the following lines to mkdocs.yml : plugins: - search # necessary for search to work - mkapi Usage MkApi provides two modes to generate documentation: Embedding mode and Page mode. Embedding Mode To generate the documentation from docstring in a Markdown source, add an exclamation mark (!), followed by mkapi in brackets, and the object full name in parentheses. Yes, this is like adding an image. The object can be a function, class, or module, etc . ![mkapi](<package.module.object>) MkApi imports modules that you specify. If they aren't in the sys.path , configure mkdocs.yml like below: plugins: - search - mkapi: src_dirs: [<path1>, <path2>, ...] Here, pathX s are inserted to sys.path . These pathX s are relative to the mkdocs.yml directory. The embedding mode is useful to embed documentation of an object in an arbitrary position of a Markdown source. For more details, see: Google style examples NumPy style examples Page Mode Using the page mode, you can construct a comprehensive API documentation for your project. You can get this powerful feature by just one line: nav: - index.md - API: mkapi/api/mkapi For more details, see Page Mode and Internal Links","title":"MkApi Documentation"},{"location":"#mkapi-documentation","text":"MkApi plugin for MkDocs generates API documentation for Python code. MkApi supports two styles of docstrings: Google and NumPy . Features of MkApi are: Type annotation : If you write your function such as def func(x: int) -> str: , you don't need write type(s) in Parameters, Returns, or Yields section again. You can overwrite the type annotation in the corresponding docstring. Object type inspection : MkApi plugin creates class , dataclass , function , or generator prefix for each object. Attribute inspection : If you write attributes with description as comment in module or class, Attributes section is automatically created. Docstring inheritance : Docstring of a subclass can inherit parameters and attributes description from its superclasses. Table of Contents : Table of contents are inserted into the documentation of each package, module, and class. Page mode : Comprehensive API documentation for your project, in which objects are linked to each other by type annotation. Bidirectional Link : Using the Page mode, bidirectional links are created between documentation and source code.","title":"MkApi Documentation"},{"location":"#installation","text":"Install the plugin using pip: pip install mkapi","title":"Installation"},{"location":"#configuration","text":"Add the following lines to mkdocs.yml : plugins: - search # necessary for search to work - mkapi","title":"Configuration"},{"location":"#usage","text":"MkApi provides two modes to generate documentation: Embedding mode and Page mode.","title":"Usage"},{"location":"#embedding-mode","text":"To generate the documentation from docstring in a Markdown source, add an exclamation mark (!), followed by mkapi in brackets, and the object full name in parentheses. Yes, this is like adding an image. The object can be a function, class, or module, etc . ![mkapi](<package.module.object>) MkApi imports modules that you specify. If they aren't in the sys.path , configure mkdocs.yml like below: plugins: - search - mkapi: src_dirs: [<path1>, <path2>, ...] Here, pathX s are inserted to sys.path . These pathX s are relative to the mkdocs.yml directory. The embedding mode is useful to embed documentation of an object in an arbitrary position of a Markdown source. For more details, see: Google style examples NumPy style examples","title":"Embedding Mode"},{"location":"#page-mode","text":"Using the page mode, you can construct a comprehensive API documentation for your project. You can get this powerful feature by just one line: nav: - index.md - API: mkapi/api/mkapi For more details, see Page Mode and Internal Links","title":"Page Mode"},{"location":"api/mkapi.core.attribute/","text":"MODULE MKAPI.CORE . ATTRIBUTE </> This module provides attributes inspection from source code. Functions get_attributes ( obj ) (dict(str: (any, str))) \u2014 Returns a dictionary that maps attribute name to a tuple of (type, description). </> get_class_attributes ( cls ) (dict(str: (any, str))) \u2014 Returns a dictionary that maps attribute name to a tuple of (type, description). </> get_dataclass_attributes ( cls ) (dict(str: (any, str))) \u2014 Returns a dictionary that maps attribute name to a tuple of (type, description). </> get_module_attributes ( module ) (dict(str: (any, str))) \u2014 Returns a dictionary that maps attribute name to a tuple of (type, description). </> function mkapi.core.attribute . get_class_attributes ( cls ) \u2192 dict(str: (any, str)) </> Returns a dictionary that maps attribute name to a tuple of (type, description). Parameters cls \u2014 Class object. Examples >>> from examples.google_style import ExampleClass >>> attrs = get_class_attributes(ExampleClass) >>> attrs['a'][0] is str True >>> attrs['a'][1] 'The first attribute. Comment *inline* with attribute.' >>> attrs['b'][0] == Dict[str, int] True >>> attrs['c'][0] is None True function mkapi.core.attribute . get_dataclass_attributes ( cls ) \u2192 dict(str: (any, str)) </> Returns a dictionary that maps attribute name to a tuple of (type, description). Parameters cls \u2014 Dataclass object. Examples >>> from mkapi.core.base import Item, Type, Inline >>> attrs = get_dataclass_attributes(Item) >>> attrs['type'][0] is Type True >>> attrs['description'][0] is Inline True function mkapi.core.attribute . get_module_attributes ( module ) \u2192 dict(str: (any, str)) </> Returns a dictionary that maps attribute name to a tuple of (type, description). Parameters module \u2014 Module object. Examples >>> from mkapi.core import renderer >>> attrs = get_module_attributes(renderer) >>> attrs['renderer'][0] is renderer.Renderer True function mkapi.core.attribute . get_attributes ( obj ) \u2192 dict(str: (any, str)) </> Returns a dictionary that maps attribute name to a tuple of (type, description). Parameters obj \u2014 Object. See Alse: get_class_attributes , get_dataclass_attributes , get_module_attributes .","title":"mkapi.core.attribute"},{"location":"api/mkapi.core.attribute/#mkapicoreattribute","text":"</> This module provides attributes inspection from source code. Functions get_attributes ( obj ) (dict(str: (any, str))) \u2014 Returns a dictionary that maps attribute name to a tuple of (type, description). </> get_class_attributes ( cls ) (dict(str: (any, str))) \u2014 Returns a dictionary that maps attribute name to a tuple of (type, description). </> get_dataclass_attributes ( cls ) (dict(str: (any, str))) \u2014 Returns a dictionary that maps attribute name to a tuple of (type, description). </> get_module_attributes ( module ) (dict(str: (any, str))) \u2014 Returns a dictionary that maps attribute name to a tuple of (type, description). </> function","title":"mkapi.core.attribute"},{"location":"api/mkapi.core.attribute/#mkapicoreattributeget_class_attributes","text":"</> Returns a dictionary that maps attribute name to a tuple of (type, description). Parameters cls \u2014 Class object. Examples >>> from examples.google_style import ExampleClass >>> attrs = get_class_attributes(ExampleClass) >>> attrs['a'][0] is str True >>> attrs['a'][1] 'The first attribute. Comment *inline* with attribute.' >>> attrs['b'][0] == Dict[str, int] True >>> attrs['c'][0] is None True function","title":"mkapi.core.attribute.get_class_attributes"},{"location":"api/mkapi.core.attribute/#mkapicoreattributeget_dataclass_attributes","text":"</> Returns a dictionary that maps attribute name to a tuple of (type, description). Parameters cls \u2014 Dataclass object. Examples >>> from mkapi.core.base import Item, Type, Inline >>> attrs = get_dataclass_attributes(Item) >>> attrs['type'][0] is Type True >>> attrs['description'][0] is Inline True function","title":"mkapi.core.attribute.get_dataclass_attributes"},{"location":"api/mkapi.core.attribute/#mkapicoreattributeget_module_attributes","text":"</> Returns a dictionary that maps attribute name to a tuple of (type, description). Parameters module \u2014 Module object. Examples >>> from mkapi.core import renderer >>> attrs = get_module_attributes(renderer) >>> attrs['renderer'][0] is renderer.Renderer True function","title":"mkapi.core.attribute.get_module_attributes"},{"location":"api/mkapi.core.attribute/#mkapicoreattributeget_attributes","text":"</> Returns a dictionary that maps attribute name to a tuple of (type, description). Parameters obj \u2014 Object. See Alse: get_class_attributes , get_dataclass_attributes , get_module_attributes .","title":"mkapi.core.attribute.get_attributes"},{"location":"api/mkapi.core.base/","text":"MODULE MKAPI.CORE . BASE </> This module provides entity classes to represent docstring structure. Classes Base \u2014 Base class. </> Inline \u2014 Inline class. </> Type \u2014 Type class represents type of Item , Section , Docstring , or Object . </> Item \u2014 Item class represents an item in Parameters, Attributes, and Raises sections, etc. </> Section \u2014 Section class represents a section in docstring. </> Docstring \u2014 Docstring class represents a docstring of an object. </> dataclass mkapi.core.base . Base ( name='' , markdown='' ) </> Base class. Parameters name (str, optional) \u2014 Name of self. markdown (str, optional) \u2014 Markdown source. Attributes callback (callable( Base : str), optional) \u2014 Callback function to modify HTML output. html (str) \u2014 HTML output after conversion. markdown (str) \u2014 Markdown source. name (str) \u2014 Name of self. Examples >>> base = Base('x', 'markdown') >>> base Base('x') >>> bool(base) True >>> list(base) [Base('x')] >>> base = Base() >>> bool(base) False >>> list(base) [] Methods __bool__ ( ) (bool) \u2014 Returns True if name is not empty. </> __iter__ ( ) ( Base ) \u2014 Yields self if markdown is not empty. </> copy ( ) \u2014 Returns a copy of the Base instance. </> set_html ( html ) \u2014 Sets HTML output. </> method __bool__ ( ) \u2192 bool </> Returns True if name is not empty. generator __iter__ ( ) \u2192 Base </> Yields self if markdown is not empty. method set_html ( html ) </> Sets HTML output. Parameters html (str) \u2014 HTML output. method copy ( ) </> Returns a copy of the Base instance. dataclass mkapi.core.base . Inline ( name='' ) </> Bases mkapi.core.base.Base Inline class. Parameters name (str, optional) \u2014 Name of self. Attributes callback (callable( Base : str), optional) \u2014 Callback function to modify HTML output. html (str) \u2014 HTML output after conversion. markdown (str) \u2014 Markdown source. name (str) \u2014 Name of self. Examples >>> inline = Inline() >>> bool(inline) False >>> inline = Inline('markdown') >>> inline.name == inline.markdown True >>> inline Inline('markdown') >>> bool(inline) True >>> next(iter(inline)) is inline True >>> inline.set_html(\"<p>p1</p><p>p2</p>\") >>> inline.html 'p1<br>p2' >>> inline.copy() Inline('markdown') Methods __bool__ ( ) (bool) \u2014 Returns True if name is not empty. </> __iter__ ( ) ( Base ) \u2014 Yields self if markdown is not empty. </> copy ( ) \u2014 Returns a copy of the Inline instance. </> set_html ( html ) \u2014 Sets html attribute cleaning p tags. </> method __bool__ ( ) \u2192 bool </> Returns True if name is not empty. generator __iter__ ( ) \u2192 Base </> Yields self if markdown is not empty. method set_html ( html ) </> Sets html attribute cleaning p tags. Parameters html (str) \u2014 HTML output. method copy ( ) </> Returns a copy of the Inline instance. dataclass mkapi.core.base . Type ( name='' ) </> Bases mkapi.core.base.Inline mkapi.core.base.Base Type class represents type of Item , Section , Docstring , or Object . Parameters name (str, optional) \u2014 Name of self. Attributes callback (callable( Base : str), optional) \u2014 Callback function to modify HTML output. html (str) \u2014 HTML output after conversion. markdown (str) \u2014 Markdown source. name (str) \u2014 Name of self. Examples >>> a = Type('str') >>> a Type('str') >>> list(a) [] >>> b = Type('[Object](base.Object)') >>> b.markdown '[Object](base.Object)' >>> list(b) [Type('[Object](base.Object)')] >>> a.copy() Type('str') Methods __bool__ ( ) (bool) \u2014 Returns True if name is not empty. </> __iter__ ( ) ( Base ) \u2014 Yields self if markdown is not empty. </> copy ( ) \u2014 Returns a copy of the Type instance. </> set_html ( html ) \u2014 Sets html attribute cleaning p tags. </> method __bool__ ( ) \u2192 bool </> Returns True if name is not empty. generator __iter__ ( ) \u2192 Base </> Yields self if markdown is not empty. method set_html ( html ) </> Sets html attribute cleaning p tags. Parameters html (str) \u2014 HTML output. method copy ( ) </> Returns a copy of the Type instance. dataclass mkapi.core.base . Item ( name='' , type=<factory> , description=<factory> , kind='' ) </> Bases mkapi.core.base.Type mkapi.core.base.Inline mkapi.core.base.Base Item class represents an item in Parameters, Attributes, and Raises sections, etc. Parameters name (str, optional) \u2014 Name of self. type ( Type , optional) \u2014 Type of self. description ( Inline , optional) \u2014 Description of self. kind (str, optional) \u2014 Kind of self, for example readonly_property . This value is rendered as a class attribute in HTML. Attributes callback (callable( Base : str), optional) \u2014 Callback function to modify HTML output. description ( Inline ) \u2014 Description of self. html (str) \u2014 HTML output after conversion. kind (str) \u2014 Kind of self, for example readonly_property . This value is rendered as a class attribute in HTML. markdown (str) \u2014 Markdown source. name (str) \u2014 Name of self. type ( Type ) \u2014 Type of self. Examples >>> item = Item('[x](x)', Type('int'), Inline('A parameter.')) >>> item Item('[x](x)', 'int') >>> item.name, item.markdown, item.html ('[x](x)', '[x](x)', '') >>> item.type Type('int') >>> item.description Inline('A parameter.') >>> item = Item('[x](x)', 'str', 'A parameter.') >>> item.type Type('str') >>> it = iter(item) >>> next(it) is item True >>> next(it) is item.description True >>> item.set_html('<p><strong>init</strong></p>') >>> item.html '__init__' Methods __bool__ ( ) (bool) \u2014 Returns True if name is not empty. </> __iter__ ( ) ( Base ) \u2014 Yields self if markdown is not empty. </> copy ( ) \u2014 Returns a copy of the Item instance. </> set_description ( description , force ) \u2014 Sets description. </> set_html ( html ) \u2014 Sets html attribute cleaning p tags. </> set_type ( type , force ) \u2014 Sets type. </> to_tuple ( ) (str, str, str) \u2014 Returns a tuple of (name, type, description). </> update ( item , force ) \u2014 Updates type and description. </> method __bool__ ( ) \u2192 bool </> Returns True if name is not empty. generator __iter__ ( ) \u2192 Base </> Yields self if markdown is not empty. method set_html ( html ) </> Sets html attribute cleaning p tags. Parameters html (str) \u2014 HTML output. method to_tuple ( ) \u2192 (str, str, str) </> Returns a tuple of (name, type, description). Examples >>> item = Item('[x](x)', 'int', 'A parameter.') >>> item.to_tuple() ('[x](x)', 'int', 'A parameter.') method set_type ( type , force=False ) </> Sets type. Parameters type ( Type ) \u2014 force (bool, optional) \u2014 If True, overwrite self regardless of existing type and description. item \u2014 Type instance. See Also Item.update method set_description ( description , force=False ) </> Sets description. Parameters description ( Inline ) \u2014 Inline instance. force (bool, optional) \u2014 If True, overwrite self regardless of existing type and description. See Also Item.update method update ( item , force=False ) </> Updates type and description. Parameters item ( Item ) \u2014 Item instance. force (bool, optional) \u2014 If True, overwrite self regardless of existing type and description. Examples >>> item = Item('x') >>> item2 = Item('x', 'int', 'description') >>> item.update(item2) >>> item.to_tuple() ('x', 'int', 'description') >>> item2 = Item('x', 'str', 'new description') >>> item.update(item2) >>> item.to_tuple() ('x', 'int', 'description') >>> item.update(item2, force=True) >>> item.to_tuple() ('x', 'str', 'new description') >>> item.update(Item('x'), force=True) >>> item.to_tuple() ('x', 'str', 'new description') method copy ( ) </> Returns a copy of the Item instance. dataclass mkapi.core.base . Section ( name='' , markdown='' , items=<factory> , type=<factory> ) </> Bases mkapi.core.base.Base Section class represents a section in docstring. Parameters name (str, optional) \u2014 Name of self. markdown (str, optional) \u2014 Markdown source. items (list of Item , optional) \u2014 List for Arguments, Attributes, or Raises sections, etc. type ( Type , optional) \u2014 Type of self. Attributes callback (callable( Base : str), optional) \u2014 Callback function to modify HTML output. html (str) \u2014 HTML output after conversion. items (list of Item ) \u2014 List for Arguments, Attributes, or Raises sections, etc. markdown (str) \u2014 Markdown source. name (str) \u2014 Name of self. type ( Type ) \u2014 Type of self. Examples >>> items = [Item('x'), Item('[y](a)'), Item('z')] >>> section = Section('Parameters', items=items) >>> section Section('Parameters', num_items=3) >>> list(section) [Item('[y](a)', '')] Methods __bool__ ( ) \u2014 Returns True if the number of items is larger than 0. </> __contains__ ( name ) (bool) \u2014 Returns True if there is an Item instance whose name is equal to name . </> __delitem__ ( name ) \u2014 Delete an Item instance whose name is equal to name . </> __getitem__ ( name ) ( Item ) \u2014 Returns an Item instance whose name is equal to name . </> __iter__ ( ) ( Base ) \u2014 Yields a Base instance that has non empty Markdown. </> copy ( ) \u2014 Returns a copy of the Section instace. </> merge ( section , force ) ( Section ) \u2014 Returns a merged Section </> set_html ( html ) \u2014 Sets HTML output. </> set_item ( item , force ) \u2014 Sets an Item . </> update ( section , force ) \u2014 Updates items. </> method set_html ( html ) </> Sets HTML output. Parameters html (str) \u2014 HTML output. method __bool__ ( ) </> Returns True if the number of items is larger than 0. generator __iter__ ( ) \u2192 Base </> Yields a Base instance that has non empty Markdown. method __getitem__ ( name ) \u2192 Item </> Returns an Item instance whose name is equal to name . If there is no Item instance, a Item instance is newly created. Parameters name (str) \u2014 Item name. Examples >>> section = Section(\"\", items=[Item('x')]) >>> section['x'] Item('x', '') >>> section['y'] Item('y', '') >>> section.items [Item('x', ''), Item('y', '')] method __delitem__ ( name ) </> Delete an Item instance whose name is equal to name . Parameters name (str) \u2014 Item name. method __contains__ ( name ) \u2192 bool </> Returns True if there is an Item instance whose name is equal to name . Parameters name (str) \u2014 Item name. method set_item ( item , force=False ) </> Sets an Item . Parameters item ( Item ) \u2014 Item instance. force (bool, optional) \u2014 If True, overwrite self regardless of existing item. Examples >>> items = [Item('x', 'int'), Item('y', 'str', 'y')] >>> section = Section('Parameters', items=items) >>> section.set_item(Item('x', 'float', 'X')) >>> section['x'].to_tuple() ('x', 'int', 'X') >>> section.set_item(Item('y', 'int', 'Y'), force=True) >>> section['y'].to_tuple() ('y', 'int', 'Y') >>> section.set_item(Item('z', 'float', 'Z')) >>> [item.name for item in section.items] ['x', 'y', 'z'] See Also Section.update method update ( section , force=False ) </> Updates items. Parameters section ( Section ) \u2014 Section instance. force (bool, optional) \u2014 If True, overwrite items of self regardless of existing value. Examples >>> s1 = Section('Parameters', items=[Item('a', 's'), Item('b', 'f')]) >>> s2 = Section('Parameters', items=[Item('a', 'i', 'A'), Item('x', 'd')]) >>> s1.update(s2) >>> s1['a'].to_tuple() ('a', 's', 'A') >>> s1['x'].to_tuple() ('x', 'd', '') >>> s1.update(s2, force=True) >>> s1['a'].to_tuple() ('a', 'i', 'A') >>> s1.items [Item('a', 'i'), Item('b', 'f'), Item('x', 'd')] method merge ( section , force=False ) \u2192 Section </> Returns a merged Section Parameters section ( Section ) \u2014 force (bool, optional) \u2014 Examples >>> s1 = Section('Parameters', items=[Item('a', 's'), Item('b', 'f')]) >>> s2 = Section('Parameters', items=[Item('a', 'i'), Item('c', 'd')]) >>> s3 = s1.merge(s2) >>> s3.items [Item('a', 's'), Item('b', 'f'), Item('c', 'd')] >>> s3 = s1.merge(s2, force=True) >>> s3.items [Item('a', 'i'), Item('b', 'f'), Item('c', 'd')] >>> s3 = s2.merge(s1) >>> s3.items [Item('a', 'i'), Item('c', 'd'), Item('b', 'f')] method copy ( ) </> Returns a copy of the Section instace. Examples >>> s = Section('E', 'markdown', [Item('a', 's'), Item('b', 'i')]) >>> s.copy() Section('E', num_items=2) dataclass mkapi.core.base . Docstring ( sections=<factory> , type=<factory> ) </> Docstring class represents a docstring of an object. Parameters sections (list of Section , optional) \u2014 List of Section instance. type ( Type , optional) \u2014 Type for Returns or Yields sections. Attributes sections (list of Section ) \u2014 List of Section instance. type ( Type ) \u2014 Type for Returns or Yields sections. Examples Empty docstring: >>> docstring = Docstring() >>> assert not docstring Docstring with 3 sections: >>> default = Section(\"\", markdown=\"Default\") >>> parameters = Section(\"Parameters\", items=[Item(\"a\"), Item(\"[b](!a)\")]) >>> returns = Section(\"Returns\", markdown=\"Results\") >>> docstring = Docstring([default, parameters, returns]) >>> docstring Docstring(num_sections=3) Docstring is iterable: >>> list(docstring) [Section('', num_items=0), Item('[b](!a)', ''), Section('Returns', num_items=0)] Indexing: >>> docstring[\"Parameters\"].items[0].name 'a' Section ordering: >>> docstring = Docstring() >>> _ = docstring[''] >>> _ = docstring['Todo'] >>> _ = docstring['Attributes'] >>> _ = docstring['Parameters'] >>> [section.name for section in docstring.sections] ['', 'Parameters', 'Attributes', 'Todo'] Methods __bool__ ( ) \u2014 Returns True if the number of sections is larger than 0. </> __contains__ ( name ) (bool) \u2014 Returns True if there is a Section instance whose name is equal to name . </> __getitem__ ( name ) ( Section ) \u2014 Returns a Section instance whose name is equal to name . </> __iter__ ( ) ( Base ) \u2014 Yields Base instance. </> set_section ( section , force , copy , replace ) \u2014 Sets a Section . </> method __bool__ ( ) </> Returns True if the number of sections is larger than 0. generator __iter__ ( ) \u2192 Base </> Yields Base instance. method __getitem__ ( name ) \u2192 Section </> Returns a Section instance whose name is equal to name . If there is no Section instance, a Section instance is newly created. Parameters name (str) \u2014 Section name. method __contains__ ( name ) \u2192 bool </> Returns True if there is a Section instance whose name is equal to name . Parameters name \u2014 Section name. method set_section ( section , force=False , copy=False , replace=False ) </> Sets a Section . Parameters section ( Section ) \u2014 Section instance. force (bool, optional) \u2014 If True, overwrite self regardless of existing seciton. copy (bool, optional) \u2014 replace (bool, optional) \u2014 Examples >>> items = [Item('x', 'int'), Item('y', 'str', 'y')] >>> s1 = Section('Attributes', items=items) >>> items = [Item('x', 'str', 'X'), Item('z', 'str', 'z')] >>> s2 = Section('Attributes', items=items) >>> doc = Docstring([s1]) >>> doc.set_section(s2) >>> doc['Attributes']['x'].to_tuple() ('x', 'int', 'X') >>> doc['Attributes']['z'].to_tuple() ('z', 'str', 'z') >>> doc.set_section(s2, force=True) >>> doc['Attributes']['x'].to_tuple() ('x', 'str', 'X') >>> items = [Item('x', 'X', 'str'), Item('z', 'z', 'str')] >>> s3 = Section('Parameters', items=items) >>> doc.set_section(s3) >>> doc.sections [Section('Parameters', num_items=2), Section('Attributes', num_items=3)]","title":"mkapi.core.base"},{"location":"api/mkapi.core.base/#mkapicorebase","text":"</> This module provides entity classes to represent docstring structure. Classes Base \u2014 Base class. </> Inline \u2014 Inline class. </> Type \u2014 Type class represents type of Item , Section , Docstring , or Object . </> Item \u2014 Item class represents an item in Parameters, Attributes, and Raises sections, etc. </> Section \u2014 Section class represents a section in docstring. </> Docstring \u2014 Docstring class represents a docstring of an object. </> dataclass","title":"mkapi.core.base"},{"location":"api/mkapi.core.base/#mkapicorebasebase","text":"</> Base class. Parameters name (str, optional) \u2014 Name of self. markdown (str, optional) \u2014 Markdown source. Attributes callback (callable( Base : str), optional) \u2014 Callback function to modify HTML output. html (str) \u2014 HTML output after conversion. markdown (str) \u2014 Markdown source. name (str) \u2014 Name of self. Examples >>> base = Base('x', 'markdown') >>> base Base('x') >>> bool(base) True >>> list(base) [Base('x')] >>> base = Base() >>> bool(base) False >>> list(base) [] Methods __bool__ ( ) (bool) \u2014 Returns True if name is not empty. </> __iter__ ( ) ( Base ) \u2014 Yields self if markdown is not empty. </> copy ( ) \u2014 Returns a copy of the Base instance. </> set_html ( html ) \u2014 Sets HTML output. </> method","title":"mkapi.core.base.Base"},{"location":"api/mkapi.core.base/#mkapicorebasebasebool","text":"</> Returns True if name is not empty. generator","title":"mkapi.core.base.Base.bool"},{"location":"api/mkapi.core.base/#mkapicorebasebaseiter","text":"</> Yields self if markdown is not empty. method","title":"mkapi.core.base.Base.iter"},{"location":"api/mkapi.core.base/#mkapicorebasebaseset_html","text":"</> Sets HTML output. Parameters html (str) \u2014 HTML output. method","title":"mkapi.core.base.Base.set_html"},{"location":"api/mkapi.core.base/#mkapicorebasebasecopy","text":"</> Returns a copy of the Base instance. dataclass","title":"mkapi.core.base.Base.copy"},{"location":"api/mkapi.core.base/#mkapicorebaseinline","text":"</> Bases mkapi.core.base.Base Inline class. Parameters name (str, optional) \u2014 Name of self. Attributes callback (callable( Base : str), optional) \u2014 Callback function to modify HTML output. html (str) \u2014 HTML output after conversion. markdown (str) \u2014 Markdown source. name (str) \u2014 Name of self. Examples >>> inline = Inline() >>> bool(inline) False >>> inline = Inline('markdown') >>> inline.name == inline.markdown True >>> inline Inline('markdown') >>> bool(inline) True >>> next(iter(inline)) is inline True >>> inline.set_html(\"<p>p1</p><p>p2</p>\") >>> inline.html 'p1<br>p2' >>> inline.copy() Inline('markdown') Methods __bool__ ( ) (bool) \u2014 Returns True if name is not empty. </> __iter__ ( ) ( Base ) \u2014 Yields self if markdown is not empty. </> copy ( ) \u2014 Returns a copy of the Inline instance. </> set_html ( html ) \u2014 Sets html attribute cleaning p tags. </> method","title":"mkapi.core.base.Inline"},{"location":"api/mkapi.core.base/#mkapicorebasebasebool_1","text":"</> Returns True if name is not empty. generator","title":"mkapi.core.base.Base.bool"},{"location":"api/mkapi.core.base/#mkapicorebasebaseiter_1","text":"</> Yields self if markdown is not empty. method","title":"mkapi.core.base.Base.iter"},{"location":"api/mkapi.core.base/#mkapicorebaseinlineset_html","text":"</> Sets html attribute cleaning p tags. Parameters html (str) \u2014 HTML output. method","title":"mkapi.core.base.Inline.set_html"},{"location":"api/mkapi.core.base/#mkapicorebaseinlinecopy","text":"</> Returns a copy of the Inline instance. dataclass","title":"mkapi.core.base.Inline.copy"},{"location":"api/mkapi.core.base/#mkapicorebasetype","text":"</> Bases mkapi.core.base.Inline mkapi.core.base.Base Type class represents type of Item , Section , Docstring , or Object . Parameters name (str, optional) \u2014 Name of self. Attributes callback (callable( Base : str), optional) \u2014 Callback function to modify HTML output. html (str) \u2014 HTML output after conversion. markdown (str) \u2014 Markdown source. name (str) \u2014 Name of self. Examples >>> a = Type('str') >>> a Type('str') >>> list(a) [] >>> b = Type('[Object](base.Object)') >>> b.markdown '[Object](base.Object)' >>> list(b) [Type('[Object](base.Object)')] >>> a.copy() Type('str') Methods __bool__ ( ) (bool) \u2014 Returns True if name is not empty. </> __iter__ ( ) ( Base ) \u2014 Yields self if markdown is not empty. </> copy ( ) \u2014 Returns a copy of the Type instance. </> set_html ( html ) \u2014 Sets html attribute cleaning p tags. </> method","title":"mkapi.core.base.Type"},{"location":"api/mkapi.core.base/#mkapicorebasebasebool_2","text":"</> Returns True if name is not empty. generator","title":"mkapi.core.base.Base.bool"},{"location":"api/mkapi.core.base/#mkapicorebasebaseiter_2","text":"</> Yields self if markdown is not empty. method","title":"mkapi.core.base.Base.iter"},{"location":"api/mkapi.core.base/#mkapicorebaseinlineset_html_1","text":"</> Sets html attribute cleaning p tags. Parameters html (str) \u2014 HTML output. method","title":"mkapi.core.base.Inline.set_html"},{"location":"api/mkapi.core.base/#mkapicorebaseinlinecopy_1","text":"</> Returns a copy of the Type instance. dataclass","title":"mkapi.core.base.Inline.copy"},{"location":"api/mkapi.core.base/#mkapicorebaseitem","text":"</> Bases mkapi.core.base.Type mkapi.core.base.Inline mkapi.core.base.Base Item class represents an item in Parameters, Attributes, and Raises sections, etc. Parameters name (str, optional) \u2014 Name of self. type ( Type , optional) \u2014 Type of self. description ( Inline , optional) \u2014 Description of self. kind (str, optional) \u2014 Kind of self, for example readonly_property . This value is rendered as a class attribute in HTML. Attributes callback (callable( Base : str), optional) \u2014 Callback function to modify HTML output. description ( Inline ) \u2014 Description of self. html (str) \u2014 HTML output after conversion. kind (str) \u2014 Kind of self, for example readonly_property . This value is rendered as a class attribute in HTML. markdown (str) \u2014 Markdown source. name (str) \u2014 Name of self. type ( Type ) \u2014 Type of self. Examples >>> item = Item('[x](x)', Type('int'), Inline('A parameter.')) >>> item Item('[x](x)', 'int') >>> item.name, item.markdown, item.html ('[x](x)', '[x](x)', '') >>> item.type Type('int') >>> item.description Inline('A parameter.') >>> item = Item('[x](x)', 'str', 'A parameter.') >>> item.type Type('str') >>> it = iter(item) >>> next(it) is item True >>> next(it) is item.description True >>> item.set_html('<p><strong>init</strong></p>') >>> item.html '__init__' Methods __bool__ ( ) (bool) \u2014 Returns True if name is not empty. </> __iter__ ( ) ( Base ) \u2014 Yields self if markdown is not empty. </> copy ( ) \u2014 Returns a copy of the Item instance. </> set_description ( description , force ) \u2014 Sets description. </> set_html ( html ) \u2014 Sets html attribute cleaning p tags. </> set_type ( type , force ) \u2014 Sets type. </> to_tuple ( ) (str, str, str) \u2014 Returns a tuple of (name, type, description). </> update ( item , force ) \u2014 Updates type and description. </> method","title":"mkapi.core.base.Item"},{"location":"api/mkapi.core.base/#mkapicorebasebasebool_3","text":"</> Returns True if name is not empty. generator","title":"mkapi.core.base.Base.bool"},{"location":"api/mkapi.core.base/#mkapicorebaseitemiter","text":"</> Yields self if markdown is not empty. method","title":"mkapi.core.base.Item.iter"},{"location":"api/mkapi.core.base/#mkapicorebaseitemset_html","text":"</> Sets html attribute cleaning p tags. Parameters html (str) \u2014 HTML output. method","title":"mkapi.core.base.Item.set_html"},{"location":"api/mkapi.core.base/#mkapicorebaseitemto_tuple","text":"</> Returns a tuple of (name, type, description). Examples >>> item = Item('[x](x)', 'int', 'A parameter.') >>> item.to_tuple() ('[x](x)', 'int', 'A parameter.') method","title":"mkapi.core.base.Item.to_tuple"},{"location":"api/mkapi.core.base/#mkapicorebaseitemset_type","text":"</> Sets type. Parameters type ( Type ) \u2014 force (bool, optional) \u2014 If True, overwrite self regardless of existing type and description. item \u2014 Type instance. See Also Item.update method","title":"mkapi.core.base.Item.set_type"},{"location":"api/mkapi.core.base/#mkapicorebaseitemset_description","text":"</> Sets description. Parameters description ( Inline ) \u2014 Inline instance. force (bool, optional) \u2014 If True, overwrite self regardless of existing type and description. See Also Item.update method","title":"mkapi.core.base.Item.set_description"},{"location":"api/mkapi.core.base/#mkapicorebaseitemupdate","text":"</> Updates type and description. Parameters item ( Item ) \u2014 Item instance. force (bool, optional) \u2014 If True, overwrite self regardless of existing type and description. Examples >>> item = Item('x') >>> item2 = Item('x', 'int', 'description') >>> item.update(item2) >>> item.to_tuple() ('x', 'int', 'description') >>> item2 = Item('x', 'str', 'new description') >>> item.update(item2) >>> item.to_tuple() ('x', 'int', 'description') >>> item.update(item2, force=True) >>> item.to_tuple() ('x', 'str', 'new description') >>> item.update(Item('x'), force=True) >>> item.to_tuple() ('x', 'str', 'new description') method","title":"mkapi.core.base.Item.update"},{"location":"api/mkapi.core.base/#mkapicorebaseitemcopy","text":"</> Returns a copy of the Item instance. dataclass","title":"mkapi.core.base.Item.copy"},{"location":"api/mkapi.core.base/#mkapicorebasesection","text":"</> Bases mkapi.core.base.Base Section class represents a section in docstring. Parameters name (str, optional) \u2014 Name of self. markdown (str, optional) \u2014 Markdown source. items (list of Item , optional) \u2014 List for Arguments, Attributes, or Raises sections, etc. type ( Type , optional) \u2014 Type of self. Attributes callback (callable( Base : str), optional) \u2014 Callback function to modify HTML output. html (str) \u2014 HTML output after conversion. items (list of Item ) \u2014 List for Arguments, Attributes, or Raises sections, etc. markdown (str) \u2014 Markdown source. name (str) \u2014 Name of self. type ( Type ) \u2014 Type of self. Examples >>> items = [Item('x'), Item('[y](a)'), Item('z')] >>> section = Section('Parameters', items=items) >>> section Section('Parameters', num_items=3) >>> list(section) [Item('[y](a)', '')] Methods __bool__ ( ) \u2014 Returns True if the number of items is larger than 0. </> __contains__ ( name ) (bool) \u2014 Returns True if there is an Item instance whose name is equal to name . </> __delitem__ ( name ) \u2014 Delete an Item instance whose name is equal to name . </> __getitem__ ( name ) ( Item ) \u2014 Returns an Item instance whose name is equal to name . </> __iter__ ( ) ( Base ) \u2014 Yields a Base instance that has non empty Markdown. </> copy ( ) \u2014 Returns a copy of the Section instace. </> merge ( section , force ) ( Section ) \u2014 Returns a merged Section </> set_html ( html ) \u2014 Sets HTML output. </> set_item ( item , force ) \u2014 Sets an Item . </> update ( section , force ) \u2014 Updates items. </> method","title":"mkapi.core.base.Section"},{"location":"api/mkapi.core.base/#mkapicorebasebaseset_html_1","text":"</> Sets HTML output. Parameters html (str) \u2014 HTML output. method","title":"mkapi.core.base.Base.set_html"},{"location":"api/mkapi.core.base/#mkapicorebasesectionbool","text":"</> Returns True if the number of items is larger than 0. generator","title":"mkapi.core.base.Section.bool"},{"location":"api/mkapi.core.base/#mkapicorebasesectioniter","text":"</> Yields a Base instance that has non empty Markdown. method","title":"mkapi.core.base.Section.iter"},{"location":"api/mkapi.core.base/#mkapicorebasesectiongetitem","text":"</> Returns an Item instance whose name is equal to name . If there is no Item instance, a Item instance is newly created. Parameters name (str) \u2014 Item name. Examples >>> section = Section(\"\", items=[Item('x')]) >>> section['x'] Item('x', '') >>> section['y'] Item('y', '') >>> section.items [Item('x', ''), Item('y', '')] method","title":"mkapi.core.base.Section.getitem"},{"location":"api/mkapi.core.base/#mkapicorebasesectiondelitem","text":"</> Delete an Item instance whose name is equal to name . Parameters name (str) \u2014 Item name. method","title":"mkapi.core.base.Section.delitem"},{"location":"api/mkapi.core.base/#mkapicorebasesectioncontains","text":"</> Returns True if there is an Item instance whose name is equal to name . Parameters name (str) \u2014 Item name. method","title":"mkapi.core.base.Section.contains"},{"location":"api/mkapi.core.base/#mkapicorebasesectionset_item","text":"</> Sets an Item . Parameters item ( Item ) \u2014 Item instance. force (bool, optional) \u2014 If True, overwrite self regardless of existing item. Examples >>> items = [Item('x', 'int'), Item('y', 'str', 'y')] >>> section = Section('Parameters', items=items) >>> section.set_item(Item('x', 'float', 'X')) >>> section['x'].to_tuple() ('x', 'int', 'X') >>> section.set_item(Item('y', 'int', 'Y'), force=True) >>> section['y'].to_tuple() ('y', 'int', 'Y') >>> section.set_item(Item('z', 'float', 'Z')) >>> [item.name for item in section.items] ['x', 'y', 'z'] See Also Section.update method","title":"mkapi.core.base.Section.set_item"},{"location":"api/mkapi.core.base/#mkapicorebasesectionupdate","text":"</> Updates items. Parameters section ( Section ) \u2014 Section instance. force (bool, optional) \u2014 If True, overwrite items of self regardless of existing value. Examples >>> s1 = Section('Parameters', items=[Item('a', 's'), Item('b', 'f')]) >>> s2 = Section('Parameters', items=[Item('a', 'i', 'A'), Item('x', 'd')]) >>> s1.update(s2) >>> s1['a'].to_tuple() ('a', 's', 'A') >>> s1['x'].to_tuple() ('x', 'd', '') >>> s1.update(s2, force=True) >>> s1['a'].to_tuple() ('a', 'i', 'A') >>> s1.items [Item('a', 'i'), Item('b', 'f'), Item('x', 'd')] method","title":"mkapi.core.base.Section.update"},{"location":"api/mkapi.core.base/#mkapicorebasesectionmerge","text":"</> Returns a merged Section Parameters section ( Section ) \u2014 force (bool, optional) \u2014 Examples >>> s1 = Section('Parameters', items=[Item('a', 's'), Item('b', 'f')]) >>> s2 = Section('Parameters', items=[Item('a', 'i'), Item('c', 'd')]) >>> s3 = s1.merge(s2) >>> s3.items [Item('a', 's'), Item('b', 'f'), Item('c', 'd')] >>> s3 = s1.merge(s2, force=True) >>> s3.items [Item('a', 'i'), Item('b', 'f'), Item('c', 'd')] >>> s3 = s2.merge(s1) >>> s3.items [Item('a', 'i'), Item('c', 'd'), Item('b', 'f')] method","title":"mkapi.core.base.Section.merge"},{"location":"api/mkapi.core.base/#mkapicorebasesectioncopy","text":"</> Returns a copy of the Section instace. Examples >>> s = Section('E', 'markdown', [Item('a', 's'), Item('b', 'i')]) >>> s.copy() Section('E', num_items=2) dataclass","title":"mkapi.core.base.Section.copy"},{"location":"api/mkapi.core.base/#mkapicorebasedocstring","text":"</> Docstring class represents a docstring of an object. Parameters sections (list of Section , optional) \u2014 List of Section instance. type ( Type , optional) \u2014 Type for Returns or Yields sections. Attributes sections (list of Section ) \u2014 List of Section instance. type ( Type ) \u2014 Type for Returns or Yields sections. Examples Empty docstring: >>> docstring = Docstring() >>> assert not docstring Docstring with 3 sections: >>> default = Section(\"\", markdown=\"Default\") >>> parameters = Section(\"Parameters\", items=[Item(\"a\"), Item(\"[b](!a)\")]) >>> returns = Section(\"Returns\", markdown=\"Results\") >>> docstring = Docstring([default, parameters, returns]) >>> docstring Docstring(num_sections=3) Docstring is iterable: >>> list(docstring) [Section('', num_items=0), Item('[b](!a)', ''), Section('Returns', num_items=0)] Indexing: >>> docstring[\"Parameters\"].items[0].name 'a' Section ordering: >>> docstring = Docstring() >>> _ = docstring[''] >>> _ = docstring['Todo'] >>> _ = docstring['Attributes'] >>> _ = docstring['Parameters'] >>> [section.name for section in docstring.sections] ['', 'Parameters', 'Attributes', 'Todo'] Methods __bool__ ( ) \u2014 Returns True if the number of sections is larger than 0. </> __contains__ ( name ) (bool) \u2014 Returns True if there is a Section instance whose name is equal to name . </> __getitem__ ( name ) ( Section ) \u2014 Returns a Section instance whose name is equal to name . </> __iter__ ( ) ( Base ) \u2014 Yields Base instance. </> set_section ( section , force , copy , replace ) \u2014 Sets a Section . </> method","title":"mkapi.core.base.Docstring"},{"location":"api/mkapi.core.base/#mkapicorebasedocstringbool","text":"</> Returns True if the number of sections is larger than 0. generator","title":"mkapi.core.base.Docstring.bool"},{"location":"api/mkapi.core.base/#mkapicorebasedocstringiter","text":"</> Yields Base instance. method","title":"mkapi.core.base.Docstring.iter"},{"location":"api/mkapi.core.base/#mkapicorebasedocstringgetitem","text":"</> Returns a Section instance whose name is equal to name . If there is no Section instance, a Section instance is newly created. Parameters name (str) \u2014 Section name. method","title":"mkapi.core.base.Docstring.getitem"},{"location":"api/mkapi.core.base/#mkapicorebasedocstringcontains","text":"</> Returns True if there is a Section instance whose name is equal to name . Parameters name \u2014 Section name. method","title":"mkapi.core.base.Docstring.contains"},{"location":"api/mkapi.core.base/#mkapicorebasedocstringset_section","text":"</> Sets a Section . Parameters section ( Section ) \u2014 Section instance. force (bool, optional) \u2014 If True, overwrite self regardless of existing seciton. copy (bool, optional) \u2014 replace (bool, optional) \u2014 Examples >>> items = [Item('x', 'int'), Item('y', 'str', 'y')] >>> s1 = Section('Attributes', items=items) >>> items = [Item('x', 'str', 'X'), Item('z', 'str', 'z')] >>> s2 = Section('Attributes', items=items) >>> doc = Docstring([s1]) >>> doc.set_section(s2) >>> doc['Attributes']['x'].to_tuple() ('x', 'int', 'X') >>> doc['Attributes']['z'].to_tuple() ('z', 'str', 'z') >>> doc.set_section(s2, force=True) >>> doc['Attributes']['x'].to_tuple() ('x', 'str', 'X') >>> items = [Item('x', 'X', 'str'), Item('z', 'z', 'str')] >>> s3 = Section('Parameters', items=items) >>> doc.set_section(s3) >>> doc.sections [Section('Parameters', num_items=2), Section('Attributes', num_items=3)]","title":"mkapi.core.base.Docstring.set_section"},{"location":"api/mkapi.core.docstring/","text":"MODULE MKAPI.CORE . DOCSTRING </> This module provides functions that parse docstring. Functions get_docstring ( obj ) ( Docstring ) \u2014 Returns a Docstring instance. </> get_section ( name , doc , style ) ( Section ) \u2014 Returns a Section instance. </> parse_bases ( doc , obj ) \u2014 Parses base classes to create a Base(s) line. </> parse_parameter ( lines , style ) ( Item ) \u2014 Returns a Item instance that represents a parameter. </> parse_parameters ( doc , style ) (list of Item ) \u2014 Returns a list of Item. </> parse_returns ( doc , style ) (str, str) \u2014 Returns a tuple of (type, markdown). </> parse_source ( doc , obj ) \u2014 Parses parameters' docstring to inspect type and description from source. </> section_heading ( line ) (str, str) \u2014 Returns a tuple of (section name, style name). </> split_parameter ( doc ) (list of str) \u2014 Yields a list of parameter string. </> split_section ( doc ) (str, str, str) \u2014 Yields a tuple of (section name, contents, style). </> function mkapi.core.docstring . section_heading ( line ) \u2192 (str, str) </> Returns a tuple of (section name, style name). Parameters line (str) \u2014 Docstring line. Examples >>> section_heading(\"Args:\") ('Args', 'google') >>> section_heading(\"Raises\") ('Raises', 'numpy') >>> section_heading(\"other\") ('', '') generator mkapi.core.docstring . split_section ( doc ) \u2192 (str, str, str) </> Yields a tuple of (section name, contents, style). Parameters doc (str) \u2014 Docstring Examples >>> doc = \"abc\\n\\nArgs:\\n x: X\\n\" >>> it = split_section(doc) >>> next(it) ('', 'abc', '') >>> next(it) ('Parameters', 'x: X', 'google') generator mkapi.core.docstring . split_parameter ( doc ) \u2192 list of str </> Yields a list of parameter string. Parameters doc (str) \u2014 Docstring function mkapi.core.docstring . parse_parameter ( lines , style ) \u2192 Item </> Returns a Item instance that represents a parameter. Parameters lines (list of str) \u2014 Splitted parameter docstring lines. style (str) \u2014 Docstring style. google or numpy . function mkapi.core.docstring . parse_parameters ( doc , style ) \u2192 list of Item </> Returns a list of Item. Parameters doc (str) \u2014 style (str) \u2014 function mkapi.core.docstring . parse_returns ( doc , style ) \u2192 (str, str) </> Returns a tuple of (type, markdown). Parameters doc (str) \u2014 style (str) \u2014 function mkapi.core.docstring . get_section ( name , doc , style ) \u2192 Section </> Returns a Section instance. Parameters name (str) \u2014 doc (str) \u2014 style (str) \u2014 function mkapi.core.docstring . parse_bases ( doc , obj ) </> Parses base classes to create a Base(s) line. Parameters doc ( Docstring ) \u2014 obj (any) \u2014 function mkapi.core.docstring . parse_source ( doc , obj ) </> Parses parameters' docstring to inspect type and description from source. Parameters doc ( Docstring ) \u2014 obj (any) \u2014 Examples >>> from mkapi.core.base import Base >>> doc = Docstring() >>> parse_source(doc, Base) >>> section = doc['Parameters'] >>> section['name'].to_tuple() ('name', 'str, optional', 'Name of self.') >>> section = doc['Attributes'] >>> section['html'].to_tuple() ('html', 'str', 'HTML output after conversion.') function mkapi.core.docstring . get_docstring ( obj ) \u2192 Docstring </> Returns a Docstring instance. Parameters obj (any) \u2014","title":"mkapi.core.docstring"},{"location":"api/mkapi.core.docstring/#mkapicoredocstring","text":"</> This module provides functions that parse docstring. Functions get_docstring ( obj ) ( Docstring ) \u2014 Returns a Docstring instance. </> get_section ( name , doc , style ) ( Section ) \u2014 Returns a Section instance. </> parse_bases ( doc , obj ) \u2014 Parses base classes to create a Base(s) line. </> parse_parameter ( lines , style ) ( Item ) \u2014 Returns a Item instance that represents a parameter. </> parse_parameters ( doc , style ) (list of Item ) \u2014 Returns a list of Item. </> parse_returns ( doc , style ) (str, str) \u2014 Returns a tuple of (type, markdown). </> parse_source ( doc , obj ) \u2014 Parses parameters' docstring to inspect type and description from source. </> section_heading ( line ) (str, str) \u2014 Returns a tuple of (section name, style name). </> split_parameter ( doc ) (list of str) \u2014 Yields a list of parameter string. </> split_section ( doc ) (str, str, str) \u2014 Yields a tuple of (section name, contents, style). </> function","title":"mkapi.core.docstring"},{"location":"api/mkapi.core.docstring/#mkapicoredocstringsection_heading","text":"</> Returns a tuple of (section name, style name). Parameters line (str) \u2014 Docstring line. Examples >>> section_heading(\"Args:\") ('Args', 'google') >>> section_heading(\"Raises\") ('Raises', 'numpy') >>> section_heading(\"other\") ('', '') generator","title":"mkapi.core.docstring.section_heading"},{"location":"api/mkapi.core.docstring/#mkapicoredocstringsplit_section","text":"</> Yields a tuple of (section name, contents, style). Parameters doc (str) \u2014 Docstring Examples >>> doc = \"abc\\n\\nArgs:\\n x: X\\n\" >>> it = split_section(doc) >>> next(it) ('', 'abc', '') >>> next(it) ('Parameters', 'x: X', 'google') generator","title":"mkapi.core.docstring.split_section"},{"location":"api/mkapi.core.docstring/#mkapicoredocstringsplit_parameter","text":"</> Yields a list of parameter string. Parameters doc (str) \u2014 Docstring function","title":"mkapi.core.docstring.split_parameter"},{"location":"api/mkapi.core.docstring/#mkapicoredocstringparse_parameter","text":"</> Returns a Item instance that represents a parameter. Parameters lines (list of str) \u2014 Splitted parameter docstring lines. style (str) \u2014 Docstring style. google or numpy . function","title":"mkapi.core.docstring.parse_parameter"},{"location":"api/mkapi.core.docstring/#mkapicoredocstringparse_parameters","text":"</> Returns a list of Item. Parameters doc (str) \u2014 style (str) \u2014 function","title":"mkapi.core.docstring.parse_parameters"},{"location":"api/mkapi.core.docstring/#mkapicoredocstringparse_returns","text":"</> Returns a tuple of (type, markdown). Parameters doc (str) \u2014 style (str) \u2014 function","title":"mkapi.core.docstring.parse_returns"},{"location":"api/mkapi.core.docstring/#mkapicoredocstringget_section","text":"</> Returns a Section instance. Parameters name (str) \u2014 doc (str) \u2014 style (str) \u2014 function","title":"mkapi.core.docstring.get_section"},{"location":"api/mkapi.core.docstring/#mkapicoredocstringparse_bases","text":"</> Parses base classes to create a Base(s) line. Parameters doc ( Docstring ) \u2014 obj (any) \u2014 function","title":"mkapi.core.docstring.parse_bases"},{"location":"api/mkapi.core.docstring/#mkapicoredocstringparse_source","text":"</> Parses parameters' docstring to inspect type and description from source. Parameters doc ( Docstring ) \u2014 obj (any) \u2014 Examples >>> from mkapi.core.base import Base >>> doc = Docstring() >>> parse_source(doc, Base) >>> section = doc['Parameters'] >>> section['name'].to_tuple() ('name', 'str, optional', 'Name of self.') >>> section = doc['Attributes'] >>> section['html'].to_tuple() ('html', 'str', 'HTML output after conversion.') function","title":"mkapi.core.docstring.parse_source"},{"location":"api/mkapi.core.docstring/#mkapicoredocstringget_docstring","text":"</> Returns a Docstring instance. Parameters obj (any) \u2014","title":"mkapi.core.docstring.get_docstring"},{"location":"api/mkapi.core.inherit/","text":"MODULE MKAPI.CORE . INHERIT </> This module implements the functionality of docstring inheritance. Functions get_bases ( node ) ( Node , iterator of Node ) \u2014 Yields a tuple of (Node instance, iterator of Node). </> get_section ( node , name , mode ) ( Section ) \u2014 Returns a tuple of (docstring section, signature section). </> inherit ( node ) \u2014 Inherits Parameters and Attributes from superclasses. </> inherit_base ( node , base , name ) \u2014 Inherits Parameters or Attributes section from base class. </> is_complete ( node , name ) (bool) \u2014 Returns True if docstring is complete. </> function mkapi.core.inherit . get_section ( node , name , mode ) \u2192 Section </> Returns a tuple of (docstring section, signature section). Parameters node ( Node ) \u2014 Node instance. name (str) \u2014 Section name: Parameters or Attributes . mode (str) \u2014 Mode name: Docstring or Signature . Examples >>> node = get_node('mkapi.core.base.Type') >>> section = get_section(node, 'Parameters', 'Docstring') >>> 'name' in section True >>> section['name'].to_tuple() ('name', 'str, optional', '') function mkapi.core.inherit . is_complete ( node , name='both' ) \u2192 bool </> Returns True if docstring is complete. Parameters node ( Node ) \u2014 Node instance. name (str, optional) \u2014 Section name: 'Parameters' or 'Attributes', or 'both'. If name is 'both', both sections are checked. Examples >>> from mkapi.core.object import get_object >>> node = Node(get_object('mkapi.core.base.Base')) >>> is_complete(node, 'Parameters') True >>> node = Node(get_object('mkapi.core.base.Type')) >>> is_complete(node) False function mkapi.core.inherit . inherit_base ( node , base , name='both' ) </> Inherits Parameters or Attributes section from base class. Parameters node ( Node ) \u2014 Node instance. base ( Node ) \u2014 Node instance of a super class. name (str, optional) \u2014 Section name: 'Parameters' or 'Attributes', or 'both'. If name is 'both', both sections are inherited. Examples >>> from mkapi.core.object import get_object >>> base = Node(get_object('mkapi.core.base.Base')) >>> node = Node(get_object('mkapi.core.base.Type')) >>> node.docstring['Parameters']['name'].to_tuple() ('name', 'str, optional', '') >>> inherit_base(node, base) >>> node.docstring['Parameters']['name'].to_tuple() ('name', 'str, optional', 'Name of self.') generator mkapi.core.inherit . get_bases ( node ) \u2192 ( Node , iterator of Node ) </> Yields a tuple of (Node instance, iterator of Node). Parameters node ( Node ) \u2014 Node instance. Examples >>> from mkapi.core.object import get_object >>> node = Node(get_object('mkapi.core.base.Type')) >>> it = get_bases(node) >>> n, gen = next(it) >>> n is node True >>> [x.object.name for x in gen] ['Inline', 'Base'] >>> for n, gen in it: ... if n.object.name == 'set_html': ... break >>> [x.object.name for x in gen] ['set_html', 'set_html'] function mkapi.core.inherit . inherit ( node ) </> Inherits Parameters and Attributes from superclasses. Parameters node ( Node ) \u2014 Node instance.","title":"mkapi.core.inherit"},{"location":"api/mkapi.core.inherit/#mkapicoreinherit","text":"</> This module implements the functionality of docstring inheritance. Functions get_bases ( node ) ( Node , iterator of Node ) \u2014 Yields a tuple of (Node instance, iterator of Node). </> get_section ( node , name , mode ) ( Section ) \u2014 Returns a tuple of (docstring section, signature section). </> inherit ( node ) \u2014 Inherits Parameters and Attributes from superclasses. </> inherit_base ( node , base , name ) \u2014 Inherits Parameters or Attributes section from base class. </> is_complete ( node , name ) (bool) \u2014 Returns True if docstring is complete. </> function","title":"mkapi.core.inherit"},{"location":"api/mkapi.core.inherit/#mkapicoreinheritget_section","text":"</> Returns a tuple of (docstring section, signature section). Parameters node ( Node ) \u2014 Node instance. name (str) \u2014 Section name: Parameters or Attributes . mode (str) \u2014 Mode name: Docstring or Signature . Examples >>> node = get_node('mkapi.core.base.Type') >>> section = get_section(node, 'Parameters', 'Docstring') >>> 'name' in section True >>> section['name'].to_tuple() ('name', 'str, optional', '') function","title":"mkapi.core.inherit.get_section"},{"location":"api/mkapi.core.inherit/#mkapicoreinheritis_complete","text":"</> Returns True if docstring is complete. Parameters node ( Node ) \u2014 Node instance. name (str, optional) \u2014 Section name: 'Parameters' or 'Attributes', or 'both'. If name is 'both', both sections are checked. Examples >>> from mkapi.core.object import get_object >>> node = Node(get_object('mkapi.core.base.Base')) >>> is_complete(node, 'Parameters') True >>> node = Node(get_object('mkapi.core.base.Type')) >>> is_complete(node) False function","title":"mkapi.core.inherit.is_complete"},{"location":"api/mkapi.core.inherit/#mkapicoreinheritinherit_base","text":"</> Inherits Parameters or Attributes section from base class. Parameters node ( Node ) \u2014 Node instance. base ( Node ) \u2014 Node instance of a super class. name (str, optional) \u2014 Section name: 'Parameters' or 'Attributes', or 'both'. If name is 'both', both sections are inherited. Examples >>> from mkapi.core.object import get_object >>> base = Node(get_object('mkapi.core.base.Base')) >>> node = Node(get_object('mkapi.core.base.Type')) >>> node.docstring['Parameters']['name'].to_tuple() ('name', 'str, optional', '') >>> inherit_base(node, base) >>> node.docstring['Parameters']['name'].to_tuple() ('name', 'str, optional', 'Name of self.') generator","title":"mkapi.core.inherit.inherit_base"},{"location":"api/mkapi.core.inherit/#mkapicoreinheritget_bases","text":"</> Yields a tuple of (Node instance, iterator of Node). Parameters node ( Node ) \u2014 Node instance. Examples >>> from mkapi.core.object import get_object >>> node = Node(get_object('mkapi.core.base.Type')) >>> it = get_bases(node) >>> n, gen = next(it) >>> n is node True >>> [x.object.name for x in gen] ['Inline', 'Base'] >>> for n, gen in it: ... if n.object.name == 'set_html': ... break >>> [x.object.name for x in gen] ['set_html', 'set_html'] function","title":"mkapi.core.inherit.get_bases"},{"location":"api/mkapi.core.inherit/#mkapicoreinheritinherit","text":"</> Inherits Parameters and Attributes from superclasses. Parameters node ( Node ) \u2014 Node instance.","title":"mkapi.core.inherit.inherit"},{"location":"api/mkapi.core.linker/","text":"MODULE MKAPI.CORE . LINKER </> This module provides functions that relate to link. Functions get_link ( obj , include_module ) (str) \u2014 Returns Markdown link for object, if possible. </> link ( name , href ) (str) \u2014 Reutrns Markdown link with a mark that indicates this link was created by MkApi. </> replace_link ( obj , markdown ) (str) \u2014 Returns a replaced link with object full name. </> resolve_link ( markdown , abs_src_path , abs_api_paths ) (str) \u2014 Reutrns resolved link. </> resolve_object ( html ) (dict(str: any)) \u2014 Reutrns an object context dictionary. </> function mkapi.core.linker . link ( name , href ) \u2192 str </> Reutrns Markdown link with a mark that indicates this link was created by MkApi. Parameters name (str) \u2014 Link name. href (str) \u2014 Reference. Examples >>> link('abc', 'xyz') '[abc](!xyz)' function mkapi.core.linker . get_link ( obj , include_module=False ) \u2192 str </> Returns Markdown link for object, if possible. Parameters obj (any) \u2014 Object include_module (bool, optional) \u2014 If True, link text includes module path. Examples >>> get_link(get_fullname) '[get_fullname](!mkapi.core.object.get_fullname)' >>> get_link(get_fullname, include_module=True) '[mkapi.core.object.get_fullname](!mkapi.core.object.get_fullname)' function mkapi.core.linker . resolve_link ( markdown , abs_src_path , abs_api_paths ) \u2192 str </> Reutrns resolved link. Parameters markdown (str) \u2014 Markdown source. abs_src_path (str) \u2014 Absolute source path of Markdown. abs_api_paths (list of str) \u2014 A list of API paths. Examples >>> abs_src_path = '/src/examples/example.md' >>> abs_api_paths = ['/api/a','/api/b', '/api/b.c'] >>> resolve_link('[abc](!b.c.d)', abs_src_path, abs_api_paths) '[abc](../../api/b.c#b.c.d)' function mkapi.core.linker . resolve_object ( html ) \u2192 dict(str: any) </> Reutrns an object context dictionary. Parameters html (str) \u2014 HTML source. Examples >>> resolve_object(\"<p><a href='a'>p</a><a href='b'>n</a></p>\") {'heading_id': '', 'level': 0, 'prefix_url': 'a', 'name_url': 'b'} >>> resolve_object(\"<h2 id='i'><a href='a'>p</a><a href='b'>n</a></h2>\") {'heading_id': 'i', 'level': 2, 'prefix_url': 'a', 'name_url': 'b'} function mkapi.core.linker . replace_link ( obj , markdown ) \u2192 str </> Returns a replaced link with object full name. Parameters obj (any) \u2014 Object that has a module. markdown (str) \u2014 Markdown Examples >>> from mkapi.core.object import get_object >>> obj = get_object('mkapi.core.structure.Object') >>> replace_link(obj, '[Signature]()') '[Signature](!mkapi.core.signature.Signature)' >>> replace_link(obj, '[](Signature)') '[Signature](!mkapi.core.signature.Signature)' >>> replace_link(obj, '[text](Signature)') '[text](!mkapi.core.signature.Signature)' >>> replace_link(obj, '[dummy.Dummy]()') '[dummy.Dummy]()' >>> replace_link(obj, 'Signature_') '[Signature](!mkapi.core.signature.Signature)'","title":"mkapi.core.linker"},{"location":"api/mkapi.core.linker/#mkapicorelinker","text":"</> This module provides functions that relate to link. Functions get_link ( obj , include_module ) (str) \u2014 Returns Markdown link for object, if possible. </> link ( name , href ) (str) \u2014 Reutrns Markdown link with a mark that indicates this link was created by MkApi. </> replace_link ( obj , markdown ) (str) \u2014 Returns a replaced link with object full name. </> resolve_link ( markdown , abs_src_path , abs_api_paths ) (str) \u2014 Reutrns resolved link. </> resolve_object ( html ) (dict(str: any)) \u2014 Reutrns an object context dictionary. </> function","title":"mkapi.core.linker"},{"location":"api/mkapi.core.linker/#mkapicorelinkerlink","text":"</> Reutrns Markdown link with a mark that indicates this link was created by MkApi. Parameters name (str) \u2014 Link name. href (str) \u2014 Reference. Examples >>> link('abc', 'xyz') '[abc](!xyz)' function","title":"mkapi.core.linker.link"},{"location":"api/mkapi.core.linker/#mkapicorelinkerget_link","text":"</> Returns Markdown link for object, if possible. Parameters obj (any) \u2014 Object include_module (bool, optional) \u2014 If True, link text includes module path. Examples >>> get_link(get_fullname) '[get_fullname](!mkapi.core.object.get_fullname)' >>> get_link(get_fullname, include_module=True) '[mkapi.core.object.get_fullname](!mkapi.core.object.get_fullname)' function","title":"mkapi.core.linker.get_link"},{"location":"api/mkapi.core.linker/#mkapicorelinkerresolve_link","text":"</> Reutrns resolved link. Parameters markdown (str) \u2014 Markdown source. abs_src_path (str) \u2014 Absolute source path of Markdown. abs_api_paths (list of str) \u2014 A list of API paths. Examples >>> abs_src_path = '/src/examples/example.md' >>> abs_api_paths = ['/api/a','/api/b', '/api/b.c'] >>> resolve_link('[abc](!b.c.d)', abs_src_path, abs_api_paths) '[abc](../../api/b.c#b.c.d)' function","title":"mkapi.core.linker.resolve_link"},{"location":"api/mkapi.core.linker/#mkapicorelinkerresolve_object","text":"</> Reutrns an object context dictionary. Parameters html (str) \u2014 HTML source. Examples >>> resolve_object(\"<p><a href='a'>p</a><a href='b'>n</a></p>\") {'heading_id': '', 'level': 0, 'prefix_url': 'a', 'name_url': 'b'} >>> resolve_object(\"<h2 id='i'><a href='a'>p</a><a href='b'>n</a></h2>\") {'heading_id': 'i', 'level': 2, 'prefix_url': 'a', 'name_url': 'b'} function","title":"mkapi.core.linker.resolve_object"},{"location":"api/mkapi.core.linker/#mkapicorelinkerreplace_link","text":"</> Returns a replaced link with object full name. Parameters obj (any) \u2014 Object that has a module. markdown (str) \u2014 Markdown Examples >>> from mkapi.core.object import get_object >>> obj = get_object('mkapi.core.structure.Object') >>> replace_link(obj, '[Signature]()') '[Signature](!mkapi.core.signature.Signature)' >>> replace_link(obj, '[](Signature)') '[Signature](!mkapi.core.signature.Signature)' >>> replace_link(obj, '[text](Signature)') '[text](!mkapi.core.signature.Signature)' >>> replace_link(obj, '[dummy.Dummy]()') '[dummy.Dummy]()' >>> replace_link(obj, 'Signature_') '[Signature](!mkapi.core.signature.Signature)'","title":"mkapi.core.linker.replace_link"},{"location":"api/mkapi.core/","text":"PACKAGE MKAPI . CORE </> Package level documentation is written in __init__.py . MODULE MKAPI.CORE . ATTRIBUTE </> This module provides attributes inspection from source code. Functions get_attributes ( obj ) (dict(str: (any, str))) \u2014 Returns a dictionary that maps attribute name to a tuple of (type, description). </> get_class_attributes ( cls ) (dict(str: (any, str))) \u2014 Returns a dictionary that maps attribute name to a tuple of (type, description). </> get_dataclass_attributes ( cls ) (dict(str: (any, str))) \u2014 Returns a dictionary that maps attribute name to a tuple of (type, description). </> get_module_attributes ( module ) (dict(str: (any, str))) \u2014 Returns a dictionary that maps attribute name to a tuple of (type, description). </> MODULE MKAPI.CORE . BASE </> This module provides entity classes to represent docstring structure. Classes Base \u2014 Base class. </> Inline \u2014 Inline class. </> Type \u2014 Type class represents type of Item , Section , Docstring , or Object . </> Item \u2014 Item class represents an item in Parameters, Attributes, and Raises sections, etc. </> Section \u2014 Section class represents a section in docstring. </> Docstring \u2014 Docstring class represents a docstring of an object. </> MODULE MKAPI.CORE . DOCSTRING </> This module provides functions that parse docstring. Functions get_docstring ( obj ) ( Docstring ) \u2014 Returns a Docstring instance. </> get_section ( name , doc , style ) ( Section ) \u2014 Returns a Section instance. </> parse_bases ( doc , obj ) \u2014 Parses base classes to create a Base(s) line. </> parse_parameter ( lines , style ) ( Item ) \u2014 Returns a Item instance that represents a parameter. </> parse_parameters ( doc , style ) (list of Item ) \u2014 Returns a list of Item. </> parse_returns ( doc , style ) (str, str) \u2014 Returns a tuple of (type, markdown). </> parse_source ( doc , obj ) \u2014 Parses parameters' docstring to inspect type and description from source. </> section_heading ( line ) (str, str) \u2014 Returns a tuple of (section name, style name). </> split_parameter ( doc ) (list of str) \u2014 Yields a list of parameter string. </> split_section ( doc ) (str, str, str) \u2014 Yields a tuple of (section name, contents, style). </> MODULE MKAPI.CORE . INHERIT </> This module implements the functionality of docstring inheritance. Functions get_bases ( node ) ( Node , iterator of Node ) \u2014 Yields a tuple of (Node instance, iterator of Node). </> get_section ( node , name , mode ) ( Section ) \u2014 Returns a tuple of (docstring section, signature section). </> inherit ( node ) \u2014 Inherits Parameters and Attributes from superclasses. </> inherit_base ( node , base , name ) \u2014 Inherits Parameters or Attributes section from base class. </> is_complete ( node , name ) (bool) \u2014 Returns True if docstring is complete. </> MODULE MKAPI.CORE . LINKER </> This module provides functions that relate to link. Functions get_link ( obj , include_module ) (str) \u2014 Returns Markdown link for object, if possible. </> link ( name , href ) (str) \u2014 Reutrns Markdown link with a mark that indicates this link was created by MkApi. </> replace_link ( obj , markdown ) (str) \u2014 Returns a replaced link with object full name. </> resolve_link ( markdown , abs_src_path , abs_api_paths ) (str) \u2014 Reutrns resolved link. </> resolve_object ( html ) (dict(str: any)) \u2014 Reutrns an object context dictionary. </> MODULE MKAPI.CORE . MODULE </> This modules provides Module class that has tree structure. Classes Module \u2014 Module class represents an module. </> Functions get_module ( name ) ( Module ) \u2014 Returns a Module instace by name or object. </> MODULE MKAPI.CORE . NODE </> This modules provides Node class that has tree structure. Classes Node \u2014 Node class represents an object. </> Functions get_node ( name , sourcefile_index ) ( Node ) \u2014 Returns a Node instace by name or object. </> is_member ( obj , name , sourcefiles ) (int) \u2014 Returns an integer thats indicates if obj is a member or not. </> MODULE MKAPI.CORE . OBJECT </> This module provides utility functions that relate to object. Functions from_object ( obj ) (bool) \u2014 Returns True, if the docstring of obj is the same as that of object . </> get_fullname ( obj , name ) (str) \u2014 Reutrns an object full name specified by name . </> get_object ( name ) (any) \u2014 Reutrns an object specified by name . </> get_origin ( obj ) (any) \u2014 Returns an original object. </> get_sourcefiles ( obj ) (list of str) \u2014 Returns a list of source file. </> split_prefix_and_name ( obj ) (str, str) \u2014 Splits an object full name into prefix and name. </> MODULE MKAPI.CORE . PAGE </> This module provides a Page class that works with other converter. Classes Page \u2014 Page class works with MkapiPlugin . </> MODULE MKAPI.CORE . RENDERER </> This module provides Renderer class that renders Node instance to create API documentation. Attributes renderer ( Renderer ) \u2014 Renderer instance that can be used globally. Classes Renderer \u2014 Renderer instance renders Node instance recursively to create API documentation. </> MODULE MKAPI.CORE . SIGNATURE </> This module provides Signature class that inspects object and creates signature and types. Classes Signature \u2014 Signature class. </> Functions a_of_b ( annotation , obj ) (str) \u2014 Returns A of B style string. </> resolve_forward_ref ( obj , name ) (str) \u2014 Returns a resolved name for typing.ForwardRef . </> to_string ( annotation , kind , obj ) (str) \u2014 Returns string expression of annotation. </> to_string_args ( annotation , obj ) (str) \u2014 Returns a string for callable and generator annotation. </> union ( annotation , obj ) (str) \u2014 Returns a string for union annotation. </> MODULE MKAPI.CORE . STRUCTURE </> This module provides base class of Node and Module . Classes Object \u2014 Object class represents an object. </> Tree \u2014 Tree class. This class is the base class of Node and Module . </>","title":"mkapi.core"},{"location":"api/mkapi.core/#mkapicore","text":"</> Package level documentation is written in __init__.py . MODULE","title":"mkapi.core"},{"location":"api/mkapi.core/#mkapicoreattribute","text":"</> This module provides attributes inspection from source code. Functions get_attributes ( obj ) (dict(str: (any, str))) \u2014 Returns a dictionary that maps attribute name to a tuple of (type, description). </> get_class_attributes ( cls ) (dict(str: (any, str))) \u2014 Returns a dictionary that maps attribute name to a tuple of (type, description). </> get_dataclass_attributes ( cls ) (dict(str: (any, str))) \u2014 Returns a dictionary that maps attribute name to a tuple of (type, description). </> get_module_attributes ( module ) (dict(str: (any, str))) \u2014 Returns a dictionary that maps attribute name to a tuple of (type, description). </> MODULE","title":"mkapi.core.attribute"},{"location":"api/mkapi.core/#mkapicorebase","text":"</> This module provides entity classes to represent docstring structure. Classes Base \u2014 Base class. </> Inline \u2014 Inline class. </> Type \u2014 Type class represents type of Item , Section , Docstring , or Object . </> Item \u2014 Item class represents an item in Parameters, Attributes, and Raises sections, etc. </> Section \u2014 Section class represents a section in docstring. </> Docstring \u2014 Docstring class represents a docstring of an object. </> MODULE","title":"mkapi.core.base"},{"location":"api/mkapi.core/#mkapicoredocstring","text":"</> This module provides functions that parse docstring. Functions get_docstring ( obj ) ( Docstring ) \u2014 Returns a Docstring instance. </> get_section ( name , doc , style ) ( Section ) \u2014 Returns a Section instance. </> parse_bases ( doc , obj ) \u2014 Parses base classes to create a Base(s) line. </> parse_parameter ( lines , style ) ( Item ) \u2014 Returns a Item instance that represents a parameter. </> parse_parameters ( doc , style ) (list of Item ) \u2014 Returns a list of Item. </> parse_returns ( doc , style ) (str, str) \u2014 Returns a tuple of (type, markdown). </> parse_source ( doc , obj ) \u2014 Parses parameters' docstring to inspect type and description from source. </> section_heading ( line ) (str, str) \u2014 Returns a tuple of (section name, style name). </> split_parameter ( doc ) (list of str) \u2014 Yields a list of parameter string. </> split_section ( doc ) (str, str, str) \u2014 Yields a tuple of (section name, contents, style). </> MODULE","title":"mkapi.core.docstring"},{"location":"api/mkapi.core/#mkapicoreinherit","text":"</> This module implements the functionality of docstring inheritance. Functions get_bases ( node ) ( Node , iterator of Node ) \u2014 Yields a tuple of (Node instance, iterator of Node). </> get_section ( node , name , mode ) ( Section ) \u2014 Returns a tuple of (docstring section, signature section). </> inherit ( node ) \u2014 Inherits Parameters and Attributes from superclasses. </> inherit_base ( node , base , name ) \u2014 Inherits Parameters or Attributes section from base class. </> is_complete ( node , name ) (bool) \u2014 Returns True if docstring is complete. </> MODULE","title":"mkapi.core.inherit"},{"location":"api/mkapi.core/#mkapicorelinker","text":"</> This module provides functions that relate to link. Functions get_link ( obj , include_module ) (str) \u2014 Returns Markdown link for object, if possible. </> link ( name , href ) (str) \u2014 Reutrns Markdown link with a mark that indicates this link was created by MkApi. </> replace_link ( obj , markdown ) (str) \u2014 Returns a replaced link with object full name. </> resolve_link ( markdown , abs_src_path , abs_api_paths ) (str) \u2014 Reutrns resolved link. </> resolve_object ( html ) (dict(str: any)) \u2014 Reutrns an object context dictionary. </> MODULE","title":"mkapi.core.linker"},{"location":"api/mkapi.core/#mkapicoremodule","text":"</> This modules provides Module class that has tree structure. Classes Module \u2014 Module class represents an module. </> Functions get_module ( name ) ( Module ) \u2014 Returns a Module instace by name or object. </> MODULE","title":"mkapi.core.module"},{"location":"api/mkapi.core/#mkapicorenode","text":"</> This modules provides Node class that has tree structure. Classes Node \u2014 Node class represents an object. </> Functions get_node ( name , sourcefile_index ) ( Node ) \u2014 Returns a Node instace by name or object. </> is_member ( obj , name , sourcefiles ) (int) \u2014 Returns an integer thats indicates if obj is a member or not. </> MODULE","title":"mkapi.core.node"},{"location":"api/mkapi.core/#mkapicoreobject","text":"</> This module provides utility functions that relate to object. Functions from_object ( obj ) (bool) \u2014 Returns True, if the docstring of obj is the same as that of object . </> get_fullname ( obj , name ) (str) \u2014 Reutrns an object full name specified by name . </> get_object ( name ) (any) \u2014 Reutrns an object specified by name . </> get_origin ( obj ) (any) \u2014 Returns an original object. </> get_sourcefiles ( obj ) (list of str) \u2014 Returns a list of source file. </> split_prefix_and_name ( obj ) (str, str) \u2014 Splits an object full name into prefix and name. </> MODULE","title":"mkapi.core.object"},{"location":"api/mkapi.core/#mkapicorepage","text":"</> This module provides a Page class that works with other converter. Classes Page \u2014 Page class works with MkapiPlugin . </> MODULE","title":"mkapi.core.page"},{"location":"api/mkapi.core/#mkapicorerenderer","text":"</> This module provides Renderer class that renders Node instance to create API documentation. Attributes renderer ( Renderer ) \u2014 Renderer instance that can be used globally. Classes Renderer \u2014 Renderer instance renders Node instance recursively to create API documentation. </> MODULE","title":"mkapi.core.renderer"},{"location":"api/mkapi.core/#mkapicoresignature","text":"</> This module provides Signature class that inspects object and creates signature and types. Classes Signature \u2014 Signature class. </> Functions a_of_b ( annotation , obj ) (str) \u2014 Returns A of B style string. </> resolve_forward_ref ( obj , name ) (str) \u2014 Returns a resolved name for typing.ForwardRef . </> to_string ( annotation , kind , obj ) (str) \u2014 Returns string expression of annotation. </> to_string_args ( annotation , obj ) (str) \u2014 Returns a string for callable and generator annotation. </> union ( annotation , obj ) (str) \u2014 Returns a string for union annotation. </> MODULE","title":"mkapi.core.signature"},{"location":"api/mkapi.core/#mkapicorestructure","text":"</> This module provides base class of Node and Module . Classes Object \u2014 Object class represents an object. </> Tree \u2014 Tree class. This class is the base class of Node and Module . </>","title":"mkapi.core.structure"},{"location":"api/mkapi.core.module/","text":"MODULE MKAPI.CORE . MODULE </> This modules provides Module class that has tree structure. Classes Module \u2014 Module class represents an module. </> Functions get_module ( name ) ( Module ) \u2014 Returns a Module instace by name or object. </> dataclass mkapi.core.module . Module ( obj ) </> Bases mkapi.core.structure.Tree Module class represents an module. Parameters obj (any) \u2014 Object. Attributes docstring ( Docstring ) \u2014 Docstring instance. lineno (int) \u2014 Line number. members (list of Module ) \u2014 Member Module instances. node ( Node ) \u2014 Node inspect of self. obj (any) \u2014 Object. object ( Object ) \u2014 Object instance. parent ( Module , optional) \u2014 Parent Module instance. sourcefile (str) \u2014 Source file path. Methods __getitem__ ( index ) \u2014 Returns a member Tree instance. </> get_kind ( ) (str) \u2014 Returns kind of self. </> get_markdown ( filters ) (str) \u2014 Returns a Markdown source for docstring of this object. </> get_members ( ) (list of Module ) \u2014 Returns a list of members. </> walk ( ) \u2014 Yields all members. </> method __getitem__ ( index ) </> Returns a member Tree instance. If index is str, a member Tree instance whose name is equal to index is returned. Parameters index (Union(int, str, list of str)) \u2014 Raises IndexError \u2014 If no member found. generator walk ( ) </> Yields all members. method get_kind ( ) \u2192 str </> Returns kind of self. method get_members ( ) \u2192 list of Module </> Returns a list of members. method get_markdown ( filters ) \u2192 str </> Returns a Markdown source for docstring of this object. Parameters filters (list of str) \u2014 A list of filters. Avaiable filters: upper , inherit , strict . function mkapi.core.module . get_module ( name ) \u2192 Module </> Returns a Module instace by name or object. Parameters name \u2014 Object name or object itself.","title":"mkapi.core.module"},{"location":"api/mkapi.core.module/#mkapicoremodule","text":"</> This modules provides Module class that has tree structure. Classes Module \u2014 Module class represents an module. </> Functions get_module ( name ) ( Module ) \u2014 Returns a Module instace by name or object. </> dataclass","title":"mkapi.core.module"},{"location":"api/mkapi.core.module/#mkapicoremodulemodule","text":"</> Bases mkapi.core.structure.Tree Module class represents an module. Parameters obj (any) \u2014 Object. Attributes docstring ( Docstring ) \u2014 Docstring instance. lineno (int) \u2014 Line number. members (list of Module ) \u2014 Member Module instances. node ( Node ) \u2014 Node inspect of self. obj (any) \u2014 Object. object ( Object ) \u2014 Object instance. parent ( Module , optional) \u2014 Parent Module instance. sourcefile (str) \u2014 Source file path. Methods __getitem__ ( index ) \u2014 Returns a member Tree instance. </> get_kind ( ) (str) \u2014 Returns kind of self. </> get_markdown ( filters ) (str) \u2014 Returns a Markdown source for docstring of this object. </> get_members ( ) (list of Module ) \u2014 Returns a list of members. </> walk ( ) \u2014 Yields all members. </> method","title":"mkapi.core.module.Module"},{"location":"api/mkapi.core.module/#mkapicorestructuretreegetitem","text":"</> Returns a member Tree instance. If index is str, a member Tree instance whose name is equal to index is returned. Parameters index (Union(int, str, list of str)) \u2014 Raises IndexError \u2014 If no member found. generator","title":"mkapi.core.structure.Tree.getitem"},{"location":"api/mkapi.core.module/#mkapicorestructuretreewalk","text":"</> Yields all members. method","title":"mkapi.core.structure.Tree.walk"},{"location":"api/mkapi.core.module/#mkapicoremodulemoduleget_kind","text":"</> Returns kind of self. method","title":"mkapi.core.module.Module.get_kind"},{"location":"api/mkapi.core.module/#mkapicoremodulemoduleget_members","text":"</> Returns a list of members. method","title":"mkapi.core.module.Module.get_members"},{"location":"api/mkapi.core.module/#mkapicoremodulemoduleget_markdown","text":"</> Returns a Markdown source for docstring of this object. Parameters filters (list of str) \u2014 A list of filters. Avaiable filters: upper , inherit , strict . function","title":"mkapi.core.module.Module.get_markdown"},{"location":"api/mkapi.core.module/#mkapicoremoduleget_module","text":"</> Returns a Module instace by name or object. Parameters name \u2014 Object name or object itself.","title":"mkapi.core.module.get_module"},{"location":"api/mkapi.core.node/","text":"MODULE MKAPI.CORE . NODE </> This modules provides Node class that has tree structure. Classes Node \u2014 Node class represents an object. </> Functions get_node ( name , sourcefile_index ) ( Node ) \u2014 Returns a Node instace by name or object. </> is_member ( obj , name , sourcefiles ) (int) \u2014 Returns an integer thats indicates if obj is a member or not. </> dataclass mkapi.core.node . Node ( obj , sourcefile_index=0 ) </> Bases mkapi.core.structure.Tree Node class represents an object. Parameters obj (any) \u2014 Object. sourcefile_index (int, optional) \u2014 If obj is a member of class, this value is the index of unique source files given by mro() of the class. Otherwise, 0. Attributes docstring ( Docstring ) \u2014 Docstring instance. lineno (int) \u2014 Line number. members (list of Node ) \u2014 Member Node instances. obj (any) \u2014 Object. object ( Object ) \u2014 Object instance. parent ( Node , optional) \u2014 Parent Node instance. sourcefile (str) \u2014 Source file path. sourcefile_index (int) \u2014 If obj is a member of class, this value is the index of unique source files given by mro() of the class. Otherwise, 0. Methods __getitem__ ( index ) \u2014 Returns a member Tree instance. </> get_html ( filters ) (str) \u2014 Renders and returns HTML. </> get_kind ( ) (str) \u2014 Returns kind of self. </> get_markdown ( level , callback ) (str) \u2014 Returns a Markdown source for docstring of this object. </> get_members ( ) (list of Node ) \u2014 Returns a list of members. </> set_html ( html ) \u2014 Sets HTML to Base instances recursively. </> walk ( ) \u2014 Yields all members. </> method __getitem__ ( index ) </> Returns a member Tree instance. If index is str, a member Tree instance whose name is equal to index is returned. Parameters index (Union(int, str, list of str)) \u2014 Raises IndexError \u2014 If no member found. generator walk ( ) </> Yields all members. method get_kind ( ) \u2192 str </> Returns kind of self. method get_members ( ) \u2192 list of Node </> Returns a list of members. method get_markdown ( level=0 , callback=None ) \u2192 str </> Returns a Markdown source for docstring of this object. Parameters level (int, optional) \u2014 Heading level. If 0, <div> tags are used. callback (callable( Base : str), optional) \u2014 To modify Markdown source. method set_html ( html ) </> Sets HTML to Base instances recursively. Parameters html (str) \u2014 HTML that is provided by a Markdown converter. method get_html ( filters=None ) \u2192 str </> Renders and returns HTML. Parameters filters (list of str, optional) \u2014 function mkapi.core.node . is_member ( obj , name='' , sourcefiles=None ) \u2192 int </> Returns an integer thats indicates if obj is a member or not. -1 -1 : Is not a member. >0 >0 : Is a member. If the value is larger than 0, obj is defined in different file and the value is corresponding to the index of unique source files of superclasses. Parameters obj (any) \u2014 Object name (str, optional) \u2014 Object name. sourcefiles (list of str, optional) \u2014 Parent source files. If the parent is a class, those of the superclasses should be included in the order of mro() . function mkapi.core.node . get_node ( name , sourcefile_index=0 ) \u2192 Node </> Returns a Node instace by name or object. Parameters name \u2014 Object name or object itself. sourcefile_index (int, optional) \u2014 If obj is a member of class, this value is the index of unique source files given by mro() of the class. Otherwise, 0.","title":"mkapi.core.node"},{"location":"api/mkapi.core.node/#mkapicorenode","text":"</> This modules provides Node class that has tree structure. Classes Node \u2014 Node class represents an object. </> Functions get_node ( name , sourcefile_index ) ( Node ) \u2014 Returns a Node instace by name or object. </> is_member ( obj , name , sourcefiles ) (int) \u2014 Returns an integer thats indicates if obj is a member or not. </> dataclass","title":"mkapi.core.node"},{"location":"api/mkapi.core.node/#mkapicorenodenode","text":"</> Bases mkapi.core.structure.Tree Node class represents an object. Parameters obj (any) \u2014 Object. sourcefile_index (int, optional) \u2014 If obj is a member of class, this value is the index of unique source files given by mro() of the class. Otherwise, 0. Attributes docstring ( Docstring ) \u2014 Docstring instance. lineno (int) \u2014 Line number. members (list of Node ) \u2014 Member Node instances. obj (any) \u2014 Object. object ( Object ) \u2014 Object instance. parent ( Node , optional) \u2014 Parent Node instance. sourcefile (str) \u2014 Source file path. sourcefile_index (int) \u2014 If obj is a member of class, this value is the index of unique source files given by mro() of the class. Otherwise, 0. Methods __getitem__ ( index ) \u2014 Returns a member Tree instance. </> get_html ( filters ) (str) \u2014 Renders and returns HTML. </> get_kind ( ) (str) \u2014 Returns kind of self. </> get_markdown ( level , callback ) (str) \u2014 Returns a Markdown source for docstring of this object. </> get_members ( ) (list of Node ) \u2014 Returns a list of members. </> set_html ( html ) \u2014 Sets HTML to Base instances recursively. </> walk ( ) \u2014 Yields all members. </> method","title":"mkapi.core.node.Node"},{"location":"api/mkapi.core.node/#mkapicorestructuretreegetitem","text":"</> Returns a member Tree instance. If index is str, a member Tree instance whose name is equal to index is returned. Parameters index (Union(int, str, list of str)) \u2014 Raises IndexError \u2014 If no member found. generator","title":"mkapi.core.structure.Tree.getitem"},{"location":"api/mkapi.core.node/#mkapicorestructuretreewalk","text":"</> Yields all members. method","title":"mkapi.core.structure.Tree.walk"},{"location":"api/mkapi.core.node/#mkapicorenodenodeget_kind","text":"</> Returns kind of self. method","title":"mkapi.core.node.Node.get_kind"},{"location":"api/mkapi.core.node/#mkapicorenodenodeget_members","text":"</> Returns a list of members. method","title":"mkapi.core.node.Node.get_members"},{"location":"api/mkapi.core.node/#mkapicorenodenodeget_markdown","text":"</> Returns a Markdown source for docstring of this object. Parameters level (int, optional) \u2014 Heading level. If 0, <div> tags are used. callback (callable( Base : str), optional) \u2014 To modify Markdown source. method","title":"mkapi.core.node.Node.get_markdown"},{"location":"api/mkapi.core.node/#mkapicorenodenodeset_html","text":"</> Sets HTML to Base instances recursively. Parameters html (str) \u2014 HTML that is provided by a Markdown converter. method","title":"mkapi.core.node.Node.set_html"},{"location":"api/mkapi.core.node/#mkapicorenodenodeget_html","text":"</> Renders and returns HTML. Parameters filters (list of str, optional) \u2014 function","title":"mkapi.core.node.Node.get_html"},{"location":"api/mkapi.core.node/#mkapicorenodeis_member","text":"</> Returns an integer thats indicates if obj is a member or not. -1 -1 : Is not a member. >0 >0 : Is a member. If the value is larger than 0, obj is defined in different file and the value is corresponding to the index of unique source files of superclasses. Parameters obj (any) \u2014 Object name (str, optional) \u2014 Object name. sourcefiles (list of str, optional) \u2014 Parent source files. If the parent is a class, those of the superclasses should be included in the order of mro() . function","title":"mkapi.core.node.is_member"},{"location":"api/mkapi.core.node/#mkapicorenodeget_node","text":"</> Returns a Node instace by name or object. Parameters name \u2014 Object name or object itself. sourcefile_index (int, optional) \u2014 If obj is a member of class, this value is the index of unique source files given by mro() of the class. Otherwise, 0.","title":"mkapi.core.node.get_node"},{"location":"api/mkapi.core.object/","text":"MODULE MKAPI.CORE . OBJECT </> This module provides utility functions that relate to object. Functions from_object ( obj ) (bool) \u2014 Returns True, if the docstring of obj is the same as that of object . </> get_fullname ( obj , name ) (str) \u2014 Reutrns an object full name specified by name . </> get_object ( name ) (any) \u2014 Reutrns an object specified by name . </> get_origin ( obj ) (any) \u2014 Returns an original object. </> get_sourcefiles ( obj ) (list of str) \u2014 Returns a list of source file. </> split_prefix_and_name ( obj ) (str, str) \u2014 Splits an object full name into prefix and name. </> function mkapi.core.object . get_object ( name ) \u2192 any </> Reutrns an object specified by name . Parameters name (str) \u2014 Object name. Examples >>> import inspect >>> obj = get_object('mkapi.core') >>> inspect.ismodule(obj) True >>> obj = get_object('mkapi.core.base') >>> inspect.ismodule(obj) True >>> obj = get_object('mkapi.core.node.Node') >>> inspect.isclass(obj) True >>> obj = get_object('mkapi.core.node.Node.get_markdown') >>> inspect.isfunction(obj) True function mkapi.core.object . get_fullname ( obj , name ) \u2192 str </> Reutrns an object full name specified by name . Parameters obj (any) \u2014 Object that has a module. name (str) \u2014 Object name in the module. Examples >>> obj = get_object('mkapi.core.base.Item') >>> get_fullname(obj, 'Section') 'mkapi.core.base.Section' >>> get_fullname(obj, 'preprocess') 'mkapi.core.preprocess' >>> get_fullname(obj, 'abc') '' function mkapi.core.object . split_prefix_and_name ( obj ) \u2192 (str, str) </> Splits an object full name into prefix and name. Parameters obj (any) \u2014 Object that has a module. Examples >>> import inspect >>> obj = get_object('mkapi.core') >>> split_prefix_and_name(obj) ('mkapi', 'core') >>> obj = get_object('mkapi.core.base') >>> split_prefix_and_name(obj) ('mkapi.core', 'base') >>> obj = get_object('mkapi.core.node.Node') >>> split_prefix_and_name(obj) ('mkapi.core.node', 'Node') >>> obj = get_object('mkapi.core.node.Node.get_markdown') >>> split_prefix_and_name(obj) ('mkapi.core.node.Node', 'get_markdown') function mkapi.core.object . get_sourcefiles ( obj ) \u2192 list of str </> Returns a list of source file. If obj is a class, source files of its superclasses are also included. Parameters obj (any) \u2014 Object name. function mkapi.core.object . from_object ( obj ) \u2192 bool </> Returns True, if the docstring of obj is the same as that of object . Parameters obj (any) \u2014 Object. name \u2014 Object name. Examples >>> class A: pass >>> from_object(A.__call__) True >>> from_object(A.__eq__) True >>> from_object(A.__getattribute__) True function mkapi.core.object . get_origin ( obj ) \u2192 any </> Returns an original object. Parameters obj (any) \u2014 Examples >>> class A: ... @property ... def x(self): ... pass >>> hasattr(A.x, __name__) False >>> get_origin(A.x).__name__ 'x'","title":"mkapi.core.object"},{"location":"api/mkapi.core.object/#mkapicoreobject","text":"</> This module provides utility functions that relate to object. Functions from_object ( obj ) (bool) \u2014 Returns True, if the docstring of obj is the same as that of object . </> get_fullname ( obj , name ) (str) \u2014 Reutrns an object full name specified by name . </> get_object ( name ) (any) \u2014 Reutrns an object specified by name . </> get_origin ( obj ) (any) \u2014 Returns an original object. </> get_sourcefiles ( obj ) (list of str) \u2014 Returns a list of source file. </> split_prefix_and_name ( obj ) (str, str) \u2014 Splits an object full name into prefix and name. </> function","title":"mkapi.core.object"},{"location":"api/mkapi.core.object/#mkapicoreobjectget_object","text":"</> Reutrns an object specified by name . Parameters name (str) \u2014 Object name. Examples >>> import inspect >>> obj = get_object('mkapi.core') >>> inspect.ismodule(obj) True >>> obj = get_object('mkapi.core.base') >>> inspect.ismodule(obj) True >>> obj = get_object('mkapi.core.node.Node') >>> inspect.isclass(obj) True >>> obj = get_object('mkapi.core.node.Node.get_markdown') >>> inspect.isfunction(obj) True function","title":"mkapi.core.object.get_object"},{"location":"api/mkapi.core.object/#mkapicoreobjectget_fullname","text":"</> Reutrns an object full name specified by name . Parameters obj (any) \u2014 Object that has a module. name (str) \u2014 Object name in the module. Examples >>> obj = get_object('mkapi.core.base.Item') >>> get_fullname(obj, 'Section') 'mkapi.core.base.Section' >>> get_fullname(obj, 'preprocess') 'mkapi.core.preprocess' >>> get_fullname(obj, 'abc') '' function","title":"mkapi.core.object.get_fullname"},{"location":"api/mkapi.core.object/#mkapicoreobjectsplit_prefix_and_name","text":"</> Splits an object full name into prefix and name. Parameters obj (any) \u2014 Object that has a module. Examples >>> import inspect >>> obj = get_object('mkapi.core') >>> split_prefix_and_name(obj) ('mkapi', 'core') >>> obj = get_object('mkapi.core.base') >>> split_prefix_and_name(obj) ('mkapi.core', 'base') >>> obj = get_object('mkapi.core.node.Node') >>> split_prefix_and_name(obj) ('mkapi.core.node', 'Node') >>> obj = get_object('mkapi.core.node.Node.get_markdown') >>> split_prefix_and_name(obj) ('mkapi.core.node.Node', 'get_markdown') function","title":"mkapi.core.object.split_prefix_and_name"},{"location":"api/mkapi.core.object/#mkapicoreobjectget_sourcefiles","text":"</> Returns a list of source file. If obj is a class, source files of its superclasses are also included. Parameters obj (any) \u2014 Object name. function","title":"mkapi.core.object.get_sourcefiles"},{"location":"api/mkapi.core.object/#mkapicoreobjectfrom_object","text":"</> Returns True, if the docstring of obj is the same as that of object . Parameters obj (any) \u2014 Object. name \u2014 Object name. Examples >>> class A: pass >>> from_object(A.__call__) True >>> from_object(A.__eq__) True >>> from_object(A.__getattribute__) True function","title":"mkapi.core.object.from_object"},{"location":"api/mkapi.core.object/#mkapicoreobjectget_origin","text":"</> Returns an original object. Parameters obj (any) \u2014 Examples >>> class A: ... @property ... def x(self): ... pass >>> hasattr(A.x, __name__) False >>> get_origin(A.x).__name__ 'x'","title":"mkapi.core.object.get_origin"},{"location":"api/mkapi.core.page/","text":"MODULE MKAPI.CORE . PAGE </> This module provides a Page class that works with other converter. Classes Page \u2014 Page class works with MkapiPlugin . </> dataclass mkapi.core.page . Page ( source , abs_src_path , abs_api_paths=<factory> ) </> Page class works with MkapiPlugin . Parameters source (str) \u2014 Markdown source. abs_src_path (str) \u2014 Absolute source path of Markdown. abs_api_paths (list of str, optional) \u2014 A list of API paths. Attributes abs_api_paths (list of str) \u2014 A list of API paths. abs_src_path (str) \u2014 Absolute source path of Markdown. markdown (str) \u2014 Converted Markdown including API documentation. nodes (list of Node or Code ) \u2014 A list of Node instances. Methods content ( html ) (str) \u2014 Returns updated HTML to MkapiPlugin . </> method content ( html ) \u2192 str </> Returns updated HTML to MkapiPlugin . Parameters html (str) \u2014 Input HTML converted by MkDocs.","title":"mkapi.core.page"},{"location":"api/mkapi.core.page/#mkapicorepage","text":"</> This module provides a Page class that works with other converter. Classes Page \u2014 Page class works with MkapiPlugin . </> dataclass","title":"mkapi.core.page"},{"location":"api/mkapi.core.page/#mkapicorepagepage","text":"</> Page class works with MkapiPlugin . Parameters source (str) \u2014 Markdown source. abs_src_path (str) \u2014 Absolute source path of Markdown. abs_api_paths (list of str, optional) \u2014 A list of API paths. Attributes abs_api_paths (list of str) \u2014 A list of API paths. abs_src_path (str) \u2014 Absolute source path of Markdown. markdown (str) \u2014 Converted Markdown including API documentation. nodes (list of Node or Code ) \u2014 A list of Node instances. Methods content ( html ) (str) \u2014 Returns updated HTML to MkapiPlugin . </> method","title":"mkapi.core.page.Page"},{"location":"api/mkapi.core.page/#mkapicorepagepagecontent","text":"</> Returns updated HTML to MkapiPlugin . Parameters html (str) \u2014 Input HTML converted by MkDocs.","title":"mkapi.core.page.Page.content"},{"location":"api/mkapi.core.renderer/","text":"MODULE MKAPI.CORE . RENDERER </> This module provides Renderer class that renders Node instance to create API documentation. Attributes renderer ( Renderer ) \u2014 Renderer instance that can be used globally. Classes Renderer \u2014 Renderer instance renders Node instance recursively to create API documentation. </> dataclass mkapi.core.renderer . Renderer ( ) </> Renderer instance renders Node instance recursively to create API documentation. Attributes templates (dict(str: Template)) \u2014 Jinja template dictionary. Methods render ( node , filters ) (str) \u2014 Returns a rendered HTML for Node. </> render_docstring ( docstring , filters ) (str) \u2014 Returns a rendered HTML for Docstring. </> render_module ( module , filters ) (str) \u2014 Returns a rendered Markdown for Module. </> render_node ( node , object , docstring , members ) (str) \u2014 Returns a rendered HTML for Node using prerendered components. </> render_object ( object , filters ) (str) \u2014 Returns a rendered HTML for Object. </> render_object_member ( name , url , signature ) (str) \u2014 Returns a rendered HTML for Object in toc. </> render_section ( section , filters ) (str) \u2014 Returns a rendered HTML for Section. </> method render ( node , filters=None ) \u2192 str </> Returns a rendered HTML for Node. Parameters node ( Node ) \u2014 Node instance. filters (list of str, optional) \u2014 method render_node ( node , object , docstring , members ) \u2192 str </> Returns a rendered HTML for Node using prerendered components. Parameters node ( Node ) \u2014 Node instance. object (str) \u2014 Rendered HTML for Object instance. docstring (str) \u2014 Rendered HTML for Docstring instance. members (list of str) \u2014 A list of rendered HTML for member Node instances. method render_object ( object , filters=None ) \u2192 str </> Returns a rendered HTML for Object. Parameters object ( Object ) \u2014 Object instance. filters (list of str, optional) \u2014 Filters. method render_object_member ( name , url , signature ) \u2192 str </> Returns a rendered HTML for Object in toc. Parameters name (str) \u2014 Object name. url (str) \u2014 Link to definition. signature (dict(str: any)) \u2014 Signature. method render_docstring ( docstring , filters=None ) \u2192 str </> Returns a rendered HTML for Docstring. Parameters docstring ( Docstring ) \u2014 Docstring instance. filters (list of str, optional) \u2014 method render_section ( section , filters=None ) \u2192 str </> Returns a rendered HTML for Section. Parameters section ( Section ) \u2014 Section instance. filters (list of str, optional) \u2014 method render_module ( module , filters=None ) \u2192 str </> Returns a rendered Markdown for Module. Parameters module ( Module ) \u2014 Module instance. filters (list of str, optional) \u2014 A list of filters. Avaiable filters: upper , inherit , strict , heading . Note This function returns Markdown instead of HTML. The returned Markdown will be converted into HTML by MkDocs. Then the HTML is rendered into HTML again by other functions in this module.","title":"mkapi.core.renderer"},{"location":"api/mkapi.core.renderer/#mkapicorerenderer","text":"</> This module provides Renderer class that renders Node instance to create API documentation. Attributes renderer ( Renderer ) \u2014 Renderer instance that can be used globally. Classes Renderer \u2014 Renderer instance renders Node instance recursively to create API documentation. </> dataclass","title":"mkapi.core.renderer"},{"location":"api/mkapi.core.renderer/#mkapicorerendererrenderer","text":"</> Renderer instance renders Node instance recursively to create API documentation. Attributes templates (dict(str: Template)) \u2014 Jinja template dictionary. Methods render ( node , filters ) (str) \u2014 Returns a rendered HTML for Node. </> render_docstring ( docstring , filters ) (str) \u2014 Returns a rendered HTML for Docstring. </> render_module ( module , filters ) (str) \u2014 Returns a rendered Markdown for Module. </> render_node ( node , object , docstring , members ) (str) \u2014 Returns a rendered HTML for Node using prerendered components. </> render_object ( object , filters ) (str) \u2014 Returns a rendered HTML for Object. </> render_object_member ( name , url , signature ) (str) \u2014 Returns a rendered HTML for Object in toc. </> render_section ( section , filters ) (str) \u2014 Returns a rendered HTML for Section. </> method","title":"mkapi.core.renderer.Renderer"},{"location":"api/mkapi.core.renderer/#mkapicorerendererrendererrender","text":"</> Returns a rendered HTML for Node. Parameters node ( Node ) \u2014 Node instance. filters (list of str, optional) \u2014 method","title":"mkapi.core.renderer.Renderer.render"},{"location":"api/mkapi.core.renderer/#mkapicorerendererrendererrender_node","text":"</> Returns a rendered HTML for Node using prerendered components. Parameters node ( Node ) \u2014 Node instance. object (str) \u2014 Rendered HTML for Object instance. docstring (str) \u2014 Rendered HTML for Docstring instance. members (list of str) \u2014 A list of rendered HTML for member Node instances. method","title":"mkapi.core.renderer.Renderer.render_node"},{"location":"api/mkapi.core.renderer/#mkapicorerendererrendererrender_object","text":"</> Returns a rendered HTML for Object. Parameters object ( Object ) \u2014 Object instance. filters (list of str, optional) \u2014 Filters. method","title":"mkapi.core.renderer.Renderer.render_object"},{"location":"api/mkapi.core.renderer/#mkapicorerendererrendererrender_object_member","text":"</> Returns a rendered HTML for Object in toc. Parameters name (str) \u2014 Object name. url (str) \u2014 Link to definition. signature (dict(str: any)) \u2014 Signature. method","title":"mkapi.core.renderer.Renderer.render_object_member"},{"location":"api/mkapi.core.renderer/#mkapicorerendererrendererrender_docstring","text":"</> Returns a rendered HTML for Docstring. Parameters docstring ( Docstring ) \u2014 Docstring instance. filters (list of str, optional) \u2014 method","title":"mkapi.core.renderer.Renderer.render_docstring"},{"location":"api/mkapi.core.renderer/#mkapicorerendererrendererrender_section","text":"</> Returns a rendered HTML for Section. Parameters section ( Section ) \u2014 Section instance. filters (list of str, optional) \u2014 method","title":"mkapi.core.renderer.Renderer.render_section"},{"location":"api/mkapi.core.renderer/#mkapicorerendererrendererrender_module","text":"</> Returns a rendered Markdown for Module. Parameters module ( Module ) \u2014 Module instance. filters (list of str, optional) \u2014 A list of filters. Avaiable filters: upper , inherit , strict , heading . Note This function returns Markdown instead of HTML. The returned Markdown will be converted into HTML by MkDocs. Then the HTML is rendered into HTML again by other functions in this module.","title":"mkapi.core.renderer.Renderer.render_module"},{"location":"api/mkapi.core.signature/","text":"MODULE MKAPI.CORE . SIGNATURE </> This module provides Signature class that inspects object and creates signature and types. Classes Signature \u2014 Signature class. </> Functions a_of_b ( annotation , obj ) (str) \u2014 Returns A of B style string. </> resolve_forward_ref ( obj , name ) (str) \u2014 Returns a resolved name for typing.ForwardRef . </> to_string ( annotation , kind , obj ) (str) \u2014 Returns string expression of annotation. </> to_string_args ( annotation , obj ) (str) \u2014 Returns a string for callable and generator annotation. </> union ( annotation , obj ) (str) \u2014 Returns a string for union annotation. </> dataclass mkapi.core.signature . Signature ( obj=None ) </> Signature class. Parameters obj (any, optional) \u2014 Object Attributes arguments (list of str, optional) \u2014 Returns arguments list. </> attributes ( Section ) \u2014 Attributes section. defaults (dict(str: any)) \u2014 Default value dictionary. Key is parameter name and value is default value. obj (any) \u2014 Object parameters ( Section ) \u2014 Parameters section. returns (str) \u2014 Returned type string. Used in Returns section. signature (Signature, optional) \u2014 inspect.Signature instance. yields (str) \u2014 Yielded type string. Used in Yields section. Methods set_attributes ( ) \u2014 method set_attributes ( ) </> Examples >>> from mkapi.core.base import Base >>> s = Signature(Base) >>> s.parameters['name'].to_tuple() ('name', 'str, optional', 'Name of self.') >>> s.attributes['html'].to_tuple() ('html', 'str', 'HTML output after conversion.') function mkapi.core.signature . to_string ( annotation , kind='returns' , obj=None ) \u2192 str </> Returns string expression of annotation. If possible, type string includes link. Parameters annotation \u2014 Annotation kind (str, optional) \u2014 'returns' or 'yields' obj (optional) \u2014 Examples >>> from typing import Callable, Iterator, List >>> to_string(Iterator[str]) 'iterator of str' >>> to_string(Iterator[str], 'yields') 'str' >>> to_string(Callable) 'callable' >>> to_string(Callable[[int, float], str]) 'callable(int, float: str)' >>> from mkapi.core.node import Node >>> to_string(List[Node]) 'list of [Node](!mkapi.core.node.Node)' function mkapi.core.signature . a_of_b ( annotation , obj=None ) \u2192 str </> Returns A of B style string. Parameters annotation \u2014 Annotation obj (optional) \u2014 Examples >>> from typing import List, Iterable, Iterator >>> a_of_b(List[str]) 'list of str' >>> a_of_b(List[List[str]]) 'list of list of str' >>> a_of_b(Iterable[int]) 'iterable of int' >>> a_of_b(Iterator[float]) 'iterator of float' function mkapi.core.signature . union ( annotation , obj=None ) \u2192 str </> Returns a string for union annotation. Parameters annotation \u2014 Annotation obj (optional) \u2014 Examples >>> from typing import List, Optional, Tuple, Union >>> union(Optional[List[str]]) 'list of str, optional' >>> union(Union[str, int]) 'str or int' >>> union(Union[str, int, float]) 'str, int, or float' >>> union(Union[List[str], Tuple[int, int]]) 'Union(list of str, (int, int))' function mkapi.core.signature . to_string_args ( annotation , obj=None ) \u2192 str </> Returns a string for callable and generator annotation. Parameters annotation \u2014 Annotation obj (optional) \u2014 Examples >>> from typing import Callable, List, Tuple, Any >>> from typing import Generator, AsyncGenerator >>> to_string_args(Callable[[int, List[str]], Tuple[int, int]]) 'callable(int, list of str: (int, int))' >>> to_string_args(Callable[[int], Any]) 'callable(int)' >>> to_string_args(Callable[[str], None]) 'callable(str)' >>> to_string_args(Callable[..., int]) 'callable(...: int)' >>> to_string_args(Generator[int, float, str]) 'generator(int, float, str)' >>> to_string_args(AsyncGenerator[int, float]) 'asyncgenerator(int, float)' function mkapi.core.signature . resolve_forward_ref ( obj , name ) \u2192 str </> Returns a resolved name for typing.ForwardRef . Parameters obj (any) \u2014 Object name (str) \u2014 Forward reference name. Examples >>> from mkapi.core.base import Docstring >>> resolve_forward_ref(Docstring, 'Docstring') '[Docstring](!mkapi.core.base.Docstring)' >>> resolve_forward_ref(Docstring, 'invalid_object_name') 'invalid_object_name'","title":"mkapi.core.signature"},{"location":"api/mkapi.core.signature/#mkapicoresignature","text":"</> This module provides Signature class that inspects object and creates signature and types. Classes Signature \u2014 Signature class. </> Functions a_of_b ( annotation , obj ) (str) \u2014 Returns A of B style string. </> resolve_forward_ref ( obj , name ) (str) \u2014 Returns a resolved name for typing.ForwardRef . </> to_string ( annotation , kind , obj ) (str) \u2014 Returns string expression of annotation. </> to_string_args ( annotation , obj ) (str) \u2014 Returns a string for callable and generator annotation. </> union ( annotation , obj ) (str) \u2014 Returns a string for union annotation. </> dataclass","title":"mkapi.core.signature"},{"location":"api/mkapi.core.signature/#mkapicoresignaturesignature","text":"</> Signature class. Parameters obj (any, optional) \u2014 Object Attributes arguments (list of str, optional) \u2014 Returns arguments list. </> attributes ( Section ) \u2014 Attributes section. defaults (dict(str: any)) \u2014 Default value dictionary. Key is parameter name and value is default value. obj (any) \u2014 Object parameters ( Section ) \u2014 Parameters section. returns (str) \u2014 Returned type string. Used in Returns section. signature (Signature, optional) \u2014 inspect.Signature instance. yields (str) \u2014 Yielded type string. Used in Yields section. Methods set_attributes ( ) \u2014 method","title":"mkapi.core.signature.Signature"},{"location":"api/mkapi.core.signature/#mkapicoresignaturesignatureset_attributes","text":"</> Examples >>> from mkapi.core.base import Base >>> s = Signature(Base) >>> s.parameters['name'].to_tuple() ('name', 'str, optional', 'Name of self.') >>> s.attributes['html'].to_tuple() ('html', 'str', 'HTML output after conversion.') function","title":"mkapi.core.signature.Signature.set_attributes"},{"location":"api/mkapi.core.signature/#mkapicoresignatureto_string","text":"</> Returns string expression of annotation. If possible, type string includes link. Parameters annotation \u2014 Annotation kind (str, optional) \u2014 'returns' or 'yields' obj (optional) \u2014 Examples >>> from typing import Callable, Iterator, List >>> to_string(Iterator[str]) 'iterator of str' >>> to_string(Iterator[str], 'yields') 'str' >>> to_string(Callable) 'callable' >>> to_string(Callable[[int, float], str]) 'callable(int, float: str)' >>> from mkapi.core.node import Node >>> to_string(List[Node]) 'list of [Node](!mkapi.core.node.Node)' function","title":"mkapi.core.signature.to_string"},{"location":"api/mkapi.core.signature/#mkapicoresignaturea_of_b","text":"</> Returns A of B style string. Parameters annotation \u2014 Annotation obj (optional) \u2014 Examples >>> from typing import List, Iterable, Iterator >>> a_of_b(List[str]) 'list of str' >>> a_of_b(List[List[str]]) 'list of list of str' >>> a_of_b(Iterable[int]) 'iterable of int' >>> a_of_b(Iterator[float]) 'iterator of float' function","title":"mkapi.core.signature.a_of_b"},{"location":"api/mkapi.core.signature/#mkapicoresignatureunion","text":"</> Returns a string for union annotation. Parameters annotation \u2014 Annotation obj (optional) \u2014 Examples >>> from typing import List, Optional, Tuple, Union >>> union(Optional[List[str]]) 'list of str, optional' >>> union(Union[str, int]) 'str or int' >>> union(Union[str, int, float]) 'str, int, or float' >>> union(Union[List[str], Tuple[int, int]]) 'Union(list of str, (int, int))' function","title":"mkapi.core.signature.union"},{"location":"api/mkapi.core.signature/#mkapicoresignatureto_string_args","text":"</> Returns a string for callable and generator annotation. Parameters annotation \u2014 Annotation obj (optional) \u2014 Examples >>> from typing import Callable, List, Tuple, Any >>> from typing import Generator, AsyncGenerator >>> to_string_args(Callable[[int, List[str]], Tuple[int, int]]) 'callable(int, list of str: (int, int))' >>> to_string_args(Callable[[int], Any]) 'callable(int)' >>> to_string_args(Callable[[str], None]) 'callable(str)' >>> to_string_args(Callable[..., int]) 'callable(...: int)' >>> to_string_args(Generator[int, float, str]) 'generator(int, float, str)' >>> to_string_args(AsyncGenerator[int, float]) 'asyncgenerator(int, float)' function","title":"mkapi.core.signature.to_string_args"},{"location":"api/mkapi.core.signature/#mkapicoresignatureresolve_forward_ref","text":"</> Returns a resolved name for typing.ForwardRef . Parameters obj (any) \u2014 Object name (str) \u2014 Forward reference name. Examples >>> from mkapi.core.base import Docstring >>> resolve_forward_ref(Docstring, 'Docstring') '[Docstring](!mkapi.core.base.Docstring)' >>> resolve_forward_ref(Docstring, 'invalid_object_name') 'invalid_object_name'","title":"mkapi.core.signature.resolve_forward_ref"},{"location":"api/mkapi.core.structure/","text":"MODULE MKAPI.CORE . STRUCTURE </> This module provides base class of Node and Module . Classes Object \u2014 Object class represents an object. </> Tree \u2014 Tree class. This class is the base class of Node and Module . </> dataclass mkapi.core.structure . Object ( name='' , prefix='' , qualname='' , kind='' , signature=<factory> ) </> Bases mkapi.core.base.Base Object class represents an object. Parameters name (str, optional) \u2014 Object name. prefix (str, optional) \u2014 Object prefix. qualname (str, optional) \u2014 Qualified name. kind (str, optional) \u2014 Object kind such as 'class', 'function', etc. signature ( Signature , optional) \u2014 Signature if object is module or callable. Attributes callback (callable( Base : str), optional) \u2014 Callback function to modify HTML output. html (str) \u2014 HTML output after conversion. id (str) \u2014 ID attribute of HTML. kind (str) \u2014 Object kind such as 'class', 'function', etc. markdown (str) \u2014 Markdown source. module (str) \u2014 name (str) \u2014 Object name. prefix (str) \u2014 Object prefix. qualname (str) \u2014 Qualified name. signature ( Signature ) \u2014 Signature if object is module or callable. type ( Type ) \u2014 Type for missing Returns and Yields sections. Methods __bool__ ( ) (bool) \u2014 Returns True if name is not empty. </> __iter__ ( ) ( Base ) \u2014 Yields self if markdown is not empty. </> copy ( ) \u2014 Returns a copy of the Object instance. </> set_html ( html ) \u2014 Sets HTML output. </> method __bool__ ( ) \u2192 bool </> Returns True if name is not empty. method set_html ( html ) </> Sets HTML output. Parameters html (str) \u2014 HTML output. method copy ( ) </> Returns a copy of the Object instance. generator __iter__ ( ) \u2192 Base </> Yields self if markdown is not empty. dataclass mkapi.core.structure . Tree ( obj ) </> Tree class. This class is the base class of Node and Module . Parameters obj (any) \u2014 Object. Attributes docstring ( Docstring ) \u2014 Docstring instance. lineno (int) \u2014 Line number. members (list of any) \u2014 Member instances. obj (any) \u2014 Object. object ( Object ) \u2014 Object instance. parent (any) \u2014 Parent instance. sourcefile (str) \u2014 Source file path. Methods __getitem__ ( index ) \u2014 Returns a member Tree instance. </> get_kind ( ) (str) \u2014 Returns kind of self. </> get_markdown ( ) (str) \u2014 Returns a Markdown source for docstring of self. </> get_members ( ) (list of Tree ) \u2014 Returns a list of members. </> walk ( ) \u2014 Yields all members. </> method __getitem__ ( index ) </> Returns a member Tree instance. If index is str, a member Tree instance whose name is equal to index is returned. Parameters index (Union(int, str, list of str)) \u2014 Raises IndexError \u2014 If no member found. method get_kind ( ) \u2192 str </> Returns kind of self. method get_members ( ) \u2192 list of Tree </> Returns a list of members. method get_markdown ( ) \u2192 str </> Returns a Markdown source for docstring of self. generator walk ( ) </> Yields all members.","title":"mkapi.core.structure"},{"location":"api/mkapi.core.structure/#mkapicorestructure","text":"</> This module provides base class of Node and Module . Classes Object \u2014 Object class represents an object. </> Tree \u2014 Tree class. This class is the base class of Node and Module . </> dataclass","title":"mkapi.core.structure"},{"location":"api/mkapi.core.structure/#mkapicorestructureobject","text":"</> Bases mkapi.core.base.Base Object class represents an object. Parameters name (str, optional) \u2014 Object name. prefix (str, optional) \u2014 Object prefix. qualname (str, optional) \u2014 Qualified name. kind (str, optional) \u2014 Object kind such as 'class', 'function', etc. signature ( Signature , optional) \u2014 Signature if object is module or callable. Attributes callback (callable( Base : str), optional) \u2014 Callback function to modify HTML output. html (str) \u2014 HTML output after conversion. id (str) \u2014 ID attribute of HTML. kind (str) \u2014 Object kind such as 'class', 'function', etc. markdown (str) \u2014 Markdown source. module (str) \u2014 name (str) \u2014 Object name. prefix (str) \u2014 Object prefix. qualname (str) \u2014 Qualified name. signature ( Signature ) \u2014 Signature if object is module or callable. type ( Type ) \u2014 Type for missing Returns and Yields sections. Methods __bool__ ( ) (bool) \u2014 Returns True if name is not empty. </> __iter__ ( ) ( Base ) \u2014 Yields self if markdown is not empty. </> copy ( ) \u2014 Returns a copy of the Object instance. </> set_html ( html ) \u2014 Sets HTML output. </> method","title":"mkapi.core.structure.Object"},{"location":"api/mkapi.core.structure/#mkapicorebasebasebool","text":"</> Returns True if name is not empty. method","title":"mkapi.core.base.Base.bool"},{"location":"api/mkapi.core.structure/#mkapicorebasebaseset_html","text":"</> Sets HTML output. Parameters html (str) \u2014 HTML output. method","title":"mkapi.core.base.Base.set_html"},{"location":"api/mkapi.core.structure/#mkapicorebasebasecopy","text":"</> Returns a copy of the Object instance. generator","title":"mkapi.core.base.Base.copy"},{"location":"api/mkapi.core.structure/#mkapicorestructureobjectiter","text":"</> Yields self if markdown is not empty. dataclass","title":"mkapi.core.structure.Object.iter"},{"location":"api/mkapi.core.structure/#mkapicorestructuretree","text":"</> Tree class. This class is the base class of Node and Module . Parameters obj (any) \u2014 Object. Attributes docstring ( Docstring ) \u2014 Docstring instance. lineno (int) \u2014 Line number. members (list of any) \u2014 Member instances. obj (any) \u2014 Object. object ( Object ) \u2014 Object instance. parent (any) \u2014 Parent instance. sourcefile (str) \u2014 Source file path. Methods __getitem__ ( index ) \u2014 Returns a member Tree instance. </> get_kind ( ) (str) \u2014 Returns kind of self. </> get_markdown ( ) (str) \u2014 Returns a Markdown source for docstring of self. </> get_members ( ) (list of Tree ) \u2014 Returns a list of members. </> walk ( ) \u2014 Yields all members. </> method","title":"mkapi.core.structure.Tree"},{"location":"api/mkapi.core.structure/#mkapicorestructuretreegetitem","text":"</> Returns a member Tree instance. If index is str, a member Tree instance whose name is equal to index is returned. Parameters index (Union(int, str, list of str)) \u2014 Raises IndexError \u2014 If no member found. method","title":"mkapi.core.structure.Tree.getitem"},{"location":"api/mkapi.core.structure/#mkapicorestructuretreeget_kind","text":"</> Returns kind of self. method","title":"mkapi.core.structure.Tree.get_kind"},{"location":"api/mkapi.core.structure/#mkapicorestructuretreeget_members","text":"</> Returns a list of members. method","title":"mkapi.core.structure.Tree.get_members"},{"location":"api/mkapi.core.structure/#mkapicorestructuretreeget_markdown","text":"</> Returns a Markdown source for docstring of self. generator","title":"mkapi.core.structure.Tree.get_markdown"},{"location":"api/mkapi.core.structure/#mkapicorestructuretreewalk","text":"</> Yields all members.","title":"mkapi.core.structure.Tree.walk"},{"location":"api/mkapi/","text":"PACKAGE MKAPI </> PACKAGE MKAPI . CORE </> Package level documentation is written in __init__.py .","title":"mkapi"},{"location":"api/mkapi/#mkapi","text":"</> PACKAGE","title":"mkapi"},{"location":"api/mkapi/#mkapicore","text":"</> Package level documentation is written in __init__.py .","title":"mkapi.core"},{"location":"api/mkapi.plugins/","text":"PACKAGE MKAPI . PLUGINS </> MODULE MKAPI.PLUGINS . MKDOCS </> This module provides the MkapiPlugin class. MkapiPlugin is a MkDocs plugin that creates Python API documentation from Docstring. Classes MkapiPlugin \u2014 MkapiPlugin class for API generation. </>","title":"mkapi.plugins"},{"location":"api/mkapi.plugins/#mkapiplugins","text":"</> MODULE","title":"mkapi.plugins"},{"location":"api/mkapi.plugins/#mkapipluginsmkdocs","text":"</> This module provides the MkapiPlugin class. MkapiPlugin is a MkDocs plugin that creates Python API documentation from Docstring. Classes MkapiPlugin \u2014 MkapiPlugin class for API generation. </>","title":"mkapi.plugins.mkdocs"},{"location":"api/mkapi.plugins.mkdocs/","text":"MODULE MKAPI.PLUGINS . MKDOCS </> This module provides the MkapiPlugin class. MkapiPlugin is a MkDocs plugin that creates Python API documentation from Docstring. Classes MkapiPlugin \u2014 MkapiPlugin class for API generation. </> class mkapi.plugins.mkdocs . MkapiPlugin ( ) </> Bases mkdocs.plugins.BasePlugin MkapiPlugin class for API generation. Attributes __class__.server \u2014 abs_api_paths \u2014 config \u2014 pages \u2014 Methods load_config ( options , config_file_path ) \u2014 Load config from a dict of options. Returns a tuple of (errors, warnings). </> on_config ( config ) \u2014 Inserts src_dirs to sys.path . </> on_files ( files , config ) \u2014 Collects plugin CSS ans JavaScript and appends them to files . </> on_page_content ( html , page , config , files ) \u2014 Merges html and MkApi's node structure. </> on_page_markdown ( markdown , page , config , files ) \u2014 Converts Markdown source to intermidiate version. </> method load_config ( options , config_file_path=None ) </> Load config from a dict of options. Returns a tuple of (errors, warnings). Parameters options \u2014 config_file_path (optional) \u2014 method on_config ( config ) </> Inserts src_dirs to sys.path . Parameters config \u2014 method on_files ( files , config ) </> Collects plugin CSS ans JavaScript and appends them to files . Parameters files \u2014 config \u2014 method on_page_markdown ( markdown , page , config , files ) </> Converts Markdown source to intermidiate version. Parameters markdown \u2014 page \u2014 config \u2014 files \u2014 method on_page_content ( html , page , config , files ) </> Merges html and MkApi's node structure. Parameters html \u2014 page \u2014 config \u2014 files \u2014","title":"mkapi.plugins.mkdocs"},{"location":"api/mkapi.plugins.mkdocs/#mkapipluginsmkdocs","text":"</> This module provides the MkapiPlugin class. MkapiPlugin is a MkDocs plugin that creates Python API documentation from Docstring. Classes MkapiPlugin \u2014 MkapiPlugin class for API generation. </> class","title":"mkapi.plugins.mkdocs"},{"location":"api/mkapi.plugins.mkdocs/#mkapipluginsmkdocsmkapiplugin","text":"</> Bases mkdocs.plugins.BasePlugin MkapiPlugin class for API generation. Attributes __class__.server \u2014 abs_api_paths \u2014 config \u2014 pages \u2014 Methods load_config ( options , config_file_path ) \u2014 Load config from a dict of options. Returns a tuple of (errors, warnings). </> on_config ( config ) \u2014 Inserts src_dirs to sys.path . </> on_files ( files , config ) \u2014 Collects plugin CSS ans JavaScript and appends them to files . </> on_page_content ( html , page , config , files ) \u2014 Merges html and MkApi's node structure. </> on_page_markdown ( markdown , page , config , files ) \u2014 Converts Markdown source to intermidiate version. </> method","title":"mkapi.plugins.mkdocs.MkapiPlugin"},{"location":"api/mkapi.plugins.mkdocs/#mkdocspluginsbasepluginload_config","text":"</> Load config from a dict of options. Returns a tuple of (errors, warnings). Parameters options \u2014 config_file_path (optional) \u2014 method","title":"mkdocs.plugins.BasePlugin.load_config"},{"location":"api/mkapi.plugins.mkdocs/#mkapipluginsmkdocsmkapipluginon_config","text":"</> Inserts src_dirs to sys.path . Parameters config \u2014 method","title":"mkapi.plugins.mkdocs.MkapiPlugin.on_config"},{"location":"api/mkapi.plugins.mkdocs/#mkapipluginsmkdocsmkapipluginon_files","text":"</> Collects plugin CSS ans JavaScript and appends them to files . Parameters files \u2014 config \u2014 method","title":"mkapi.plugins.mkdocs.MkapiPlugin.on_files"},{"location":"api/mkapi.plugins.mkdocs/#mkapipluginsmkdocsmkapipluginon_page_markdown","text":"</> Converts Markdown source to intermidiate version. Parameters markdown \u2014 page \u2014 config \u2014 files \u2014 method","title":"mkapi.plugins.mkdocs.MkapiPlugin.on_page_markdown"},{"location":"api/mkapi.plugins.mkdocs/#mkapipluginsmkdocsmkapipluginon_page_content","text":"</> Merges html and MkApi's node structure. Parameters html \u2014 page \u2014 config \u2014 files \u2014","title":"mkapi.plugins.mkdocs.MkapiPlugin.on_page_content"},{"location":"api/source/mkapi.core.attribute/","text":"SOURCE CODE MKAPI.CORE. ATTRIBUTE DOCS \"\"\"This module provides attributes inspection from source code.\"\"\" import ast import importlib import inspect from dataclasses import InitVar , is_dataclass from functools import lru_cache from typing import Any , Dict , Iterable , List , Tuple import _ast from mkapi import utils def parse_attribute ( x ) -> str : return \".\" . join ([ parse_node ( x . value ), x . attr ]) def parse_attribute_with_lineno ( x ) -> Tuple [ str , int ]: return parse_node ( x ), x . lineno def parse_subscript ( x ) -> str : value = parse_node ( x . value ) slice = parse_node ( x . slice . value ) if isinstance ( slice , str ): return f \" { value } [ { slice } ]\" else : slice = \", \" . join ( slice ) return f \" { value } [ { slice } ]\" def parse_tuple ( x ): return tuple ( parse_node ( x ) for x in x . elts ) def parse_list ( x ): return \"[\" + \", \" . join ( parse_node ( x ) for x in x . elts ) + \"]\" def parse_node ( x ): if isinstance ( x , _ast . Name ): return x . id elif isinstance ( x , _ast . Assign ): return parse_node ( x . targets [ 0 ]) elif isinstance ( x , _ast . Attribute ): return parse_attribute ( x ) elif isinstance ( x , _ast . Subscript ): return parse_subscript ( x ) elif isinstance ( x , _ast . Tuple ): return parse_tuple ( x ) elif isinstance ( x , _ast . List ): return parse_list ( x ) elif hasattr ( _ast , \"Constant\" ) and isinstance ( x , _ast . Constant ): return x . value elif hasattr ( _ast , \"Str\" ) and isinstance ( x , _ast . Str ): return x . s else : raise NotImplementedError def parse_annotation_assign ( assign ) -> Tuple [ str , int , str ]: type = parse_node ( assign . annotation ) attr , lineno = parse_attribute_with_lineno ( assign . target ) return attr , lineno , type def get_description ( lines : List [ str ], lineno : int ) -> str : index = lineno - 1 line = lines [ index ] if \" #: \" in line : return line . split ( \" #: \" )[ 1 ] . strip () if index != 0 : line = lines [ index - 1 ] . strip () if line . startswith ( \"#: \" ): return line [ 3 :] . strip () if index + 1 < len ( lines ): docs = [] in_doc = False for line in lines [ index + 1 :]: line = line . strip () if not in_doc and not line : break elif not in_doc and ( line . startswith ( \"'''\" ) or line . startswith ( '\"\"\"' )): mark = line [: 3 ] if line . endswith ( mark ): return line [ 3 : - 3 ] in_doc = True docs . append ( line [ 3 :]) elif in_doc and line . endswith ( mark ): docs . append ( line [: - 3 ]) return \" \\n \" . join ( docs ) . strip () elif in_doc : docs . append ( line ) if docs : return \" \\n \" . join ( docs ) . strip () return \"\" def get_source ( obj ) -> str : try : source = inspect . getsource ( obj ) or \"\" if not source : return \"\" except ( OSError , TypeError ): return \"\" else : return source def get_attributes_with_lineno ( nodes : Iterable [ ast . AST ], module , is_module : bool = False ) -> List [ Tuple [ str , int , Any ]]: attr_dict : Dict [ Tuple [ str , int ], Any ] = {} linenos : Dict [ int , int ] = {} def update ( attr , lineno , type ): if type or ( attr , lineno ) not in attr_dict : attr_dict [( attr , lineno )] = type linenos [ lineno ] = linenos . get ( lineno , 0 ) + 1 globals = dict ( inspect . getmembers ( module )) for x in nodes : if isinstance ( x , _ast . AnnAssign ): attr , lineno , type_str = parse_annotation_assign ( x ) try : type = eval ( type_str , globals ) except NameError : type = type_str update ( attr , lineno , type ) if isinstance ( x , _ast . Attribute ) and isinstance ( x . ctx , _ast . Store ): attr , lineno = parse_attribute_with_lineno ( x ) update ( attr , lineno , ()) if is_module and isinstance ( x , _ast . Assign ): attr , lineno = parse_attribute_with_lineno ( x ) update ( attr , lineno , ()) attr_lineno = [( attr , lineno , type ) for ( attr , lineno ), type in attr_dict . items ()] attr_lineno = [ x for x in attr_lineno if linenos [ x [ 1 ]] == 1 ] attr_lineno = sorted ( attr_lineno , key = lambda x : x [ 1 ]) return attr_lineno def get_attributes_dict ( attr_list : List [ Tuple [ str , int , Any ]], source : str , prefix : str = \"\" ) -> Dict [ str , Tuple [ Any , str ]]: attrs : Dict [ str , Tuple [ Any , str ]] = {} lines = source . split ( \" \\n \" ) for k , ( name , lineno , type ) in enumerate ( attr_list ): if not prefix or name . startswith ( prefix ): name = name [ len ( prefix ) :] stop = len ( lines ) if k < len ( attr_list ) - 1 : stop = attr_list [ k + 1 ][ 1 ] - 1 description = get_description ( lines [: stop ], lineno ) if type : attrs [ name ] = type , description # Assignment with type annotation wins. elif name not in attrs : attrs [ name ] = None , description return attrs def get_class_attributes ( cls ) -> Dict [ str , Tuple [ Any , str ]]: DOCS \"\"\"Returns a dictionary that maps attribute name to a tuple of (type, description). Args: cls: Class object. Examples: >>> from examples.google_style import ExampleClass >>> attrs = get_class_attributes(ExampleClass) >>> attrs['a'][0] is str True >>> attrs['a'][1] 'The first attribute. Comment *inline* with attribute.' >>> attrs['b'][0] == Dict[str, int] True >>> attrs['c'][0] is None True \"\"\" source = get_source ( cls ) if not source : return {} source = utils . join ( source . split ( \" \\n \" )) node = ast . parse ( source ) nodes = ast . walk ( node ) module = importlib . import_module ( cls . __module__ ) attr_lineno = get_attributes_with_lineno ( nodes , module ) return get_attributes_dict ( attr_lineno , source , prefix = \"self.\" ) def get_dataclass_attributes ( cls ) -> Dict [ str , Tuple [ Any , str ]]: DOCS \"\"\"Returns a dictionary that maps attribute name to a tuple of (type, description). Args: cls: Dataclass object. Examples: >>> from mkapi.core.base import Item, Type, Inline >>> attrs = get_dataclass_attributes(Item) >>> attrs['type'][0] is Type True >>> attrs['description'][0] is Inline True \"\"\" fields = cls . __dataclass_fields__ . values () attrs = {} for field in fields : if field . type != InitVar : attrs [ field . name ] = field . type , \"\" source = get_source ( cls ) source = utils . join ( source . split ( \" \\n \" )) if not source : return {} node = ast . parse ( source ) . body [ 0 ] def nodes (): for x in ast . iter_child_nodes ( node ): if isinstance ( x , _ast . FunctionDef ): break yield x module = importlib . import_module ( cls . __module__ ) attr_lineno = get_attributes_with_lineno ( nodes (), module ) for name , ( type , description ) in get_attributes_dict ( attr_lineno , source ) . items (): if name in attrs : attrs [ name ] = attrs [ name ][ 0 ], description else : attrs [ name ] = type , description return attrs def get_module_attributes ( module ) -> Dict [ str , Tuple [ Any , str ]]: DOCS \"\"\"Returns a dictionary that maps attribute name to a tuple of (type, description). Args: module: Module object. Examples: >>> from mkapi.core import renderer >>> attrs = get_module_attributes(renderer) >>> attrs['renderer'][0] is renderer.Renderer True \"\"\" source = get_source ( module ) if not source : return {} node = ast . parse ( source ) nodes = ast . iter_child_nodes ( node ) attr_lineno = get_attributes_with_lineno ( nodes , module , is_module = True ) return get_attributes_dict ( attr_lineno , source ) @lru_cache ( maxsize = 1000 ) DOCS def get_attributes ( obj ) -> Dict [ str , Tuple [ Any , str ]]: \"\"\"Returns a dictionary that maps attribute name to a tuple of (type, description). Args: obj: Object. See Alse: get_class_attributes_, get_dataclass_attributes_, get_module_attributes_. \"\"\" if is_dataclass ( obj ): return get_dataclass_attributes ( obj ) elif inspect . isclass ( obj ): return get_class_attributes ( obj ) elif inspect . ismodule ( obj ): return get_module_attributes ( obj ) return {}","title":"mkapi.core.attribute"},{"location":"api/source/mkapi.core.base/","text":"SOURCE CODE MKAPI.CORE. BASE DOCS \"\"\"This module provides entity classes to represent docstring structure.\"\"\" from dataclasses import dataclass , field from typing import Callable , Iterator , List , Optional , Tuple from mkapi.core import preprocess from mkapi.core.regex import LINK_PATTERN @dataclass class Base : DOCS \"\"\"Base class. Examples: >>> base = Base('x', 'markdown') >>> base Base('x') >>> bool(base) True >>> list(base) [Base('x')] >>> base = Base() >>> bool(base) False >>> list(base) [] \"\"\" name : str = \"\" #: Name of self. markdown : str = \"\" #: Markdown source. html : str = field ( default = \"\" , init = False ) #: HTML output after conversion. callback : Optional [ Callable [[ \"Base\" ], str ]] = field ( default = None , init = False ) \"\"\"Callback function to modify HTML output.\"\"\" def __repr__ ( self ): class_name = self . __class__ . __name__ return f \" { class_name } ( { self . name !r} )\" def __bool__ ( self ) -> bool : DOCS \"\"\"Returns True if name is not empty.\"\"\" return bool ( self . name ) def __iter__ ( self ) -> Iterator [ \"Base\" ]: DOCS \"\"\"Yields self if markdown is not empty.\"\"\" if self . markdown : yield self def set_html ( self , html : str ): DOCS \"\"\"Sets HTML output. Args: html: HTML output. \"\"\" self . html = html if self . callback : self . html = self . callback ( self ) def copy ( self ): DOCS \"\"\"Returns a copy of the {class} instance.\"\"\" return self . __class__ ( name = self . name , markdown = self . markdown ) @dataclass ( repr = False ) class Inline ( Base ): DOCS \"\"\"Inline class. Examples: >>> inline = Inline() >>> bool(inline) False >>> inline = Inline('markdown') >>> inline.name == inline.markdown True >>> inline Inline('markdown') >>> bool(inline) True >>> next(iter(inline)) is inline True >>> inline.set_html(\"<p>p1</p><p>p2</p>\") >>> inline.html 'p1<br>p2' >>> inline.copy() Inline('markdown') \"\"\" markdown : str = field ( init = False ) def __post_init__ ( self ): self . markdown = self . name def set_html ( self , html : str ): DOCS \"\"\"Sets `html` attribute cleaning `p` tags.\"\"\" html = preprocess . strip_ptags ( html ) super () . set_html ( html ) def copy ( self ): DOCS return self . __class__ ( name = self . name ) @dataclass ( repr = False ) class Type ( Inline ): DOCS \"\"\"Type class represents type of Item_, Section_, Docstring_, or [Object](mkapi.core.structure.Object). Examples: >>> a = Type('str') >>> a Type('str') >>> list(a) [] >>> b = Type('[Object](base.Object)') >>> b.markdown '[Object](base.Object)' >>> list(b) [Type('[Object](base.Object)')] >>> a.copy() Type('str') \"\"\" markdown : str = field ( default = \"\" , init = False ) def __post_init__ ( self ): if LINK_PATTERN . search ( self . name ): self . markdown = self . name else : self . html = self . name @dataclass class Item ( Type ): DOCS \"\"\"Item class represents an item in Parameters, Attributes, and Raises sections, *etc.* Args: type: Type of self. description: Description of self. kind: Kind of self, for example `readonly_property`. This value is rendered as a class attribute in HTML. Examples: >>> item = Item('[x](x)', Type('int'), Inline('A parameter.')) >>> item Item('[x](x)', 'int') >>> item.name, item.markdown, item.html ('[x](x)', '[x](x)', '') >>> item.type Type('int') >>> item.description Inline('A parameter.') >>> item = Item('[x](x)', 'str', 'A parameter.') >>> item.type Type('str') >>> it = iter(item) >>> next(it) is item True >>> next(it) is item.description True >>> item.set_html('<p><strong>init</strong></p>') >>> item.html '__init__' \"\"\" markdown : str = field ( default = \"\" , init = False ) type : Type = field ( default_factory = Type ) description : Inline = field ( default_factory = Inline ) kind : str = \"\" def __post_init__ ( self ): if isinstance ( self . type , str ): self . type = Type ( self . type ) if isinstance ( self . description , str ): self . description = Inline ( self . description ) super () . __post_init__ () def __repr__ ( self ): class_name = self . __class__ . __name__ return f \" { class_name } ( { self . name !r} , { self . type . name !r} )\" def __iter__ ( self ) -> Iterator [ Base ]: DOCS if self . markdown : yield self yield from self . type yield from self . description def set_html ( self , html : str ): DOCS html = html . replace ( \"<strong>\" , \"__\" ) . replace ( \"</strong>\" , \"__\" ) super () . set_html ( html ) def to_tuple ( self ) -> Tuple [ str , str , str ]: DOCS \"\"\"Returns a tuple of (name, type, description). Examples: >>> item = Item('[x](x)', 'int', 'A parameter.') >>> item.to_tuple() ('[x](x)', 'int', 'A parameter.') \"\"\" return self . name , self . type . name , self . description . name def set_type ( self , type : Type , force : bool = False ): DOCS \"\"\"Sets type. Args: item: Type instance. force: If True, overwrite self regardless of existing type and description. See Also: * Item.update_ \"\"\" if not force and self . type . name : return if type . name : self . type = type . copy () def set_description ( self , description : Inline , force : bool = False ): DOCS \"\"\"Sets description. Args: description: Inline instance. force: If True, overwrite self regardless of existing type and description. See Also: * Item.update_ \"\"\" if not force and self . description . name : return if description . name : self . description = description . copy () def update ( self , item : \"Item\" , force : bool = False ): DOCS \"\"\"Updates type and description. Args: item: Item instance. force: If True, overwrite self regardless of existing type and description. Examples: >>> item = Item('x') >>> item2 = Item('x', 'int', 'description') >>> item.update(item2) >>> item.to_tuple() ('x', 'int', 'description') >>> item2 = Item('x', 'str', 'new description') >>> item.update(item2) >>> item.to_tuple() ('x', 'int', 'description') >>> item.update(item2, force=True) >>> item.to_tuple() ('x', 'str', 'new description') >>> item.update(Item('x'), force=True) >>> item.to_tuple() ('x', 'str', 'new description') \"\"\" if item . name != self . name : raise ValueError ( f \"Different name: { self . name } != { item . name } .\" ) self . set_description ( item . description , force ) self . set_type ( item . type , force ) def copy ( self ): DOCS return Item ( * self . to_tuple (), kind = self . kind ) @dataclass class Section ( Base ): DOCS \"\"\"Section class represents a section in docstring. Args: items: List for Arguments, Attributes, or Raises sections, *etc.* type: Type of self. Examples: >>> items = [Item('x'), Item('[y](a)'), Item('z')] >>> section = Section('Parameters', items=items) >>> section Section('Parameters', num_items=3) >>> list(section) [Item('[y](a)', '')] \"\"\" items : List [ Item ] = field ( default_factory = list ) type : Type = field ( default_factory = Type ) def __post_init__ ( self ): if self . markdown : self . markdown = preprocess . convert ( self . markdown ) def __repr__ ( self ): class_name = self . __class__ . __name__ return f \" { class_name } ( { self . name !r} , num_items= { len ( self . items ) } )\" def __bool__ ( self ): DOCS \"\"\"Returns True if the number of items is larger than 0.\"\"\" return len ( self . items ) > 0 def __iter__ ( self ) -> Iterator [ Base ]: DOCS \"\"\"Yields a Base_ instance that has non empty Markdown.\"\"\" yield from self . type if self . markdown : yield self for item in self . items : yield from item def __getitem__ ( self , name : str ) -> Item : DOCS \"\"\"Returns an Item_ instance whose name is equal to `name`. If there is no Item instance, a Item instance is newly created. Args: name: Item name. Examples: >>> section = Section(\"\", items=[Item('x')]) >>> section['x'] Item('x', '') >>> section['y'] Item('y', '') >>> section.items [Item('x', ''), Item('y', '')] \"\"\" for item in self . items : if item . name == name : return item item = Item ( name ) self . items . append ( item ) return item def __delitem__ ( self , name : str ): DOCS \"\"\"Delete an Item_ instance whose name is equal to `name`. Args: name: Item name. \"\"\" for k , item in enumerate ( self . items ): if item . name == name : del self . items [ k ] return raise KeyError ( f \"name not found: { name } \" ) def __contains__ ( self , name : str ) -> bool : DOCS \"\"\"Returns True if there is an [Item]() instance whose name is equal to `name`. Args: name: Item name. \"\"\" for item in self . items : if item . name == name : return True return False def set_item ( self , item : Item , force : bool = False ): DOCS \"\"\"Sets an [Item](). Args: item: Item instance. force: If True, overwrite self regardless of existing item. Examples: >>> items = [Item('x', 'int'), Item('y', 'str', 'y')] >>> section = Section('Parameters', items=items) >>> section.set_item(Item('x', 'float', 'X')) >>> section['x'].to_tuple() ('x', 'int', 'X') >>> section.set_item(Item('y', 'int', 'Y'), force=True) >>> section['y'].to_tuple() ('y', 'int', 'Y') >>> section.set_item(Item('z', 'float', 'Z')) >>> [item.name for item in section.items] ['x', 'y', 'z'] See Also: * Section.update_ \"\"\" for k , x in enumerate ( self . items ): if x . name == item . name : self . items [ k ] . update ( item , force ) return self . items . append ( item . copy ()) def update ( self , section : \"Section\" , force : bool = False ): DOCS \"\"\"Updates items. Args: section: Section instance. force: If True, overwrite items of self regardless of existing value. Examples: >>> s1 = Section('Parameters', items=[Item('a', 's'), Item('b', 'f')]) >>> s2 = Section('Parameters', items=[Item('a', 'i', 'A'), Item('x', 'd')]) >>> s1.update(s2) >>> s1['a'].to_tuple() ('a', 's', 'A') >>> s1['x'].to_tuple() ('x', 'd', '') >>> s1.update(s2, force=True) >>> s1['a'].to_tuple() ('a', 'i', 'A') >>> s1.items [Item('a', 'i'), Item('b', 'f'), Item('x', 'd')] \"\"\" for item in section . items : self . set_item ( item , force ) def merge ( self , section : \"Section\" , force : bool = False ) -> \"Section\" : DOCS \"\"\"Returns a merged Section Examples: >>> s1 = Section('Parameters', items=[Item('a', 's'), Item('b', 'f')]) >>> s2 = Section('Parameters', items=[Item('a', 'i'), Item('c', 'd')]) >>> s3 = s1.merge(s2) >>> s3.items [Item('a', 's'), Item('b', 'f'), Item('c', 'd')] >>> s3 = s1.merge(s2, force=True) >>> s3.items [Item('a', 'i'), Item('b', 'f'), Item('c', 'd')] >>> s3 = s2.merge(s1) >>> s3.items [Item('a', 'i'), Item('c', 'd'), Item('b', 'f')] \"\"\" if section . name != self . name : raise ValueError ( f \"Different name: { self . name } != { section . name } .\" ) merged = Section ( self . name ) for item in self . items : merged . set_item ( item ) for item in section . items : merged . set_item ( item , force = force ) return merged def copy ( self ): DOCS \"\"\"Returns a copy of the {class} instace. Examples: >>> s = Section('E', 'markdown', [Item('a', 's'), Item('b', 'i')]) >>> s.copy() Section('E', num_items=2) \"\"\" items = [ item . copy () for item in self . items ] return self . __class__ ( self . name , self . markdown , items = items ) SECTION_ORDER = [ \"Bases\" , \"\" , \"Parameters\" , \"Attributes\" , \"Returns\" , \"Yields\" , \"Raises\" ] @dataclass class Docstring : DOCS \"\"\"Docstring class represents a docstring of an object. Args: sections: List of Section instance. type: Type for Returns or Yields sections. Examples: Empty docstring: >>> docstring = Docstring() >>> assert not docstring Docstring with 3 sections: >>> default = Section(\"\", markdown=\"Default\") >>> parameters = Section(\"Parameters\", items=[Item(\"a\"), Item(\"[b](!a)\")]) >>> returns = Section(\"Returns\", markdown=\"Results\") >>> docstring = Docstring([default, parameters, returns]) >>> docstring Docstring(num_sections=3) `Docstring` is iterable: >>> list(docstring) [Section('', num_items=0), Item('[b](!a)', ''), Section('Returns', num_items=0)] Indexing: >>> docstring[\"Parameters\"].items[0].name 'a' Section ordering: >>> docstring = Docstring() >>> _ = docstring[''] >>> _ = docstring['Todo'] >>> _ = docstring['Attributes'] >>> _ = docstring['Parameters'] >>> [section.name for section in docstring.sections] ['', 'Parameters', 'Attributes', 'Todo'] \"\"\" sections : List [ Section ] = field ( default_factory = list ) type : Type = field ( default_factory = Type ) def __repr__ ( self ): class_name = self . __class__ . __name__ num_sections = len ( self . sections ) return f \" { class_name } (num_sections= { num_sections } )\" def __bool__ ( self ): DOCS \"\"\"Returns True if the number of sections is larger than 0.\"\"\" return len ( self . sections ) > 0 def __iter__ ( self ) -> Iterator [ Base ]: DOCS \"\"\"Yields [Base]() instance.\"\"\" for section in self . sections : yield from section def __getitem__ ( self , name : str ) -> Section : DOCS \"\"\"Returns a [Section]() instance whose name is equal to `name`. If there is no Section instance, a Section instance is newly created. Args: name: Section name. \"\"\" for section in self . sections : if section . name == name : return section section = Section ( name ) self . set_section ( section ) return section def __contains__ ( self , name ) -> bool : DOCS \"\"\"Returns True if there is a [Section]() instance whose name is equal to `name`. Args: name: Section name. \"\"\" for section in self . sections : if section . name == name : return True return False def set_section ( DOCS self , section : Section , force : bool = False , copy : bool = False , replace : bool = False , ): \"\"\"Sets a [Section](). Args: section: Section instance. force: If True, overwrite self regardless of existing seciton. Examples: >>> items = [Item('x', 'int'), Item('y', 'str', 'y')] >>> s1 = Section('Attributes', items=items) >>> items = [Item('x', 'str', 'X'), Item('z', 'str', 'z')] >>> s2 = Section('Attributes', items=items) >>> doc = Docstring([s1]) >>> doc.set_section(s2) >>> doc['Attributes']['x'].to_tuple() ('x', 'int', 'X') >>> doc['Attributes']['z'].to_tuple() ('z', 'str', 'z') >>> doc.set_section(s2, force=True) >>> doc['Attributes']['x'].to_tuple() ('x', 'str', 'X') >>> items = [Item('x', 'X', 'str'), Item('z', 'z', 'str')] >>> s3 = Section('Parameters', items=items) >>> doc.set_section(s3) >>> doc.sections [Section('Parameters', num_items=2), Section('Attributes', num_items=3)] \"\"\" name = section . name for k , x in enumerate ( self . sections ): if x . name == name : if replace : self . sections [ k ] = section else : self . sections [ k ] . update ( section , force = force ) return if copy : section = section . copy () if name not in SECTION_ORDER : self . sections . append ( section ) return order = SECTION_ORDER . index ( name ) for k , x in enumerate ( self . sections ): if x . name not in SECTION_ORDER : self . sections . insert ( k , section ) return order_ = SECTION_ORDER . index ( x . name ) if order < order_ : self . sections . insert ( k , section ) return self . sections . append ( section )","title":"mkapi.core.base"},{"location":"api/source/mkapi.core.docstring/","text":"SOURCE CODE MKAPI.CORE. DOCSTRING DOCS \"\"\"This module provides functions that parse docstring.\"\"\" import inspect import re from dataclasses import is_dataclass from typing import Any , Iterator , List , Tuple from mkapi.core import preprocess from mkapi.core.base import Docstring , Inline , Item , Section , Type from mkapi.core.linker import get_link , replace_link from mkapi.core.signature import get_signature from mkapi.utils import get_indent , join SECTIONS = [ \"Args\" , \"Arguments\" , \"Attributes\" , \"Example\" , \"Examples\" , \"Note\" , \"Notes\" , \"Parameters\" , \"Raises\" , \"Returns\" , \"References\" , \"See Also\" , \"Todo\" , \"Warning\" , \"Warnings\" , \"Warns\" , \"Yield\" , \"Yields\" , ] def rename_section ( name : str ) -> str : if name in [ \"Args\" , \"Arguments\" ]: return \"Parameters\" if name == \"Warns\" : return \"Warnings\" return name def section_heading ( line : str ) -> Tuple [ str , str ]: DOCS \"\"\"Returns a tuple of (section name, style name). Args: line: Docstring line. Examples: >>> section_heading(\"Args:\") ('Args', 'google') >>> section_heading(\"Raises\") ('Raises', 'numpy') >>> section_heading(\"other\") ('', '') \"\"\" if line in SECTIONS : return line , \"numpy\" elif line . endswith ( \":\" ) and line [: - 1 ] in SECTIONS : return line [: - 1 ], \"google\" else : return \"\" , \"\" def split_section ( doc : str ) -> Iterator [ Tuple [ str , str , str ]]: DOCS \"\"\"Yields a tuple of (section name, contents, style). Args: doc: Docstring Examples: >>> doc = \"abc\\\\n\\\\nArgs:\\\\n x: X\\\\n\" >>> it = split_section(doc) >>> next(it) ('', 'abc', '') >>> next(it) ('Parameters', 'x: X', 'google') \"\"\" lines = [ x . rstrip () for x in doc . split ( \" \\n \" )] name = \"\" style = \"\" start = indent = 0 for stop , line in enumerate ( lines , 1 ): if stop == len ( lines ): next_indent = - 1 else : next_indent = get_indent ( lines [ stop ]) if not line and next_indent < indent and name : if start < stop - 1 : yield name , join ( lines [ start : stop - 1 ]), style start = stop name = \"\" else : section , style_ = section_heading ( line ) if section : if start < stop - 1 : yield name , join ( lines [ start : stop - 1 ]), style style = style_ name = rename_section ( section ) start = stop if style == \"numpy\" : # skip underline without counting the length. start += 1 indent = next_indent if start < len ( lines ): yield name , join ( lines [ start :]), style def split_parameter ( doc : str ) -> Iterator [ List [ str ]]: DOCS \"\"\"Yields a list of parameter string. Args: doc: Docstring \"\"\" lines = [ x . rstrip () for x in doc . split ( \" \\n \" )] start = stop = 0 for stop , line in enumerate ( lines , 1 ): if stop == len ( lines ): next_indent = 0 else : next_indent = get_indent ( lines [ stop ]) if next_indent == 0 : yield lines [ start : stop ] start = stop def parse_parameter ( lines : List [ str ], style : str ) -> Item : DOCS \"\"\"Returns a Item instance that represents a parameter. Args: lines: Splitted parameter docstring lines. style: Docstring style. `google` or `numpy`. \"\"\" if style == \"google\" : name , _ , line = lines [ 0 ] . partition ( \":\" ) name = name . strip () parsed = [ line . strip ()] pattern = r \"(.*?)\\s*?\\((.*?)\\)\" else : name = lines [ 0 ] . strip () parsed = [] pattern = r \"([^ ]*?)\\s*:\\s*(.*)\" if len ( lines ) > 1 : indent = get_indent ( lines [ 1 ]) for line in lines [ 1 :]: parsed . append ( line [ indent :]) m = re . match ( pattern , name ) if m : name , type = m . group ( 1 ), m . group ( 2 ) else : type = \"\" return Item ( name , Type ( type ), Inline ( \" \\n \" . join ( parsed ))) def parse_parameters ( doc : str , style : str ) -> List [ Item ]: DOCS \"\"\"Returns a list of Item.\"\"\" return [ parse_parameter ( lines , style ) for lines in split_parameter ( doc )] def parse_returns ( doc : str , style : str ) -> Tuple [ str , str ]: DOCS \"\"\"Returns a tuple of (type, markdown).\"\"\" lines = doc . split ( \" \\n \" ) if style == \"google\" : if \":\" in lines [ 0 ]: type , _ , lines [ 0 ] = lines [ 0 ] . partition ( \":\" ) type = type . strip () lines [ 0 ] = lines [ 0 ] . strip () else : type = \"\" else : type = lines [ 0 ] . strip () lines = lines [ 1 :] return type , join ( lines ) def get_section ( name : str , doc : str , style : str ) -> Section : DOCS \"\"\"Returns a [Section]() instance.\"\"\" type = \"\" markdown = \"\" items = [] if name in [ \"Parameters\" , \"Attributes\" , \"Raises\" ]: items = parse_parameters ( doc , style ) elif name in [ \"Returns\" , \"Yields\" ]: type , markdown = parse_returns ( doc , style ) else : markdown = doc return Section ( name , markdown , items , Type ( type )) def parse_bases ( doc : Docstring , obj : Any ): DOCS \"\"\"Parses base classes to create a Base(s) line.\"\"\" if not inspect . isclass ( obj ) or not hasattr ( obj , \"mro\" ): return objs = obj . mro ()[ 1 : - 1 ] if not objs : return types = [ get_link ( obj , include_module = True ) for obj in objs ] items = [ Item ( type = Type ( type )) for type in types if type ] doc . set_section ( Section ( \"Bases\" , items = items )) def parse_source ( doc : Docstring , obj : Any ): DOCS \"\"\"Parses parameters' docstring to inspect type and description from source. Examples: >>> from mkapi.core.base import Base >>> doc = Docstring() >>> parse_source(doc, Base) >>> section = doc['Parameters'] >>> section['name'].to_tuple() ('name', 'str, optional', 'Name of self.') >>> section = doc['Attributes'] >>> section['html'].to_tuple() ('html', 'str', 'HTML output after conversion.') \"\"\" signature = get_signature ( obj ) name = \"Parameters\" section = signature [ name ] if name in doc : section = section . merge ( doc [ name ], force = True ) if section : doc . set_section ( section , replace = True ) name = \"Attributes\" section = signature [ name ] if name not in doc and not section : return doc [ name ] . update ( section ) if is_dataclass ( obj ) and \"Parameters\" in doc : for item in doc [ \"Parameters\" ] . items : if item . name in section : doc [ name ] . set_item ( item ) def postprocess ( doc : Docstring , obj : Any ): parse_bases ( doc , obj ) parse_source ( doc , obj ) if not callable ( obj ): return signature = get_signature ( obj ) if signature . signature is None : return if \"Parameters\" in doc : for item in doc [ \"Parameters\" ] . items : description = item . description if \" {default} \" in description . name and item . name in signature : default = signature . defaults [ item . name ] description . markdown = description . name . replace ( \" {default} \" , default ) for name in [ \"Returns\" , \"Yields\" ]: if name in doc : section = doc [ name ] if not section . type : section . type = Type ( getattr ( signature , name . lower ())) if \"Returns\" not in doc and \"Yields\" not in doc : from mkapi.core.node import get_kind kind = get_kind ( obj ) if kind == \"generator\" : doc . type = Type ( signature . yields ) else : doc . type = Type ( signature . returns ) sections : List [ Section ] = [] for section in doc . sections : if section . name not in [ \"Example\" , \"Examples\" ]: for base in section : base . markdown = replace_link ( obj , base . markdown ) if section . name in [ \"Note\" , \"Notes\" , \"Warning\" , \"Warnings\" ]: markdown = preprocess . admonition ( section . name , section . markdown ) if sections and sections [ - 1 ] . name == \"\" : sections [ - 1 ] . markdown += \" \\n\\n \" + markdown continue else : section . name = \"\" section . markdown = markdown sections . append ( section ) doc . sections = sections def get_docstring ( obj : Any ) -> Docstring : DOCS \"\"\"Returns a [Docstring]() instance.\"\"\" doc = inspect . getdoc ( obj ) if doc : sections = [] for section in split_section ( doc ): sections . append ( get_section ( * section )) docstring = Docstring ( sections ) else : return Docstring () postprocess ( docstring , obj ) return docstring","title":"mkapi.core.docstring"},{"location":"api/source/mkapi.core.inherit/","text":"SOURCE CODE MKAPI.CORE. INHERIT DOCS \"\"\"This module implements the functionality of docstring inheritance.\"\"\" from typing import Iterator , Tuple from mkapi.core.base import Section from mkapi.core.node import Node , get_node def get_section ( node : Node , name : str , mode : str ) -> Section : DOCS \"\"\"Returns a tuple of (docstring section, signature section). Args: node: Node instance. name: Section name: `Parameters` or `Attributes`. mode: Mode name: `Docstring` or `Signature`. Examples: >>> node = get_node('mkapi.core.base.Type') >>> section = get_section(node, 'Parameters', 'Docstring') >>> 'name' in section True >>> section['name'].to_tuple() ('name', 'str, optional', '') \"\"\" if mode == \"Docstring\" : if name in node . docstring : return node . docstring [ name ] else : return Section ( name ) else : if hasattr ( node . object . signature , name . lower ()): return node . object . signature [ name ] else : return Section ( name ) def is_complete ( node : Node , name : str = \"both\" ) -> bool : DOCS \"\"\"Returns True if docstring is complete. Args: node: Node instance. name: Section name: 'Parameters' or 'Attributes', or 'both'. If name is 'both', both sections are checked. Examples: >>> from mkapi.core.object import get_object >>> node = Node(get_object('mkapi.core.base.Base')) >>> is_complete(node, 'Parameters') True >>> node = Node(get_object('mkapi.core.base.Type')) >>> is_complete(node) False \"\"\" if name == \"both\" : return all ( is_complete ( node , name ) for name in [ \"Parameters\" , \"Attributes\" ]) doc_section = get_section ( node , name , \"Docstring\" ) sig_section = get_section ( node , name , \"Signature\" ) for item in sig_section . items : if item . name not in doc_section : return False if not doc_section : return True for item in doc_section . items : if not item . description . name : return False return True def inherit_base ( node : Node , base : Node , name : str = \"both\" ): DOCS \"\"\"Inherits Parameters or Attributes section from base class. Args: node: Node instance. base: Node instance of a super class. name: Section name: 'Parameters' or 'Attributes', or 'both'. If name is 'both', both sections are inherited. Examples: >>> from mkapi.core.object import get_object >>> base = Node(get_object('mkapi.core.base.Base')) >>> node = Node(get_object('mkapi.core.base.Type')) >>> node.docstring['Parameters']['name'].to_tuple() ('name', 'str, optional', '') >>> inherit_base(node, base) >>> node.docstring['Parameters']['name'].to_tuple() ('name', 'str, optional', 'Name of self.') \"\"\" if name == \"both\" : for name in [ \"Parameters\" , \"Attributes\" ]: inherit_base ( node , base , name ) return base_section = get_section ( base , name , \"Docstring\" ) node_section = get_section ( node , name , \"Docstring\" ) section = base_section . merge ( node_section , force = True ) if name == \"Parameters\" : sig_section = get_section ( node , name , \"Signature\" ) items = [] for item in section . items : if item . name in sig_section : items . append ( item ) section . items = items if section : node . docstring . set_section ( section , replace = True ) def get_bases ( node : Node ) -> Iterator [ Tuple [ Node , Iterator [ Node ]]]: DOCS \"\"\"Yields a tuple of (Node instance, iterator of Node). Args: node: Node instance. Examples: >>> from mkapi.core.object import get_object >>> node = Node(get_object('mkapi.core.base.Type')) >>> it = get_bases(node) >>> n, gen = next(it) >>> n is node True >>> [x.object.name for x in gen] ['Inline', 'Base'] >>> for n, gen in it: ... if n.object.name == 'set_html': ... break >>> [x.object.name for x in gen] ['set_html', 'set_html'] \"\"\" bases = node . obj . mro ()[ 1 : - 1 ] yield node , ( get_node ( base ) for base in bases ) for member in node . members : name = member . object . name def gen ( name = name ): for base in bases : if hasattr ( base , name ): obj = getattr ( base , name ) if hasattr ( obj , \"__module__\" ): yield get_node ( getattr ( base , name )) yield member , gen () def inherit ( node : Node ): DOCS \"\"\"Inherits Parameters and Attributes from superclasses. Args: node: Node instance. \"\"\" if node . object . kind not in [ \"class\" , \"dataclass\" ]: return for node , bases in get_bases ( node ): if is_complete ( node ): continue for base in bases : inherit_base ( node , base ) if is_complete ( node ): break","title":"mkapi.core.inherit"},{"location":"api/source/mkapi.core.linker/","text":"SOURCE CODE MKAPI.CORE. LINKER DOCS \"\"\"This module provides functions that relate to link.\"\"\" import os import re from html.parser import HTMLParser from typing import Any , Dict , List from mkapi.core.object import get_fullname from mkapi.core.regex import LINK_PATTERN def link ( name : str , href : str ) -> str : DOCS \"\"\"Reutrns Markdown link with a mark that indicates this link was created by MkApi. Args: name: Link name. href: Reference. Examples: >>> link('abc', 'xyz') '[abc](!xyz)' \"\"\" return f \"[ { name } ](! { href } )\" def get_link ( obj : Any , include_module : bool = False ) -> str : DOCS \"\"\"Returns Markdown link for object, if possible. Args: obj: Object include_module: If True, link text includes module path. Examples: >>> get_link(get_fullname) '[get_fullname](!mkapi.core.object.get_fullname)' >>> get_link(get_fullname, include_module=True) '[mkapi.core.object.get_fullname](!mkapi.core.object.get_fullname)' \"\"\" if hasattr ( obj , \"__qualname__\" ): name = obj . __qualname__ elif hasattr ( obj , \"__name__\" ): name = obj . __name__ else : return \"\" if not hasattr ( obj , \"__module__\" ): return name module = obj . __module__ if module == \"builtins\" : return name fullname = \".\" . join ([ module , name ]) if include_module : text = fullname else : text = name if obj . __name__ . startswith ( \"_\" ): return text else : return link ( text , fullname ) def resolve_link ( markdown : str , abs_src_path : str , abs_api_paths : List [ str ]) -> str : DOCS \"\"\"Reutrns resolved link. Args: markdown: Markdown source. abs_src_path: Absolute source path of Markdown. abs_api_paths: A list of API paths. Examples: >>> abs_src_path = '/src/examples/example.md' >>> abs_api_paths = ['/api/a','/api/b', '/api/b.c'] >>> resolve_link('[abc](!b.c.d)', abs_src_path, abs_api_paths) '[abc](../../api/b.c#b.c.d)' \"\"\" def replace ( match ): name , href = match . groups () if href . startswith ( \"!!\" ): # Just for MkApi documentation. href = href [ 2 :] return f \"[ { name } ]( { href } )\" if href . startswith ( \"!\" ): href = href [ 1 :] from_mkapi = True else : from_mkapi = False href = resolve_href ( href , abs_src_path , abs_api_paths ) if href : return f \"[ { name } ]( { href } )\" elif from_mkapi : return name else : return match . group () return re . sub ( LINK_PATTERN , replace , markdown ) def resolve_href ( name : str , abs_src_path : str , abs_api_paths : List [ str ]) -> str : if not name : return \"\" abs_api_path = match_last ( name , abs_api_paths ) if not abs_api_path : return \"\" relpath = os . path . relpath ( abs_api_path , os . path . dirname ( abs_src_path )) relpath = relpath . replace ( \" \\\\ \" , \"/\" ) return \"#\" . join ([ relpath , name ]) def match_last ( name : str , abs_api_paths : List [ str ]) -> str : match = \"\" for abs_api_path in abs_api_paths : dirname , path = os . path . split ( abs_api_path ) if name . startswith ( path [: - 3 ]): match = abs_api_path return match class _ObjectParser ( HTMLParser ): def feed ( self , html ): self . context = { \"href\" : [], \"heading_id\" : \"\" } super () . feed ( html ) href = self . context [ \"href\" ] if len ( href ) == 2 : prefix_url , name_url = href elif len ( href ) == 1 : prefix_url , name_url = \"\" , href [ 0 ] else : prefix_url , name_url = \"\" , \"\" self . context [ \"prefix_url\" ] = prefix_url self . context [ \"name_url\" ] = name_url del self . context [ \"href\" ] return self . context def handle_starttag ( self , tag , attrs ): context = self . context if tag == \"p\" : context [ \"level\" ] = 0 elif re . match ( r \"h[1-6]\" , tag ): context [ \"level\" ] = int ( tag [ 1 :]) for attr in attrs : if attr [ 0 ] == \"id\" : self . context [ \"heading_id\" ] = attr [ 1 ] elif tag == \"a\" : for attr in attrs : if attr [ 0 ] == \"href\" : href = attr [ 1 ] if href . startswith ( \"./\" ): href = href [ 2 :] self . context [ \"href\" ] . append ( href ) parser = _ObjectParser () def resolve_object ( html : str ) -> Dict [ str , Any ]: DOCS \"\"\"Reutrns an object context dictionary. Args: html: HTML source. Examples: >>> resolve_object(\"<p><a href='a'>p</a><a href='b'>n</a></p>\") {'heading_id': '', 'level': 0, 'prefix_url': 'a', 'name_url': 'b'} >>> resolve_object(\"<h2 id='i'><a href='a'>p</a><a href='b'>n</a></h2>\") {'heading_id': 'i', 'level': 2, 'prefix_url': 'a', 'name_url': 'b'} \"\"\" parser . reset () return parser . feed ( html ) REPLACE_LINK_PATTERN = re . compile ( r \"\\[(.*?)\\]\\((.*?)\\)|(\\S+)_\" ) def replace_link ( obj : Any , markdown : str ) -> str : DOCS \"\"\"Returns a replaced link with object full name. Args: obj: Object that has a module. markdown: Markdown Examples: >>> from mkapi.core.object import get_object >>> obj = get_object('mkapi.core.structure.Object') >>> replace_link(obj, '[Signature]()') '[Signature](!mkapi.core.signature.Signature)' >>> replace_link(obj, '[](Signature)') '[Signature](!mkapi.core.signature.Signature)' >>> replace_link(obj, '[text](Signature)') '[text](!mkapi.core.signature.Signature)' >>> replace_link(obj, '[dummy.Dummy]()') '[dummy.Dummy]()' >>> replace_link(obj, 'Signature_') '[Signature](!mkapi.core.signature.Signature)' \"\"\" def replace ( match ): text , name , rest = match . groups () if rest : name , text = rest , \"\" elif not name : name , text = text , \"\" fullname = get_fullname ( obj , name ) if fullname == \"\" : return match . group () else : if text : name = text return link ( name , fullname ) return re . sub ( REPLACE_LINK_PATTERN , replace , markdown )","title":"mkapi.core.linker"},{"location":"api/source/mkapi.core/","text":"SOURCE CODE MKAPI. CORE DOCS \"\"\"Package level documentation is written in `__init__.py`.\"\"\"","title":"mkapi.core"},{"location":"api/source/mkapi.core.module/","text":"SOURCE CODE MKAPI.CORE. MODULE DOCS \"\"\"This modules provides Module class that has tree structure.\"\"\" import inspect import os from dataclasses import dataclass , field from typing import Dict , Iterator , List , Optional from mkapi.core.node import Node , get_node from mkapi.core.object import get_object from mkapi.core.structure import Tree @dataclass ( repr = False ) class Module ( Tree ): DOCS \"\"\"Module class represents an module. Attributes: parent: Parent Module instance. members: Member Module instances. node: Node inspect of self. \"\"\" parent : Optional [ \"Module\" ] = field ( default = None , init = False ) members : List [ \"Module\" ] = field ( init = False ) node : Node = field ( init = False ) def __post_init__ ( self ): super () . __post_init__ () self . node = get_node ( self . obj ) def __iter__ ( self ) -> Iterator [ \"Module\" ]: if self . docstring : yield self elif self . object . kind == \"package\" and any ( m . docstring for m in self . members ): yield self for member in self . members : yield from member def get_kind ( self ) -> str : DOCS if not self . sourcefile or self . sourcefile . endswith ( \"__init__.py\" ): return \"package\" else : return \"module\" def get_members ( self ) -> List [ \"Module\" ]: # type:ignore DOCS if self . object . kind == \"module\" : return [] else : return get_members ( self . obj ) def get_markdown ( self , filters : List [ str ]) -> str : # type:ignore DOCS \"\"\"Returns a Markdown source for docstring of this object. Args: filters: A list of filters. Avaiable filters: `upper`, `inherit`, `strict`. \"\"\" from mkapi.core.renderer import renderer return renderer . render_module ( self , filters ) # type:ignore def get_members ( obj ) -> List [ Module ]: try : sourcefile = inspect . getsourcefile ( obj ) except TypeError : return [] if not sourcefile : return [] root = os . path . dirname ( sourcefile ) paths = [ path for path in os . listdir ( root ) if not path . startswith ( \"_\" )] members = [] for path in paths : root_ = os . path . join ( root , path ) name = \"\" if os . path . isdir ( root_ ) and \"__init__.py\" in os . listdir ( root_ ): name = path elif path . endswith ( \".py\" ): name = path [: - 3 ] if name : name = \".\" . join ([ obj . __name__ , name ]) module = get_module ( name ) members . append ( module ) return members modules : Dict [ str , Module ] = {} def get_module ( name ) -> Module : DOCS \"\"\"Returns a Module instace by name or object. Args: name: Object name or object itself. \"\"\" if isinstance ( name , str ): obj = get_object ( name ) else : obj = name name = obj . __name__ if name in modules : return modules [ name ] else : module = Module ( obj ) modules [ name ] = module return module","title":"mkapi.core.module"},{"location":"api/source/mkapi.core.node/","text":"SOURCE CODE MKAPI.CORE. NODE DOCS \"\"\"This modules provides Node class that has tree structure.\"\"\" import inspect from dataclasses import dataclass , field from typing import Any , Callable , Iterator , List , Optional from mkapi.core.base import Base , Type from mkapi.core.object import ( from_object , get_object , get_origin , get_sourcefiles ) from mkapi.core.structure import Object , Tree from mkapi.core import preprocess @dataclass ( repr = False ) class Node ( Tree ): DOCS \"\"\"Node class represents an object. Args: sourcefile_index: If `obj` is a member of class, this value is the index of unique source files given by `mro()` of the class. Otherwise, 0. Attributes: parent: Parent Node instance. members: Member Node instances. \"\"\" parent : Optional [ \"Node\" ] = field ( default = None , init = False ) members : List [ \"Node\" ] = field ( init = False ) sourcefile_index : int = 0 def __post_init__ ( self ): super () . __post_init__ () members = self . members if self . object . kind in [ \"class\" , \"dataclass\" ] and not self . docstring : for member in members : if member . object . name == \"__init__\" and member . docstring : markdown = member . docstring . sections [ 0 ] . markdown if not markdown . startswith ( \"Initialize self\" ): self . docstring = member . docstring self . members = [ m for m in members if m . object . name != \"__init__\" ] doc = self . docstring if doc and 'property' in self . object . kind : if not doc . type and len ( doc . sections ) == 1 and doc . sections [ 0 ] . name == \"\" : section = doc . sections [ 0 ] markdown = section . markdown type , markdown = preprocess . split_type ( markdown ) if type : doc . type = Type ( type ) section . markdown = markdown if doc and doc . type : self . object . type = doc . type doc . type = Type () def __iter__ ( self ) -> Iterator [ Base ]: yield from self . object yield from self . docstring for member in self . members : yield from member def get_kind ( self ) -> str : DOCS if inspect . ismodule ( self . obj ): if self . sourcefile . endswith ( \"__init__.py\" ): return \"package\" else : return \"module\" if isinstance ( self . obj , property ): if self . obj . fset : return \"readwrite_property\" else : return \"readonly_property\" return get_kind ( get_origin ( self . obj )) def get_members ( self ) -> List [ \"Node\" ]: # type:ignore DOCS return get_members ( self . obj ) def get_markdown ( DOCS self , level : int = 0 , callback : Optional [ Callable [[ Base ], str ]] = None ) -> str : \"\"\"Returns a Markdown source for docstring of this object. Args: level: Heading level. If 0, `<div>` tags are used. callback: To modify Markdown source. \"\"\" markdowns = [] member_objects = [ member . object for member in self . members ] class_name = \"\" for base in self : if callback : markdown = callback ( base ) else : markdown = base . markdown markdown = markdown . replace ( \" {class} \" , class_name ) if isinstance ( base , Object ): if level : if base == self . object : markdown = \"#\" * level + \" \" + markdown elif base in member_objects : markdown = \"#\" * ( level + 1 ) + \" \" + markdown if \"class\" in base . kind : class_name = base . name markdowns . append ( markdown ) return \" \\n\\n <!-- mkapi:sep --> \\n\\n \" . join ( markdowns ) def set_html ( self , html : str ): DOCS \"\"\"Sets HTML to [Base]() instances recursively. Args: html: HTML that is provided by a Markdown converter. \"\"\" for base , html in zip ( self , html . split ( \"<!-- mkapi:sep -->\" )): base . set_html ( html . strip ()) def get_html ( self , filters : List [ str ] = None ) -> str : DOCS \"\"\"Renders and returns HTML.\"\"\" from mkapi.core.renderer import renderer return renderer . render ( self , filters ) # type:ignore def get_kind ( obj ) -> str : try : # KeyError on __dataclass_field__ (Issue#13). if hasattr ( obj , \"__dataclass_fields__\" ) and hasattr ( obj , \"__qualname__\" ): return \"dataclass\" if hasattr ( obj , \"__self__\" ) and type ( obj . __self__ ) is type : return \"classmethod\" except Exception : pass if inspect . isclass ( obj ): return \"class\" if inspect . isgeneratorfunction ( obj ): return \"generator\" if inspect . isfunction ( obj ): try : parameters = inspect . signature ( obj ) . parameters except ( ValueError , TypeError ): return \"\" if parameters : arg = list ( parameters )[ 0 ] if arg == \"self\" : return \"method\" if hasattr ( obj , \"__qualname__\" ) and \".\" in obj . __qualname__ : return \"staticmethod\" return \"function\" return \"\" def is_member ( obj : Any , name : str = \"\" , sourcefiles : List [ str ] = None ) -> int : DOCS \"\"\"Returns an integer thats indicates if `obj` is a member or not. * $-1$ : Is not a member. * $>0$ : Is a member. If the value is larger than 0, `obj` is defined in different file and the value is corresponding to the index of unique source files of superclasses. Args: name: Object name. obj: Object sourcefiles: Parent source files. If the parent is a class, those of the superclasses should be included in the order of `mro()`. \"\"\" if name == \"\" : name = obj . __name__ obj = get_origin ( obj ) if name in [ \"__func__\" , \"__self__\" ]: return - 1 if name . startswith ( \"_\" ): if not name . startswith ( \"__\" ) or not name . endswith ( \"__\" ): return - 1 if not get_kind ( obj ): return - 1 try : sourcefile = inspect . getsourcefile ( obj ) except TypeError : return - 1 if not sourcefiles : return 0 for sourcefile_index , parent_sourcefile in enumerate ( sourcefiles ): if sourcefile == parent_sourcefile : if inspect . isclass ( obj ): try : obj . mro () except ( TypeError , AttributeError ): return - 1 return sourcefile_index return - 1 def get_members ( obj : Any ) -> List [ Node ]: sourcefiles = get_sourcefiles ( obj ) members = [] for name , obj in inspect . getmembers ( obj ): sourcefile_index = is_member ( obj , name , sourcefiles ) if sourcefile_index != - 1 and not from_object ( obj ): member = get_node ( obj , sourcefile_index ) if member . docstring : members . append ( member ) return sorted ( members , key = lambda x : ( - x . sourcefile_index , x . lineno )) def get_node ( name , sourcefile_index : int = 0 ) -> Node : DOCS \"\"\"Returns a Node instace by name or object. Args: name: Object name or object itself. sourcefile_index: If `obj` is a member of class, this value is the index of unique source files given by `mro()` of the class. Otherwise, 0. \"\"\" if isinstance ( name , str ): obj = get_object ( name ) else : obj = name return Node ( obj , sourcefile_index ) def get_node_from_module ( name ): from mkapi.core.module import modules if isinstance ( name , str ): obj = get_object ( name ) else : obj = name return modules [ obj . __module__ ] . node [ obj . __qualname__ ]","title":"mkapi.core.node"},{"location":"api/source/mkapi.core.object/","text":"SOURCE CODE MKAPI.CORE. OBJECT DOCS \"\"\"This module provides utility functions that relate to object.\"\"\" import importlib import inspect from typing import Any , List , Tuple def get_object ( name : str ) -> Any : DOCS \"\"\"Reutrns an object specified by `name`. Args: name: Object name. Examples: >>> import inspect >>> obj = get_object('mkapi.core') >>> inspect.ismodule(obj) True >>> obj = get_object('mkapi.core.base') >>> inspect.ismodule(obj) True >>> obj = get_object('mkapi.core.node.Node') >>> inspect.isclass(obj) True >>> obj = get_object('mkapi.core.node.Node.get_markdown') >>> inspect.isfunction(obj) True \"\"\" names = name . split ( \".\" ) for k in range ( len ( names ), 0 , - 1 ): module_name = \".\" . join ( names [: k ]) try : obj = importlib . import_module ( module_name ) except ModuleNotFoundError : continue for attr in names [ k :]: obj = getattr ( obj , attr ) return obj raise ValueError ( f \"Could not find object: { name } \" ) def get_fullname ( obj : Any , name : str ) -> str : DOCS \"\"\"Reutrns an object full name specified by `name`. Args: obj: Object that has a module. name: Object name in the module. Examples: >>> obj = get_object('mkapi.core.base.Item') >>> get_fullname(obj, 'Section') 'mkapi.core.base.Section' >>> get_fullname(obj, 'preprocess') 'mkapi.core.preprocess' >>> get_fullname(obj, 'abc') '' \"\"\" if not hasattr ( obj , \"__module__\" ): return \"\" obj = importlib . import_module ( obj . __module__ ) names = name . split ( \".\" ) for name in names : if not hasattr ( obj , name ): return \"\" obj = getattr ( obj , name ) return \".\" . join ( split_prefix_and_name ( obj )) def split_prefix_and_name ( obj : Any ) -> Tuple [ str , str ]: DOCS \"\"\"Splits an object full name into prefix and name. Args: obj: Object that has a module. Examples: >>> import inspect >>> obj = get_object('mkapi.core') >>> split_prefix_and_name(obj) ('mkapi', 'core') >>> obj = get_object('mkapi.core.base') >>> split_prefix_and_name(obj) ('mkapi.core', 'base') >>> obj = get_object('mkapi.core.node.Node') >>> split_prefix_and_name(obj) ('mkapi.core.node', 'Node') >>> obj = get_object('mkapi.core.node.Node.get_markdown') >>> split_prefix_and_name(obj) ('mkapi.core.node.Node', 'get_markdown') \"\"\" if inspect . ismodule ( obj ): prefix , _ , name = obj . __name__ . rpartition ( \".\" ) else : module = obj . __module__ qualname = obj . __qualname__ if \".\" not in qualname : prefix , name = module , qualname else : prefix , _ , name = qualname . rpartition ( \".\" ) prefix = \".\" . join ([ module , prefix ]) if prefix == \"__main__\" : prefix = \"\" return prefix , name def get_qualname ( obj : Any ): if hasattr ( obj , \"__qualname__\" ): return obj . __qualname__ return \"\" def get_sourcefile_and_lineno ( obj : Any ) -> Tuple [ str , int ]: try : sourcefile = inspect . getsourcefile ( obj ) or \"\" except TypeError : sourcefile = \"\" try : lineno = inspect . getsourcelines ( obj )[ 1 ] except ( TypeError , OSError ): lineno = - 1 return sourcefile , lineno def get_sourcefiles ( obj : Any ) -> List [ str ]: DOCS \"\"\"Returns a list of source file. If `obj` is a class, source files of its superclasses are also included. Args: obj: Object name. \"\"\" if inspect . isclass ( obj ) and hasattr ( obj , \"mro\" ): objs = obj . mro ()[: - 1 ] else : objs = [ obj ] sourfiles = [] for obj in objs : try : sourcefile = inspect . getsourcefile ( obj ) or \"\" except TypeError : pass else : if sourcefile : sourfiles . append ( sourcefile ) return sourfiles def from_object ( obj : Any ) -> bool : DOCS \"\"\"Returns True, if the docstring of `obj` is the same as that of `object`. Args: name: Object name. obj: Object. Examples: >>> class A: pass >>> from_object(A.__call__) True >>> from_object(A.__eq__) True >>> from_object(A.__getattribute__) True \"\"\" if not hasattr ( obj , \"__name__\" ): return False name = obj . __name__ if not hasattr ( object , name ): return False return inspect . getdoc ( obj ) == getattr ( object , name ) . __doc__ def get_origin ( obj : Any ) -> Any : DOCS \"\"\"Returns an original object. Examples: >>> class A: ... @property ... def x(self): ... pass >>> hasattr(A.x, __name__) False >>> get_origin(A.x).__name__ 'x' \"\"\" if isinstance ( obj , property ): return get_origin ( obj . fget ) if not callable ( obj ): return obj if hasattr ( obj , \"__wrapped__\" ): return get_origin ( obj . __wrapped__ ) if hasattr ( obj , \"__pytest_wrapped__\" ): return get_origin ( obj . __pytest_wrapped__ . obj ) return obj","title":"mkapi.core.object"},{"location":"api/source/mkapi.core.page/","text":"SOURCE CODE MKAPI.CORE. PAGE DOCS \"\"\"This module provides a Page class that works with other converter.\"\"\" import re from dataclasses import InitVar , dataclass , field from typing import Iterator , List , Union from mkapi import utils from mkapi.core import postprocess from mkapi.core.base import Base , Section from mkapi.core.code import Code , get_code from mkapi.core.inherit import inherit from mkapi.core.linker import resolve_link from mkapi.core.node import Node , get_node from mkapi.core.regex import MKAPI_PATTERN , NODE_PATTERN , node_markdown @dataclass class Page : DOCS \"\"\"Page class works with [MkapiPlugin](mkapi.plugins.mkdocs.MkapiPlugin). Args: source (str): Markdown source. abs_src_path: Absolute source path of Markdown. abs_api_paths: A list of API paths. Attributes: markdown: Converted Markdown including API documentation. nodes: A list of Node instances. \"\"\" source : InitVar [ str ] abs_src_path : str abs_api_paths : List [ str ] = field ( default_factory = list , repr = False ) markdown : str = field ( init = False , repr = False ) nodes : List [ Union [ Node , Code ]] = field ( default_factory = list , init = False , repr = False ) def __post_init__ ( self , source ): self . markdown = \" \\n\\n \" . join ( self . split ( source )) def resolve_link ( self , markdown : str ): return resolve_link ( markdown , self . abs_src_path , self . abs_api_paths ) def resolve_link_from_base ( self , base : Base ): if isinstance ( base , Section ) and base . name in [ \"Example\" , \"Examples\" ]: return base . markdown return resolve_link ( base . markdown , self . abs_src_path , self . abs_api_paths ) def split ( self , source : str ) -> Iterator [ str ]: cursor = 0 callback = self . resolve_link_from_base for index , match in enumerate ( MKAPI_PATTERN . finditer ( source )): start , end = match . start (), match . end () if cursor < start : markdown = source [ cursor : start ] . strip () if markdown : yield self . resolve_link ( markdown ) heading , name = match . groups () level = len ( heading ) name , filters = utils . split_filters ( name ) if \"code\" in filters : code = get_code ( name ) self . nodes . append ( code ) markdown = code . get_markdown ( level ) else : node = get_node ( name ) inherit ( node ) postprocess . transform ( node , filters ) self . nodes . append ( node ) markdown = node . get_markdown ( level , callback = callback ) yield node_markdown ( index , markdown , filters ) cursor = end if cursor < len ( source ): markdown = source [ cursor :] . strip () if markdown : yield self . resolve_link ( markdown ) def content ( self , html : str ) -> str : DOCS \"\"\"Returns updated HTML to [MkapiPlugin](mkapi.plugins.mkdocs.MkapiPlugin). Args: html: Input HTML converted by MkDocs. \"\"\" def replace ( match ): node = self . nodes [ int ( match . group ( 1 ))] filters = match . group ( 2 ) . split ( \"|\" ) node . set_html ( match . group ( 3 )) return node . get_html ( filters ) return re . sub ( NODE_PATTERN , replace , html )","title":"mkapi.core.page"},{"location":"api/source/mkapi.core.renderer/","text":"SOURCE CODE MKAPI.CORE. RENDERER DOCS \"\"\" This module provides Renderer class that renders Node instance to create API documentation. \"\"\" import os from dataclasses import dataclass , field from typing import Any , Dict , List from jinja2 import Environment , FileSystemLoader , Template , select_autoescape import mkapi from mkapi.core import linker from mkapi.core.base import Docstring , Section from mkapi.core.code import Code from mkapi.core.module import Module from mkapi.core.node import Node from mkapi.core.structure import Object @dataclass class Renderer : DOCS \"\"\"Renderer instance renders Node instance recursively to create API documentation. Attributes: templates: Jinja template dictionary. \"\"\" templates : Dict [ str , Template ] = field ( default_factory = dict , init = False ) def __post_init__ ( self ): path = os . path . join ( os . path . dirname ( mkapi . __file__ ), \"templates\" ) loader = FileSystemLoader ( path ) env = Environment ( loader = loader , autoescape = select_autoescape ([ \"jinja2\" ])) for name in os . listdir ( path ): template = env . get_template ( name ) name = os . path . splitext ( name )[ 0 ] self . templates [ name ] = template def render ( self , node : Node , filters : List [ str ] = None ) -> str : DOCS \"\"\"Returns a rendered HTML for Node. Args: node: Node instance. \"\"\" object = self . render_object ( node . object , filters = filters ) docstring = self . render_docstring ( node . docstring , filters = filters ) members = [ self . render ( member , filters ) for member in node . members ] return self . render_node ( node , object , docstring , members ) def render_node ( DOCS self , node : Node , object : str , docstring : str , members : List [ str ] ) -> str : \"\"\"Returns a rendered HTML for Node using prerendered components. Args: node: Node instance. object: Rendered HTML for Object instance. docstring: Rendered HTML for Docstring instance. members: A list of rendered HTML for member Node instances. \"\"\" template = self . templates [ \"node\" ] return template . render ( node = node , object = object , docstring = docstring , members = members ) def render_object ( self , object : Object , filters : List [ str ] = None ) -> str : DOCS \"\"\"Returns a rendered HTML for Object. Args: object: Object instance. filters: Filters. \"\"\" if filters is None : filters = [] context = linker . resolve_object ( object . html ) level = context . get ( \"level\" ) if level : if object . kind in [ \"module\" , \"package\" ]: filters . append ( \"plain\" ) elif \"plain\" in filters : del filters [ filters . index ( \"plain\" )] tag = f \"h { level } \" else : tag = \"div\" template = self . templates [ \"object\" ] return template . render ( context , object = object , tag = tag , filters = filters ) def render_object_member ( DOCS self , name : str , url : str , signature : Dict [ str , Any ] ) -> str : \"\"\"Returns a rendered HTML for Object in toc. Args: name: Object name. url: Link to definition. signature: Signature. \"\"\" template = self . templates [ \"member\" ] return template . render ( name = name , url = url , signature = signature ) def render_docstring ( self , docstring : Docstring , filters : List [ str ] = None ) -> str : DOCS \"\"\"Returns a rendered HTML for Docstring. Args: docstring: Docstring instance. \"\"\" if docstring is None : return \"\" template = self . templates [ \"docstring\" ] for section in docstring . sections : if section . items : valid = any ( item . description for item in section . items ) if filters and \"strict\" in filters or section . name == \"Bases\" or valid : section . html = self . render_section ( section , filters ) return template . render ( docstring = docstring ) def render_section ( self , section : Section , filters : List [ str ] = None ) -> str : DOCS \"\"\"Returns a rendered HTML for Section. Args: section: Section instance. \"\"\" if filters is None : filters = [] if section . name == \"Bases\" : return self . templates [ \"bases\" ] . render ( section = section ) else : return self . templates [ \"items\" ] . render ( section = section , filters = filters ) def render_module ( self , module : Module , filters : List [ str ] = None ) -> str : DOCS \"\"\"Returns a rendered Markdown for Module. Args: module: Module instance. filters: A list of filters. Avaiable filters: `upper`, `inherit`, `strict`, `heading`. Note: This function returns Markdown instead of HTML. The returned Markdown will be converted into HTML by MkDocs. Then the HTML is rendered into HTML again by other functions in this module. \"\"\" if filters is None : filters = [] module_filter = \"\" if \"upper\" in filters : module_filter = \"|upper\" filters = filters . copy () del filters [ filters . index ( \"upper\" )] object_filter = \"|\" + \"|\" . join ( filters ) template = self . templates [ \"module\" ] return template . render ( module = module , module_filter = module_filter , object_filter = object_filter ) def render_code ( self , code : Code , filters : List [ str ] = None ) -> str : if filters is None : filters = [] template = self . templates [ \"code\" ] return template . render ( code = code , module = code . module , filters = filters ) #: Renderer instance that can be used globally. renderer : Renderer = Renderer ()","title":"mkapi.core.renderer"},{"location":"api/source/mkapi.core.signature/","text":"SOURCE CODE MKAPI.CORE. SIGNATURE DOCS \"\"\"This module provides Signature class that inspects object and creates signature and types.\"\"\" import importlib import inspect from dataclasses import InitVar , dataclass , field , is_dataclass from functools import lru_cache from typing import Any , Dict , List , Optional , TypeVar , Union from mkapi.core import linker , preprocess from mkapi.core.attribute import get_attributes from mkapi.core.base import Inline , Item , Section , Type @dataclass class Signature : DOCS \"\"\"Signature class. Args: obj: Object Attributes: signature: `inspect.Signature` instance. parameters: Parameters section. defaults: Default value dictionary. Key is parameter name and value is default value. attributes: Attributes section. returns: Returned type string. Used in Returns section. yields: Yielded type string. Used in Yields section. \"\"\" obj : Any = field ( default = None , repr = False ) signature : Optional [ inspect . Signature ] = field ( default = None , init = False ) parameters : Section = field ( default_factory = Section , init = False ) defaults : Dict [ str , Any ] = field ( default_factory = dict , init = False ) attributes : Section = field ( default_factory = Section , init = False ) returns : str = field ( default = \"\" , init = False ) yields : str = field ( default = \"\" , init = False ) def __post_init__ ( self ): if self . obj is None : return try : self . signature = inspect . signature ( self . obj ) except ( TypeError , ValueError ): self . set_attributes () return items = [] for name , parameter in self . signature . parameters . items (): if name == \"self\" : continue elif parameter . kind is inspect . Parameter . VAR_POSITIONAL : name = \"*\" + name elif parameter . kind is inspect . Parameter . VAR_KEYWORD : name = \"**\" + name if isinstance ( parameter . annotation , str ): type = resolve_forward_ref ( self . obj , parameter . annotation ) else : type = to_string ( parameter . annotation , obj = self . obj ) default = parameter . default if default == inspect . Parameter . empty : self . defaults [ name ] = default else : self . defaults [ name ] = f \" { default !r} \" if not type : type = \"optional\" elif not type . endswith ( \", optional\" ): type += \", optional\" items . append ( Item ( name , Type ( type ))) self . parameters = Section ( \"Parameters\" , items = items ) self . set_attributes () return_annotation = self . signature . return_annotation if isinstance ( return_annotation , str ): self . returns = resolve_forward_ref ( self . obj , return_annotation ) else : self . returns = to_string ( return_annotation , \"returns\" , obj = self . obj ) self . yields = to_string ( return_annotation , \"yields\" , obj = self . obj ) def __contains__ ( self , name ): return name in self . parameters def __getitem__ ( self , name ): return getattr ( self , name . lower ()) def __str__ ( self ): args = self . arguments if args is None : return \"\" else : return \"(\" + \", \" . join ( args ) + \")\" @property DOCS def arguments ( self ) -> Optional [ List [ str ]]: \"\"\"Returns arguments list.\"\"\" if self . obj is None or not callable ( self . obj ): return None args = [] for item in self . parameters . items : arg = item . name if self . defaults [ arg ] != inspect . Parameter . empty : arg += \"=\" + self . defaults [ arg ] args . append ( arg ) return args def set_attributes ( self ): DOCS \"\"\" Examples: >>> from mkapi.core.base import Base >>> s = Signature(Base) >>> s.parameters['name'].to_tuple() ('name', 'str, optional', 'Name of self.') >>> s.attributes['html'].to_tuple() ('html', 'str', 'HTML output after conversion.') \"\"\" items = [] for name , ( type , description ) in get_attributes ( self . obj ) . items (): if isinstance ( type , str ) and type : type = resolve_forward_ref ( self . obj , type ) else : type = to_string ( type , obj = self . obj ) if type else \"\" if not type : type , description = preprocess . split_type ( description ) item = Item ( name , Type ( type ), Inline ( description )) if is_dataclass ( self . obj ): if name in self . parameters : self . parameters [ name ] . set_description ( item . description ) if self . obj . __dataclass_fields__ [ name ] . type != InitVar : items . append ( item ) else : items . append ( item ) self . attributes = Section ( \"Attributes\" , items = items ) def split ( self , sep = \",\" ): return str ( self ) . split ( sep ) def to_string ( annotation , kind : str = \"returns\" , obj = None ) -> str : DOCS \"\"\"Returns string expression of annotation. If possible, type string includes link. Args: annotation: Annotation kind: 'returns' or 'yields' Examples: >>> from typing import Callable, Iterator, List >>> to_string(Iterator[str]) 'iterator of str' >>> to_string(Iterator[str], 'yields') 'str' >>> to_string(Callable) 'callable' >>> to_string(Callable[[int, float], str]) 'callable(int, float: str)' >>> from mkapi.core.node import Node >>> to_string(List[Node]) 'list of [Node](!mkapi.core.node.Node)' \"\"\" if kind == \"yields\" : if hasattr ( annotation , \"__args__\" ) and annotation . __args__ : if len ( annotation . __args__ ) == 1 : return to_string ( annotation . __args__ [ 0 ], obj = obj ) else : return to_string ( annotation , obj = obj ) else : return \"\" if annotation == ... : return \"...\" if hasattr ( annotation , \"__forward_arg__\" ): return resolve_forward_ref ( obj , annotation . __forward_arg__ ) if annotation == inspect . Parameter . empty or annotation is None : return \"\" name = linker . get_link ( annotation ) if name : return name if not hasattr ( annotation , \"__origin__\" ): return str ( annotation ) . replace ( \"typing.\" , \"\" ) . lower () origin = annotation . __origin__ if origin is Union : return union ( annotation , obj = obj ) if origin is tuple : args = [ to_string ( x , obj = obj ) for x in annotation . __args__ ] if args : return \"(\" + \", \" . join ( args ) + \")\" else : return \"tuple\" if origin is dict : if type ( annotation . __args__ [ 0 ]) == TypeVar : return \"dict\" args = [ to_string ( x , obj = obj ) for x in annotation . __args__ ] if args : return \"dict(\" + \": \" . join ( args ) + \")\" else : return \"dict\" if not hasattr ( annotation , \"__args__\" ): return \"\" if len ( annotation . __args__ ) == 0 : return annotation . __origin__ . __name__ . lower () if len ( annotation . __args__ ) == 1 : return a_of_b ( annotation , obj = obj ) else : return to_string_args ( annotation , obj = obj ) def a_of_b ( annotation , obj = None ) -> str : DOCS \"\"\"Returns A of B style string. Args: annotation: Annotation Examples: >>> from typing import List, Iterable, Iterator >>> a_of_b(List[str]) 'list of str' >>> a_of_b(List[List[str]]) 'list of list of str' >>> a_of_b(Iterable[int]) 'iterable of int' >>> a_of_b(Iterator[float]) 'iterator of float' \"\"\" origin = annotation . __origin__ if not hasattr ( origin , \"__name__\" ): return \"\" name = origin . __name__ . lower () if type ( annotation . __args__ [ 0 ]) == TypeVar : return name type_ = f \" { name } of \" + to_string ( annotation . __args__ [ 0 ], obj = obj ) if type_ . endswith ( \" of T\" ): return name return type_ def union ( annotation , obj = None ) -> str : DOCS \"\"\"Returns a string for union annotation. Args: annotation: Annotation Examples: >>> from typing import List, Optional, Tuple, Union >>> union(Optional[List[str]]) 'list of str, optional' >>> union(Union[str, int]) 'str or int' >>> union(Union[str, int, float]) 'str, int, or float' >>> union(Union[List[str], Tuple[int, int]]) 'Union(list of str, (int, int))' \"\"\" args = annotation . __args__ if ( len ( args ) == 2 and hasattr ( args [ 1 ], \"__name__\" ) and args [ 1 ] . __name__ == \"NoneType\" ): return to_string ( args [ 0 ], obj = obj ) + \", optional\" else : args = [ to_string ( x , obj = obj ) for x in args ] if all ( \" \" not in arg for arg in args ): if len ( args ) == 2 : return \" or \" . join ( args ) else : return \", \" . join ( args [: - 1 ]) + \", or \" + args [ - 1 ] else : return \"Union(\" + \", \" . join ( to_string ( x , obj = obj ) for x in args ) + \")\" def to_string_args ( annotation , obj = None ) -> str : DOCS \"\"\"Returns a string for callable and generator annotation. Args: annotation: Annotation Examples: >>> from typing import Callable, List, Tuple, Any >>> from typing import Generator, AsyncGenerator >>> to_string_args(Callable[[int, List[str]], Tuple[int, int]]) 'callable(int, list of str: (int, int))' >>> to_string_args(Callable[[int], Any]) 'callable(int)' >>> to_string_args(Callable[[str], None]) 'callable(str)' >>> to_string_args(Callable[..., int]) 'callable(...: int)' >>> to_string_args(Generator[int, float, str]) 'generator(int, float, str)' >>> to_string_args(AsyncGenerator[int, float]) 'asyncgenerator(int, float)' \"\"\" def to_string_with_prefix ( annotation , prefix = \",\" ): s = to_string ( annotation , obj = obj ) if s in [ \"NoneType\" , \"any\" ]: return \"\" else : return \" \" . join ([ prefix , s ]) args = annotation . __args__ name = annotation . __origin__ . __name__ . lower () if name == \"callable\" : * args , returns = args args = \", \" . join ( to_string ( x , obj = obj ) for x in args ) returns = to_string_with_prefix ( returns , \":\" ) return f \" { name } ( { args }{ returns } )\" elif name == \"generator\" : arg , sends , returns = args arg = to_string ( arg , obj = obj ) sends = to_string_with_prefix ( sends ) returns = to_string_with_prefix ( returns ) if not sends and returns : sends = \",\" return f \" { name } ( { arg }{ sends }{ returns } )\" elif name == \"asyncgenerator\" : arg , sends = args arg = to_string ( arg , obj = obj ) sends = to_string_with_prefix ( sends ) return f \" { name } ( { arg }{ sends } )\" else : return \"\" def resolve_forward_ref ( obj : Any , name : str ) -> str : DOCS \"\"\"Returns a resolved name for `typing.ForwardRef`. Args: obj: Object name: Forward reference name. Examples: >>> from mkapi.core.base import Docstring >>> resolve_forward_ref(Docstring, 'Docstring') '[Docstring](!mkapi.core.base.Docstring)' >>> resolve_forward_ref(Docstring, 'invalid_object_name') 'invalid_object_name' \"\"\" if obj is None or not hasattr ( obj , \"__module__\" ): return name module = importlib . import_module ( obj . __module__ ) globals = dict ( inspect . getmembers ( module )) try : type = eval ( name , globals ) except NameError : return name else : return to_string ( type ) @lru_cache ( maxsize = 1000 ) def get_signature ( obj : Any ) -> Signature : return Signature ( obj )","title":"mkapi.core.signature"},{"location":"api/source/mkapi.core.structure/","text":"SOURCE CODE MKAPI.CORE. STRUCTURE DOCS \"\"\"This module provides base class of [Node](mkapi.core.node.Node) and [Module](mkapi.core.module.Module).\"\"\" from dataclasses import dataclass , field from typing import Any , Iterator , List , Union from mkapi.core.base import Base , Type from mkapi.core.docstring import Docstring , get_docstring from mkapi.core.object import ( get_origin , get_qualname , get_sourcefile_and_lineno , split_prefix_and_name ) from mkapi.core.signature import Signature , get_signature \"a.b.c\" . rpartition ( \".\" ) @dataclass class Object ( Base ): DOCS \"\"\"Object class represents an object. Args: name: Object name. prefix: Object prefix. qualname: Qualified name. kind: Object kind such as 'class', 'function', *etc.* signature: Signature if object is module or callable. Attributes: id: ID attribute of HTML. type: Type for missing Returns and Yields sections. \"\"\" prefix : str = \"\" qualname : str = \"\" kind : str = \"\" signature : Signature = field ( default_factory = Signature ) module : str = field ( init = False ) markdown : str = field ( init = False ) id : str = field ( init = False ) type : Type = field ( default_factory = Type , init = False ) def __post_init__ ( self ): from mkapi.core import linker self . id = self . name if self . prefix : self . id = \".\" . join ([ self . prefix , self . name ]) if not self . qualname : self . module = self . id else : self . module = self . id [: - len ( self . qualname ) - 1 ] if not self . markdown : name = linker . link ( self . name , self . id ) if self . prefix : prefix = linker . link ( self . prefix , self . prefix ) self . markdown = \".\" . join ([ prefix , name ]) else : self . markdown = name def __repr__ ( self ): class_name = self . __class__ . __name__ id = self . id return f \" { class_name } ( { id !r} )\" def __iter__ ( self ) -> Iterator [ Base ]: DOCS yield from self . type yield self @dataclass class Tree : DOCS \"\"\"Tree class. This class is the base class of [Node](mkapi.core.node.Node) and [Module](mkapi.core.module.Module). Args: obj: Object. Attributes: sourcefile: Source file path. lineno: Line number. object: Object instance. docstring: Docstring instance. parent: Parent instance. members: Member instances. \"\"\" obj : Any = field () sourcefile : str = field ( init = False ) lineno : int = field ( init = False ) object : Object = field ( init = False ) docstring : Docstring = field ( init = False ) parent : Any = field ( default = None , init = False ) members : List [ Any ] = field ( init = False ) def __post_init__ ( self ): obj = get_origin ( self . obj ) self . sourcefile , self . lineno = get_sourcefile_and_lineno ( obj ) prefix , name = split_prefix_and_name ( obj ) qualname = get_qualname ( obj ) kind = self . get_kind () signature = get_signature ( obj ) self . object = Object ( prefix = prefix , name = name , qualname = qualname , kind = kind , signature = signature , ) self . docstring = get_docstring ( obj ) self . obj = obj self . members = self . get_members () for member in self . members : member . parent = self def __repr__ ( self ): class_name = self . __class__ . __name__ id = self . object . id sections = len ( self . docstring . sections ) numbers = len ( self . members ) return f \" { class_name } ( { id !r} , num_sections= { sections } , num_members= { numbers } )\" def __getitem__ ( self , index : Union [ int , str , List [ str ]]): DOCS \"\"\"Returns a member Tree instance. If `index` is str, a member Tree instance whose name is equal to `index` is returned. Raises: IndexError: If no member found. \"\"\" if isinstance ( index , list ): node = self for name in index : node = node [ name ] return node if isinstance ( index , int ): return self . members [ index ] if isinstance ( index , str ) and \".\" in index : names = index . split ( \".\" ) return self [ names ] for member in self . members : if member . object . name == index : return member raise IndexError def __len__ ( self ): return len ( self . members ) def __contains__ ( self , name ): for member in self . members : if member . object . name == name : return True return False def get_kind ( self ) -> str : DOCS \"\"\"Returns kind of self.\"\"\" raise NotImplementedError def get_members ( self ) -> List [ \"Tree\" ]: DOCS \"\"\"Returns a list of members.\"\"\" raise NotImplementedError def get_markdown ( self ) -> str : DOCS \"\"\"Returns a Markdown source for docstring of self.\"\"\" raise NotImplementedError def walk ( self ): DOCS \"\"\"Yields all members.\"\"\" yield self for member in self . members : yield from member . walk ()","title":"mkapi.core.structure"},{"location":"api/source/mkapi/","text":"SOURCE CODE MKAPI DOCS __version__ = \"1.0.7\" from mkapi.core.module import get_module from mkapi.core.node import get_node from mkapi.main import display , get_html __all__ = [ \"get_node\" , \"get_module\" , \"get_html\" , \"display\" ]","title":"mkapi"},{"location":"api/source/mkapi.plugins/","text":"SOURCE CODE MKAPI. PLUGINS DOCS","title":"mkapi.plugins"},{"location":"api/source/mkapi.plugins.mkdocs/","text":"SOURCE CODE MKAPI.PLUGINS. MKDOCS DOCS \"\"\"This module provides the MkapiPlugin class. MkapiPlugin is a MkDocs plugin that creates Python API documentation from Docstring. \"\"\" import inspect import logging import os import re import sys import yaml from mkdocs.config import config_options from mkdocs.plugins import BasePlugin from mkdocs.structure.files import get_files import mkapi import mkapi.plugins.api from mkapi.core.object import get_object from mkapi.core.page import Page logger = logging . getLogger ( \"mkdocs\" ) global_config = {} class MkapiPlugin ( BasePlugin ): DOCS \"\"\"MkapiPlugin class for API generation.\"\"\" config_scheme = ( ( \"src_dirs\" , config_options . Type ( list , default = [])), ( \"on_config\" , config_options . Type ( str , default = \"\" )), ( \"callback\" , config_options . Type ( str , default = \"\" )), ) server = None def on_config ( self , config ): DOCS \"\"\"Inserts `src_dirs` to `sys.path`.\"\"\" config_dir = os . path . dirname ( config [ \"config_file_path\" ]) for src_dir in self . config [ \"src_dirs\" ]: path = os . path . normpath ( os . path . join ( config_dir , src_dir )) if path not in sys . path : sys . path . insert ( 0 , path ) if not self . config [ \"src_dirs\" ]: path = os . getcwd () if path not in sys . path : sys . path . insert ( 0 , path ) self . pages = {} self . abs_api_paths = [] if not self . server : config , self . abs_api_paths = mkapi . plugins . api . create_nav ( config ) global_config [ \"config\" ] = config global_config [ \"abs_api_paths\" ] = self . abs_api_paths else : config = global_config [ \"config\" ] self . abs_api_paths = global_config [ \"abs_api_paths\" ] if self . config [ \"on_config\" ]: on_config = get_object ( self . config [ \"on_config\" ]) kwargs = {} params = inspect . signature ( on_config ) . parameters if \"config\" in params : kwargs [ \"config\" ] = config if \"mkapi\" in params : kwargs [ \"mkapi\" ] = self logger . info ( f \"[MkApi] Calling user 'on_config' with { list ( kwargs ) } \" ) config_ = on_config ( ** kwargs ) if config_ is not None : config = config_ ext = config [ \"markdown_extensions\" ] if \"admonition\" not in ext : config [ \"markdown_extensions\" ] . append ( \"admonition\" ) return config def on_files ( self , files , config ): DOCS \"\"\"Collects plugin CSS ans JavaScript and appends them to `files`.\"\"\" root = os . path . join ( os . path . dirname ( mkapi . __file__ ), \"theme\" ) docs_dir = config [ \"docs_dir\" ] config [ \"docs_dir\" ] = root files_ = get_files ( config ) config [ \"docs_dir\" ] = docs_dir theme_name = config [ \"theme\" ] . name css = [] js = [] for file in files_ : path = file . src_path . replace ( \" \\\\ \" , \"/\" ) if path . endswith ( \".css\" ): if \"common\" in path or theme_name in path : files . append ( file ) css . append ( path ) elif path . endswith ( \".js\" ): files . append ( file ) js . append ( path ) elif path . endswith ( \".yml\" ): path = os . path . normpath ( os . path . join ( root , path )) with open ( path ) as f : data = yaml . safe_load ( f ) css = data . get ( \"extra_css\" , []) + css js = data . get ( \"extra_javascript\" , []) + js css = [ x for x in css if x not in config [ \"extra_css\" ]] js = [ x for x in js if x not in config [ \"extra_javascript\" ]] config [ \"extra_css\" ] = css + config [ \"extra_css\" ] config [ \"extra_javascript\" ] = js + config [ \"extra_javascript\" ] return files def on_page_markdown ( self , markdown , page , config , files ): DOCS \"\"\"Converts Markdown source to intermidiate version.\"\"\" abs_src_path = page . file . abs_src_path clean_page_title ( page ) page = Page ( markdown , abs_src_path , self . abs_api_paths ) self . pages [ abs_src_path ] = page return page . markdown def on_page_content ( self , html , page , config , files ): DOCS \"\"\"Merges html and MkApi's node structure.\"\"\" if page . title : page . title = re . sub ( r \"<.*?>\" , \"\" , page . title ) abs_src_path = page . file . abs_src_path page = self . pages [ abs_src_path ] return page . content ( html ) def on_page_context ( self , context , page , config , nav ): abs_src_path = page . file . abs_src_path if abs_src_path in self . abs_api_paths : clear_prefix ( page . toc ) return context def on_serve ( self , server , config , builder ): for path in [ \"theme\" , \"templates\" ]: root = os . path . join ( os . path . dirname ( mkapi . __file__ ), path ) server . watch ( root , builder ) self . __class__ . server = server return server def clear_prefix ( toc ): for toc_item in toc : if toc_item . level >= 2 : toc_item . title = toc_item . title . split ( \".\" )[ - 1 ] clear_prefix ( toc_item . children ) return def clean_page_title ( page ): title = page . title if title . startswith ( \"![mkapi](\" ): page . title = title [ 9 : - 1 ] . split ( \"|\" )[ 0 ]","title":"mkapi.plugins.mkdocs"},{"location":"appendix/decorator/","text":"Decorators <!-- .mkapi-node { border: 2px dashed #88AA88; } --> File 11 appendix/decorator.py from functools import wraps def deco_without_wraps(func): def _func(*args, **kwargs): return func(*args, **kwargs) return _func def deco_with_wraps(func): @wraps(func) def _func(*args, **kwargs): return func(*args, **kwargs) return _func File 12 appendix/decorated.py \"\"\"Decorator examples.\"\"\" import pytest from appendix.decorator import deco_with_wraps, deco_without_wraps @deco_without_wraps def func_without_wraps(): \"\"\"Decorated function without `wraps`.\"\"\" @deco_with_wraps def func_with_wraps(): \"\"\"Decorated function with `wraps`.\"\"\" @deco_with_wraps @deco_with_wraps def func_with_wraps_double(): \"\"\"Doubly decorated function with `wraps`.\"\"\" @pytest.fixture def fixture(): \"\"\"Fixture.\"\"\" yield 1 @pytest.fixture @deco_with_wraps def fixture_with_wraps(): \"\"\"Fixture.\"\"\" yield 1 import inspect from appendix.decorated import func_with_wraps, func_without_wraps funcs = [func_with_wraps, func_without_wraps] for func in funcs: sourcefile = inspect.getsourcefile(func) is_wrapped = hasattr(func, '__wrapped__') print(f\"[{func.__name__}]: {sourcefile}, {is_wrapped}\") [1] 2020-06-19 17:38:11 ( 46.0ms ) python3 ( 692ms ) [func_with_wraps]: ../../examples\\appendix\\decorator.py, True [_func]: ../../examples\\appendix\\decorator.py, False ## ![mkapi](appendix.decorated|all) module appendix. decorated Decorator examples. Functions fixture ( ) \u2014 Fixture. fixture_with_wraps ( ) \u2014 Fixture. func_with_wraps ( ) \u2014 Decorated function with wraps . func_with_wraps_double ( ) \u2014 Doubly decorated function with wraps . function appendix.decorated. func_with_wraps ( ) Decorated function with wraps . function appendix.decorated. func_with_wraps_double ( ) Doubly decorated function with wraps . generator appendix.decorated. fixture ( ) Fixture. generator appendix.decorated. fixture_with_wraps ( ) Fixture.","title":"Decorators"},{"location":"appendix/decorator/#decorators","text":"<!-- .mkapi-node { border: 2px dashed #88AA88; } --> File 11 appendix/decorator.py from functools import wraps def deco_without_wraps(func): def _func(*args, **kwargs): return func(*args, **kwargs) return _func def deco_with_wraps(func): @wraps(func) def _func(*args, **kwargs): return func(*args, **kwargs) return _func File 12 appendix/decorated.py \"\"\"Decorator examples.\"\"\" import pytest from appendix.decorator import deco_with_wraps, deco_without_wraps @deco_without_wraps def func_without_wraps(): \"\"\"Decorated function without `wraps`.\"\"\" @deco_with_wraps def func_with_wraps(): \"\"\"Decorated function with `wraps`.\"\"\" @deco_with_wraps @deco_with_wraps def func_with_wraps_double(): \"\"\"Doubly decorated function with `wraps`.\"\"\" @pytest.fixture def fixture(): \"\"\"Fixture.\"\"\" yield 1 @pytest.fixture @deco_with_wraps def fixture_with_wraps(): \"\"\"Fixture.\"\"\" yield 1 import inspect from appendix.decorated import func_with_wraps, func_without_wraps funcs = [func_with_wraps, func_without_wraps] for func in funcs: sourcefile = inspect.getsourcefile(func) is_wrapped = hasattr(func, '__wrapped__') print(f\"[{func.__name__}]: {sourcefile}, {is_wrapped}\") [1] 2020-06-19 17:38:11 ( 46.0ms ) python3 ( 692ms ) [func_with_wraps]: ../../examples\\appendix\\decorator.py, True [_func]: ../../examples\\appendix\\decorator.py, False ## ![mkapi](appendix.decorated|all) module","title":"Decorators"},{"location":"appendix/decorator/#appendixdecorated","text":"Decorator examples. Functions fixture ( ) \u2014 Fixture. fixture_with_wraps ( ) \u2014 Fixture. func_with_wraps ( ) \u2014 Decorated function with wraps . func_with_wraps_double ( ) \u2014 Doubly decorated function with wraps . function","title":"appendix.decorated"},{"location":"appendix/decorator/#appendixdecoratedfunc_with_wraps","text":"Decorated function with wraps . function","title":"appendix.decorated.func_with_wraps"},{"location":"appendix/decorator/#appendixdecoratedfunc_with_wraps_double","text":"Doubly decorated function with wraps . generator","title":"appendix.decorated.func_with_wraps_double"},{"location":"appendix/decorator/#appendixdecoratedfixture","text":"Fixture. generator","title":"appendix.decorated.fixture"},{"location":"appendix/decorator/#appendixdecoratedfixture_with_wraps","text":"Fixture.","title":"appendix.decorated.fixture_with_wraps"},{"location":"appendix/filter/","text":"Filters and Variables Filters upper plain all link apilink sourcelink Variables {default} {class}","title":"Filters and Variables"},{"location":"appendix/filter/#filters-and-variables","text":"","title":"Filters and Variables"},{"location":"appendix/filter/#filters","text":"upper plain all link apilink sourcelink","title":"Filters"},{"location":"appendix/filter/#variables","text":"{default} {class}","title":"Variables"},{"location":"appendix/inherit/","text":"Inheritance and Special Methods Examples <!-- .mkapi-node { border: 2px dashed #88AA88; } --> File 8 appendix/inherit.py class Base: \"\"\"Base class.\"\"\" def func(self): \"\"\"Function.\"\"\" class Sub(Base): \"\"\"Subclass.\"\"\" # Should be added. def func(self): pass # Should not be added. def __call__(self): pass # Should not be added. def __repr__(self): pass # Should not be added. def __str__(self): pass # and so on. Superclass ![mkapi](appendix.inherit.Base) class appendix.inherit. Base ( ) Base class. Methods func ( ) \u2014 Function. method func ( ) Function. Subclass ![mkapi](appendix.inherit.Sub) class appendix.inherit. Sub ( ) Bases appendix.inherit.Base Subclass. Methods func ( ) \u2014 Function. method func ( ) Function. Implementation There are two ways to get docstring: __doc__ attribute or inspect.getdoc() . import inspect from appendix.inherit import Base, Sub Base.func.__doc__, inspect.getdoc(Base.func) [2] 2020-06-09 15:42:11 ( 5.00ms ) python3 ( 432ms ) ('Function.', 'Function.') Sub.func.__doc__, inspect.getdoc(Sub.func) [3] 2020-06-09 15:42:11 ( 3.00ms ) python3 ( 435ms ) (None, 'Function.') Because Sub.func() has no docstring, its __doc__ attribute is None . On the other hand, the super class Base.func() has docstring, so that you can get the inherited docstring using inspect.getdoc() . Therefore, MkApi uses inspect.getdoc() . Now, let's see some special methods: Sub.__call__.__doc__, inspect.getdoc(Sub.__call__) [4] 2020-06-09 15:42:11 ( 3.00ms ) python3 ( 438ms ) (None, 'Call self as a function.') Sub.__repr__.__doc__, inspect.getdoc(Sub.__repr__) [5] 2020-06-09 15:42:11 ( 3.00ms ) python3 ( 441ms ) (None, 'Return repr(self).') Sub.__repr__.__doc__, inspect.getdoc(Sub.__repr__) [6] 2020-06-09 15:42:11 ( 3.00ms ) python3 ( 444ms ) (None, 'Return repr(self).') These docstrings come from object . for name, obj in object.__dict__.items(): doc = obj.__doc__ if doc and '\\n' not in doc: print(f\"{name}: {doc}\") [7] 2020-06-09 15:42:11 ( 3.00ms ) python3 ( 447ms ) __repr__: Return repr(self). __hash__: Return hash(self). __str__: Return str(self). __getattribute__: Return getattr(self, name). __setattr__: Implement setattr(self, name, value). __delattr__: Implement delattr(self, name). __lt__: Return self<value. __le__: Return self<=value. __eq__: Return self==value. __ne__: Return self!=value. __gt__: Return self>value. __ge__: Return self>=value. __init__: Initialize self. See help(type(self)) for accurate signature. __new__: Create and return a new object. See help(type) for accurate signature. __reduce_ex__: Helper for pickle. __reduce__: Helper for pickle. __format__: Default object formatter. __sizeof__: Size of object in memory, in bytes. __dir__: Default dir() implementation. __class__: the object's class If docstring of an object is equal to that of object , the object doesn't be added into API documentation.","title":"Inheritance and Special Methods"},{"location":"appendix/inherit/#inheritance-and-special-methods","text":"","title":"Inheritance and Special Methods"},{"location":"appendix/inherit/#examples","text":"<!-- .mkapi-node { border: 2px dashed #88AA88; } --> File 8 appendix/inherit.py class Base: \"\"\"Base class.\"\"\" def func(self): \"\"\"Function.\"\"\" class Sub(Base): \"\"\"Subclass.\"\"\" # Should be added. def func(self): pass # Should not be added. def __call__(self): pass # Should not be added. def __repr__(self): pass # Should not be added. def __str__(self): pass # and so on.","title":"Examples"},{"location":"appendix/inherit/#superclass","text":"![mkapi](appendix.inherit.Base) class appendix.inherit. Base ( ) Base class. Methods func ( ) \u2014 Function. method func ( ) Function.","title":"Superclass"},{"location":"appendix/inherit/#subclass","text":"![mkapi](appendix.inherit.Sub) class appendix.inherit. Sub ( ) Bases appendix.inherit.Base Subclass. Methods func ( ) \u2014 Function. method func ( ) Function.","title":"Subclass"},{"location":"appendix/inherit/#implementation","text":"There are two ways to get docstring: __doc__ attribute or inspect.getdoc() . import inspect from appendix.inherit import Base, Sub Base.func.__doc__, inspect.getdoc(Base.func) [2] 2020-06-09 15:42:11 ( 5.00ms ) python3 ( 432ms ) ('Function.', 'Function.') Sub.func.__doc__, inspect.getdoc(Sub.func) [3] 2020-06-09 15:42:11 ( 3.00ms ) python3 ( 435ms ) (None, 'Function.') Because Sub.func() has no docstring, its __doc__ attribute is None . On the other hand, the super class Base.func() has docstring, so that you can get the inherited docstring using inspect.getdoc() . Therefore, MkApi uses inspect.getdoc() . Now, let's see some special methods: Sub.__call__.__doc__, inspect.getdoc(Sub.__call__) [4] 2020-06-09 15:42:11 ( 3.00ms ) python3 ( 438ms ) (None, 'Call self as a function.') Sub.__repr__.__doc__, inspect.getdoc(Sub.__repr__) [5] 2020-06-09 15:42:11 ( 3.00ms ) python3 ( 441ms ) (None, 'Return repr(self).') Sub.__repr__.__doc__, inspect.getdoc(Sub.__repr__) [6] 2020-06-09 15:42:11 ( 3.00ms ) python3 ( 444ms ) (None, 'Return repr(self).') These docstrings come from object . for name, obj in object.__dict__.items(): doc = obj.__doc__ if doc and '\\n' not in doc: print(f\"{name}: {doc}\") [7] 2020-06-09 15:42:11 ( 3.00ms ) python3 ( 447ms ) __repr__: Return repr(self). __hash__: Return hash(self). __str__: Return str(self). __getattribute__: Return getattr(self, name). __setattr__: Implement setattr(self, name, value). __delattr__: Implement delattr(self, name). __lt__: Return self<value. __le__: Return self<=value. __eq__: Return self==value. __ne__: Return self!=value. __gt__: Return self>value. __ge__: Return self>=value. __init__: Initialize self. See help(type(self)) for accurate signature. __new__: Create and return a new object. See help(type) for accurate signature. __reduce_ex__: Helper for pickle. __reduce__: Helper for pickle. __format__: Default object formatter. __sizeof__: Size of object in memory, in bytes. __dir__: Default dir() implementation. __class__: the object's class If docstring of an object is equal to that of object , the object doesn't be added into API documentation.","title":"Implementation"},{"location":"appendix/method/","text":"Method and Property Types <!-- .mkapi-node { border: 2px dashed #88AA88; } --> File 7 appendix/method.py class MethodTypeExample: \"\"\"Example class.\"\"\" def method(self, x): \"\"\"Method.\"\"\" def generator(self, x): \"\"\"Generator.\"\"\" yield 1 @classmethod def class_method(cls, x): \"\"\"Class method.\"\"\" @staticmethod def static_method(x): \"\"\"Static method.\"\"\" @property def read_only_property(x): \"\"\"Read only property.\"\"\" @property def read_write_property(x): \"\"\"Read write property.\"\"\" @read_write_property.setter def read_write_property(x): pass ![mkapi](appendix.method.MethodTypeExample) class appendix.method. MethodTypeExample ( ) Example class. Attributes read_only_property \u2014 Read only property. read_write_property \u2014 Read write property. Methods class_method ( x ) \u2014 Class method. generator ( x ) \u2014 Generator. method ( x ) \u2014 Method. static_method ( x ) \u2014 Static method. method method ( x ) Method. generator generator ( x ) Generator. classmethod class_method ( x ) Class method. staticmethod static_method ( x ) Static method.","title":"Method and Property Types"},{"location":"appendix/method/#method-and-property-types","text":"<!-- .mkapi-node { border: 2px dashed #88AA88; } --> File 7 appendix/method.py class MethodTypeExample: \"\"\"Example class.\"\"\" def method(self, x): \"\"\"Method.\"\"\" def generator(self, x): \"\"\"Generator.\"\"\" yield 1 @classmethod def class_method(cls, x): \"\"\"Class method.\"\"\" @staticmethod def static_method(x): \"\"\"Static method.\"\"\" @property def read_only_property(x): \"\"\"Read only property.\"\"\" @property def read_write_property(x): \"\"\"Read write property.\"\"\" @read_write_property.setter def read_write_property(x): pass ![mkapi](appendix.method.MethodTypeExample) class appendix.method. MethodTypeExample ( ) Example class. Attributes read_only_property \u2014 Read only property. read_write_property \u2014 Read write property. Methods class_method ( x ) \u2014 Class method. generator ( x ) \u2014 Generator. method ( x ) \u2014 Method. static_method ( x ) \u2014 Static method. method method ( x ) Method. generator generator ( x ) Generator. classmethod class_method ( x ) Class method. staticmethod static_method ( x ) Static method.","title":"Method and Property Types"},{"location":"appendix/order/","text":"Ordering Members in Different Files <!-- .mkapi-node { border: 2px dashed #88AA88; } --> Class members that are defined in different files are sorted by a key of (minus of source file index , line number). File 9 appendix/member_order_base.py # other code # other code # other code # other code # other code class A: def a(self): \"\"\"mro index: 1, sourcefile index: 1, line number: 13.\"\"\" File 10 appendix/member_order_sub.py from appendix.member_order_base import A class B: def b(self): \"\"\"mro index: 2, sourcefile index: 0, line number: 5.\"\"\" class C(A, B): def c(self): \"\"\"mro index: 0, sourcefile index: 0, line number: 10.\"\"\" class appendix.member_order_base. A ( ) Methods a ( ) \u2014 mro index: 1, sourcefile index: 1, line number: 13. method a ( ) mro index: 1, sourcefile index: 1, line number: 13. class appendix.member_order_sub. B ( ) Methods b ( ) \u2014 mro index: 2, sourcefile index: 0, line number: 5. method b ( ) mro index: 2, sourcefile index: 0, line number: 5. class appendix.member_order_sub. C ( ) Methods a ( ) \u2014 mro index: 1, sourcefile index: 1, line number: 13. b ( ) \u2014 mro index: 2, sourcefile index: 0, line number: 5. c ( ) \u2014 mro index: 0, sourcefile index: 0, line number: 10. method a ( ) mro index: 1, sourcefile index: 1, line number: 13. method b ( ) mro index: 2, sourcefile index: 0, line number: 5. method c ( ) mro index: 0, sourcefile index: 0, line number: 10.","title":"Ordering Members in Different Files"},{"location":"appendix/order/#ordering-members-in-different-files","text":"<!-- .mkapi-node { border: 2px dashed #88AA88; } --> Class members that are defined in different files are sorted by a key of (minus of source file index , line number). File 9 appendix/member_order_base.py # other code # other code # other code # other code # other code class A: def a(self): \"\"\"mro index: 1, sourcefile index: 1, line number: 13.\"\"\" File 10 appendix/member_order_sub.py from appendix.member_order_base import A class B: def b(self): \"\"\"mro index: 2, sourcefile index: 0, line number: 5.\"\"\" class C(A, B): def c(self): \"\"\"mro index: 0, sourcefile index: 0, line number: 10.\"\"\" class appendix.member_order_base. A ( ) Methods a ( ) \u2014 mro index: 1, sourcefile index: 1, line number: 13. method a ( ) mro index: 1, sourcefile index: 1, line number: 13. class appendix.member_order_sub. B ( ) Methods b ( ) \u2014 mro index: 2, sourcefile index: 0, line number: 5. method b ( ) mro index: 2, sourcefile index: 0, line number: 5. class appendix.member_order_sub. C ( ) Methods a ( ) \u2014 mro index: 1, sourcefile index: 1, line number: 13. b ( ) \u2014 mro index: 2, sourcefile index: 0, line number: 5. c ( ) \u2014 mro index: 0, sourcefile index: 0, line number: 10. method a ( ) mro index: 1, sourcefile index: 1, line number: 13. method b ( ) mro index: 2, sourcefile index: 0, line number: 5. method c ( ) mro index: 0, sourcefile index: 0, line number: 10.","title":"Ordering Members in Different Files"},{"location":"appendix/type/","text":"Type Annotation Examples <!-- .mkapi-node { border: 2px dashed #88AA88; } --> import mkapi [1] 2020-06-19 17:38:10 ( 2.00ms ) python3 ( 539ms ) Builtin Types def builtin(i: int, f: float, s: str, l: list, d: dict, t: tuple, e: set) -> bool: \"\"\"Function with buitin type annotation. Args: i: Integer. f: Float. s: String. l: List. d: Dictionary. t: Tuple. e: Set. \"\"\" return True mkapi.display(builtin) [2] 2020-06-19 17:38:10 ( 7.00ms ) python3 ( 546ms ) function builtin ( i , f , s , l , d , t , e ) \u2192 bool Function with buitin type annotation. Parameters i (int) \u2014 Integer. f (float) \u2014 Float. s (str) \u2014 String. l (list) \u2014 List. d (dict) \u2014 Dictionary. t (tuple) \u2014 Tuple. e (set) \u2014 Set. Builtin Types with Default def builtin_default(i: int = 1, f: float = 1.0, s: str = \"abc\", t: tuple = (1, 2)): \"\"\"Function with buitin type annotation and default. Args: i: Integer. Default={default}. f: Float. Default={default}. s: String. Default={default}. t: Tuple. Default={default}. \"\"\" mkapi.display(builtin_default) [3] 2020-06-19 17:38:10 ( 8.00ms ) python3 ( 554ms ) function builtin_default ( i=1 , f=1.0 , s='abc' , t=(1, 2) ) Function with buitin type annotation and default. Parameters i (int, optional) \u2014 Integer. Default=1. f (float, optional) \u2014 Float. Default=1.0. s (str, optional) \u2014 String. Default='abc'. t (tuple, optional) \u2014 Tuple. Default=(1, 2). Basic Collection Types from typing import Dict, List, Set, Tuple def basic(l: List[int], t: Tuple[str, int, float], d: Dict[str, int], s: Set[int]): \"\"\"Function with basic collection type annotation. Args: l: List of integer. t: Tuple of (string, string). d: Dictionary from string to integer. s: Set of integer. \"\"\" mkapi.display(basic) [4] 2020-06-19 17:38:10 ( 9.00ms ) python3 ( 563ms ) function basic ( l , t , d , s ) Function with basic collection type annotation. Parameters l (list of int) \u2014 List of integer. t (str, int, float) \u2014 Tuple of (string, string). d (dict(str: int)) \u2014 Dictionary from string to integer. s (set of int) \u2014 Set of integer. Iterator and Iterable from typing import Iterator, Iterable def function(x: Iterable[str]) -> Iterator[str]: \"\"\"Function that returns an iterator. Args: x: Iterable of string \"\"\" return iter(x) mkapi.display(function) [5] 2020-06-19 17:38:10 ( 7.00ms ) python3 ( 570ms ) function function ( x ) \u2192 iterator of str Function that returns an iterator. Parameters x (iterable of str) \u2014 Iterable of string def iterator(x: Iterable[str]) -> Iterator[str]: \"\"\"Iterator that yields string.\"\"\" yield from x mkapi.display(iterator) [6] 2020-06-19 17:38:10 ( 7.00ms ) python3 ( 577ms ) generator iterator ( x ) \u2192 str Iterator that yields string. Union and Optional from typing import Optional, Union def optional(x: Optional[List[int]]): \"\"\"Function with optional list. Args: x: List of integer or None. \"\"\" mkapi.display(optional) [7] 2020-06-19 17:38:10 ( 7.00ms ) python3 ( 584ms ) function optional ( x ) Function with optional list. Parameters x (list of int, optional) \u2014 List of integer or None. def optional_default(x: Optional[List[int]] = None): \"\"\"Function with optional list and default. Args: x: List of integer or None \"\"\" mkapi.display(optional_default) [8] 2020-06-19 17:38:10 ( 7.00ms ) python3 ( 591ms ) function optional_default ( x=None ) Function with optional list and default. Parameters x (list of int, optional) \u2014 List of integer or None def union(x: Union[int, float], y: Union[int, str, dict]): \"\"\"Function with union of builtin. Args: x: Integer or float. y: Integer, string, or dictionary. \"\"\" mkapi.display(union) [9] 2020-06-19 17:38:10 ( 7.00ms ) python3 ( 598ms ) function union ( x , y ) Function with union of builtin. Parameters x (int or float) \u2014 Integer or float. y (int, str, or dict) \u2014 Integer, string, or dictionary. def union_collection(x: Union[List[int], Tuple[str, str]]): \"\"\"Function with union of collection. Args: x: List of integer or tuple of (string, string). \"\"\" mkapi.display(union_collection) [10] 2020-06-19 17:38:10 ( 8.00ms ) python3 ( 606ms ) function union_collection ( x ) Function with union of collection. Parameters x (Union(list of int, (str, str))) \u2014 List of integer or tuple of (string, string). Callable from typing import Callable def callable( x: Callable, y: Callable[[int], str], z: Callable[[List[str], Tuple[float]], Dict[str, str]], ) -> Callable[..., int]: \"\"\"Callable. Args: x: Without arguments. y: Builtins. z: Using `typing` module. \"\"\" mkapi.display(callable) [11] 2020-06-19 17:38:10 ( 9.00ms ) python3 ( 615ms ) function callable ( x , y , z ) \u2192 callable(...: int) Callable. Parameters x (callable) \u2014 Without arguments. y (callable(int: str)) \u2014 Builtins. z (callable(list of str, (float): dict(str: str))) \u2014 Using typing module. Generator from typing import Generator, AsyncGenerator def generator( x: Generator[int, float, str], y: Generator[int, float, None], z: Generator[int, None, List[str]], ) -> Generator[int, None, None]: \"\"\"Generator. Args: x: Yield type, send type, and return type. y: Yield type and send type. z: Yield type and return type. \"\"\" mkapi.display(generator) [12] 2020-06-19 17:38:10 ( 10.0ms ) python3 ( 625ms ) function generator ( x , y , z ) \u2192 generator(int) Generator. Parameters x (generator(int, float, str)) \u2014 Yield type, send type, and return type. y (generator(int, float)) \u2014 Yield type and send type. z (generator(int,, list of str)) \u2014 Yield type and return type. def async_generator(x: AsyncGenerator[int, float], y: AsyncGenerator[int, None]): \"\"\"AsyncGenerator. Args: x: Yield type and send type. y: Yield type. \"\"\" mkapi.display(async_generator) [13] 2020-06-19 17:38:10 ( 9.00ms ) python3 ( 634ms ) function async_generator ( x , y ) AsyncGenerator. Parameters x (asyncgenerator(int, float)) \u2014 Yield type and send type. y (asyncgenerator(int)) \u2014 Yield type.","title":"Type Annotation Examples"},{"location":"appendix/type/#type-annotation-examples","text":"<!-- .mkapi-node { border: 2px dashed #88AA88; } --> import mkapi [1] 2020-06-19 17:38:10 ( 2.00ms ) python3 ( 539ms )","title":"Type Annotation Examples"},{"location":"appendix/type/#builtin-types","text":"def builtin(i: int, f: float, s: str, l: list, d: dict, t: tuple, e: set) -> bool: \"\"\"Function with buitin type annotation. Args: i: Integer. f: Float. s: String. l: List. d: Dictionary. t: Tuple. e: Set. \"\"\" return True mkapi.display(builtin) [2] 2020-06-19 17:38:10 ( 7.00ms ) python3 ( 546ms ) function builtin ( i , f , s , l , d , t , e ) \u2192 bool Function with buitin type annotation. Parameters i (int) \u2014 Integer. f (float) \u2014 Float. s (str) \u2014 String. l (list) \u2014 List. d (dict) \u2014 Dictionary. t (tuple) \u2014 Tuple. e (set) \u2014 Set.","title":"Builtin Types"},{"location":"appendix/type/#builtin-types-with-default","text":"def builtin_default(i: int = 1, f: float = 1.0, s: str = \"abc\", t: tuple = (1, 2)): \"\"\"Function with buitin type annotation and default. Args: i: Integer. Default={default}. f: Float. Default={default}. s: String. Default={default}. t: Tuple. Default={default}. \"\"\" mkapi.display(builtin_default) [3] 2020-06-19 17:38:10 ( 8.00ms ) python3 ( 554ms ) function builtin_default ( i=1 , f=1.0 , s='abc' , t=(1, 2) ) Function with buitin type annotation and default. Parameters i (int, optional) \u2014 Integer. Default=1. f (float, optional) \u2014 Float. Default=1.0. s (str, optional) \u2014 String. Default='abc'. t (tuple, optional) \u2014 Tuple. Default=(1, 2).","title":"Builtin Types with Default"},{"location":"appendix/type/#basic-collection-types","text":"from typing import Dict, List, Set, Tuple def basic(l: List[int], t: Tuple[str, int, float], d: Dict[str, int], s: Set[int]): \"\"\"Function with basic collection type annotation. Args: l: List of integer. t: Tuple of (string, string). d: Dictionary from string to integer. s: Set of integer. \"\"\" mkapi.display(basic) [4] 2020-06-19 17:38:10 ( 9.00ms ) python3 ( 563ms ) function basic ( l , t , d , s ) Function with basic collection type annotation. Parameters l (list of int) \u2014 List of integer. t (str, int, float) \u2014 Tuple of (string, string). d (dict(str: int)) \u2014 Dictionary from string to integer. s (set of int) \u2014 Set of integer.","title":"Basic Collection Types"},{"location":"appendix/type/#iterator-and-iterable","text":"from typing import Iterator, Iterable def function(x: Iterable[str]) -> Iterator[str]: \"\"\"Function that returns an iterator. Args: x: Iterable of string \"\"\" return iter(x) mkapi.display(function) [5] 2020-06-19 17:38:10 ( 7.00ms ) python3 ( 570ms ) function function ( x ) \u2192 iterator of str Function that returns an iterator. Parameters x (iterable of str) \u2014 Iterable of string def iterator(x: Iterable[str]) -> Iterator[str]: \"\"\"Iterator that yields string.\"\"\" yield from x mkapi.display(iterator) [6] 2020-06-19 17:38:10 ( 7.00ms ) python3 ( 577ms ) generator iterator ( x ) \u2192 str Iterator that yields string.","title":"Iterator and Iterable"},{"location":"appendix/type/#union-and-optional","text":"from typing import Optional, Union def optional(x: Optional[List[int]]): \"\"\"Function with optional list. Args: x: List of integer or None. \"\"\" mkapi.display(optional) [7] 2020-06-19 17:38:10 ( 7.00ms ) python3 ( 584ms ) function optional ( x ) Function with optional list. Parameters x (list of int, optional) \u2014 List of integer or None. def optional_default(x: Optional[List[int]] = None): \"\"\"Function with optional list and default. Args: x: List of integer or None \"\"\" mkapi.display(optional_default) [8] 2020-06-19 17:38:10 ( 7.00ms ) python3 ( 591ms ) function optional_default ( x=None ) Function with optional list and default. Parameters x (list of int, optional) \u2014 List of integer or None def union(x: Union[int, float], y: Union[int, str, dict]): \"\"\"Function with union of builtin. Args: x: Integer or float. y: Integer, string, or dictionary. \"\"\" mkapi.display(union) [9] 2020-06-19 17:38:10 ( 7.00ms ) python3 ( 598ms ) function union ( x , y ) Function with union of builtin. Parameters x (int or float) \u2014 Integer or float. y (int, str, or dict) \u2014 Integer, string, or dictionary. def union_collection(x: Union[List[int], Tuple[str, str]]): \"\"\"Function with union of collection. Args: x: List of integer or tuple of (string, string). \"\"\" mkapi.display(union_collection) [10] 2020-06-19 17:38:10 ( 8.00ms ) python3 ( 606ms ) function union_collection ( x ) Function with union of collection. Parameters x (Union(list of int, (str, str))) \u2014 List of integer or tuple of (string, string).","title":"Union and Optional"},{"location":"appendix/type/#callable","text":"from typing import Callable def callable( x: Callable, y: Callable[[int], str], z: Callable[[List[str], Tuple[float]], Dict[str, str]], ) -> Callable[..., int]: \"\"\"Callable. Args: x: Without arguments. y: Builtins. z: Using `typing` module. \"\"\" mkapi.display(callable) [11] 2020-06-19 17:38:10 ( 9.00ms ) python3 ( 615ms ) function callable ( x , y , z ) \u2192 callable(...: int) Callable. Parameters x (callable) \u2014 Without arguments. y (callable(int: str)) \u2014 Builtins. z (callable(list of str, (float): dict(str: str))) \u2014 Using typing module.","title":"Callable"},{"location":"appendix/type/#generator","text":"from typing import Generator, AsyncGenerator def generator( x: Generator[int, float, str], y: Generator[int, float, None], z: Generator[int, None, List[str]], ) -> Generator[int, None, None]: \"\"\"Generator. Args: x: Yield type, send type, and return type. y: Yield type and send type. z: Yield type and return type. \"\"\" mkapi.display(generator) [12] 2020-06-19 17:38:10 ( 10.0ms ) python3 ( 625ms ) function generator ( x , y , z ) \u2192 generator(int) Generator. Parameters x (generator(int, float, str)) \u2014 Yield type, send type, and return type. y (generator(int, float)) \u2014 Yield type and send type. z (generator(int,, list of str)) \u2014 Yield type and return type. def async_generator(x: AsyncGenerator[int, float], y: AsyncGenerator[int, None]): \"\"\"AsyncGenerator. Args: x: Yield type and send type. y: Yield type. \"\"\" mkapi.display(async_generator) [13] 2020-06-19 17:38:10 ( 9.00ms ) python3 ( 634ms ) function async_generator ( x , y ) AsyncGenerator. Parameters x (asyncgenerator(int, float)) \u2014 Yield type and send type. y (asyncgenerator(int)) \u2014 Yield type.","title":"Generator"},{"location":"examples/google_style/","text":"Google Style <!-- .mkapi-node { border: 2px dashed #88AA88; } --> Let's start concrete examples. Here, a sample Python file google_style.py is stored under the examples directory relative to the mkdocs.yml directory, so we would configure mkdocs.yml like below. In addition, we add an extension and extra javascript for Arithmatex . plugins: - search - mkapi: src_dirs: [examples] markdown_extensions: - pymdownx.arithmatex extra_javascript: # for pymdownx.arithmatex - https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML Function The google_style module defines a simple function add() . Code 1 google_style.add() def add(x: int, y: int = 1) -> int: \"\"\"Returns $x + y$. Args: x: The first parameter. y: The second parameter. Default={default}. Returns: Added value. Examples: Examples should be written in doctest format. >>> add(1, 2) 3 !!! note You can use the [Admonition extension of MkDocs](https://squidfunk.github.io/mkdocs-material/extensions/admonition/). Note: `Note` section is converted into the Admonition. \"\"\" return x + y Then, write a tag anywhere in your Markdown source: ![mkapi](google_style.add) MkApi generates the documentation for the add() function. function google_style. add ( x , y=1 ) Returns x + y x + y . Parameters x (int) \u2014 The first parameter. y (int, optional) \u2014 The second parameter. Default=1. Returns (int) Added value. Examples Examples should be written in doctest format. >>> add(1, 2) 3 Note You can use the Admonition extension of MkDocs . Note Note section is converted into the Admonition. Note In the above example, green dashed border lines are just guide for the eye to show the region of the documentation generated by MkApi for convenience. In this simple example, you can see some features of MkApi. Use of type annotation for both Parameters and Returns sections. Add \"optional\" if parameters have default values. Default value replacement by the {default} keyword in the Parameters section. External hyperlink. Use of MkDocs extensions: MathJax rendering and admonition. Generator The google_style module also defines a simple generator gen() . Code 2 google_style.gen() def gen(n) -> Iterator[str]: \"\"\"Yields a numbered string. Args: n (int): The length of iteration. Yields: A numbered string. \"\"\" for x in range(n): yield f\"a{x}\" Then, ![mkapi](google_style.gen) creates the documentation for the gen() generator. generator google_style. gen ( n ) Yields a numbered string. Parameters n (int) \u2014 The length of iteration. Yields (str) A numbered string. In this simple example, note that: Type inspection of gen() ( generator prefix is added before google_style.gen ). The parameter n has no type annotation but you can specify it in the Parameters section directly. Yields type is not \"iterator of str\" but \"str\", because the gen() is a generator. Class The google_style module also defines a simple class ExampleClass . Code 3 google_style.ExampleClass class ExampleClass: \"\"\"A normal class. Args: x: The first parameter. y: The second parameter. Raises: ValueError: If the length of `x` is equal to 0. \"\"\" def __init__(self, x: List[int], y: Tuple[str, int]): if len(x) == 0: raise ValueError() self.a: str = \"abc\" #: The first attribute. Comment *inline* with attribute. #: The second attribute. Comment *before* attribute. self.b: Dict[str, int] = {\"a\": 1} self.c = None \"\"\"int, optional: The third attribute. Docstring *after* attribute. Multiple paragraphs are supported.\"\"\" self.d = 100 # Not attribute description because ':' is missing. def message(self, n: int) -> List[str]: \"\"\"Returns a message list. Args: n: Repeatation. \"\"\" return [self.a] * n @property def readonly_property(self): \"\"\"str: Read-only property documentation.\"\"\" return \"readonly_property\" @property def readwrite_property(self) -> List[int]: \"\"\"Read-write property documentation.\"\"\" return [1, 2, 3] @readwrite_property.setter def readwrite_property(self, value): \"\"\"Docstring in setter is ignored.\"\"\" As usual, ![mkapi](google_style.ExampleClass) creates the documentation for the ExampleClass class. class google_style. ExampleClass ( x , y ) A normal class. Parameters x (list of int) \u2014 The first parameter. y (str, int) \u2014 The second parameter. Attributes a (str) \u2014 The first attribute. Comment inline with attribute. b (dict(str: int)) \u2014 The second attribute. Comment before attribute. c (int, optional) \u2014 The third attribute. Docstring after attribute. Multiple paragraphs are supported. readonly_property (str) \u2014 Read-only property documentation. readwrite_property (list of int) \u2014 Read-write property documentation. Raises ValueError \u2014 If the length of x is equal to 0. Methods message ( n ) (list of str) \u2014 Returns a message list. method message ( n ) \u2192 list of str Returns a message list. Parameters n (int) \u2014 Repeatation. In this example, note that: Type annotation using typing package ( List and Tuple in this case) is converted into readable style. Attributes section is inserted with type and description. These information is collected from the source code. If callable objects have neither Returns nor Yields, the type appears on the object signature line like type annotation. Properties are moved to the Attributes section with [RO] or [RW] prefix that indicates whether the property is read-only or read-write. Methods section is newly created that displays a list of methods defined in this class. Note that it has a hyperlink to the object. Note Although you can write the docstring for a class in the __init__() function, the attribute inspection only works when you write it as a class level docstring. Method You can select a method of class (or any other object that can have docstring) to generate the documentation. ![mkapi](google_style.ExampleClass.message) creates the documentation for the message() of ExampleClass class. method message ( n ) \u2192 list of str Returns a message list. Parameters n (int) \u2014 Repeatation. Data Class The google_style module also defines a simple data class ExampleDataClass . Code 4 google_style.ExampleDataClass @dataclass class ExampleDataClass: \"\"\"A dataclass. Args: x: The first parameter. Attributes: x: The first attribute. y: The second attribute. \"\"\" x: int = 0 y: int = field(default=1, init=False) Then, ![mkapi](google_style.ExampleDataClass) creates the documentation for the ExampleDataClass class. dataclass google_style. ExampleDataClass ( x=0 ) A dataclass. Parameters x (int, optional) \u2014 The first parameter. Attributes x (int) \u2014 The first attribute. y (int) \u2014 The second attribute. In this example, note that: A dataclass prefix instead of a class prefix. Attributes type inspection as well as parameters if they are data class fields. Note The Napoleon project provides complete examples: Example Google Style Python Docstrings Example NumPy Style Python Docstrings","title":"Google Style"},{"location":"examples/google_style/#google-style","text":"<!-- .mkapi-node { border: 2px dashed #88AA88; } --> Let's start concrete examples. Here, a sample Python file google_style.py is stored under the examples directory relative to the mkdocs.yml directory, so we would configure mkdocs.yml like below. In addition, we add an extension and extra javascript for Arithmatex . plugins: - search - mkapi: src_dirs: [examples] markdown_extensions: - pymdownx.arithmatex extra_javascript: # for pymdownx.arithmatex - https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML","title":"Google Style"},{"location":"examples/google_style/#function","text":"The google_style module defines a simple function add() . Code 1 google_style.add() def add(x: int, y: int = 1) -> int: \"\"\"Returns $x + y$. Args: x: The first parameter. y: The second parameter. Default={default}. Returns: Added value. Examples: Examples should be written in doctest format. >>> add(1, 2) 3 !!! note You can use the [Admonition extension of MkDocs](https://squidfunk.github.io/mkdocs-material/extensions/admonition/). Note: `Note` section is converted into the Admonition. \"\"\" return x + y Then, write a tag anywhere in your Markdown source: ![mkapi](google_style.add) MkApi generates the documentation for the add() function. function google_style. add ( x , y=1 ) Returns x + y x + y . Parameters x (int) \u2014 The first parameter. y (int, optional) \u2014 The second parameter. Default=1. Returns (int) Added value. Examples Examples should be written in doctest format. >>> add(1, 2) 3 Note You can use the Admonition extension of MkDocs . Note Note section is converted into the Admonition. Note In the above example, green dashed border lines are just guide for the eye to show the region of the documentation generated by MkApi for convenience. In this simple example, you can see some features of MkApi. Use of type annotation for both Parameters and Returns sections. Add \"optional\" if parameters have default values. Default value replacement by the {default} keyword in the Parameters section. External hyperlink. Use of MkDocs extensions: MathJax rendering and admonition.","title":"Function"},{"location":"examples/google_style/#generator","text":"The google_style module also defines a simple generator gen() . Code 2 google_style.gen() def gen(n) -> Iterator[str]: \"\"\"Yields a numbered string. Args: n (int): The length of iteration. Yields: A numbered string. \"\"\" for x in range(n): yield f\"a{x}\" Then, ![mkapi](google_style.gen) creates the documentation for the gen() generator. generator google_style. gen ( n ) Yields a numbered string. Parameters n (int) \u2014 The length of iteration. Yields (str) A numbered string. In this simple example, note that: Type inspection of gen() ( generator prefix is added before google_style.gen ). The parameter n has no type annotation but you can specify it in the Parameters section directly. Yields type is not \"iterator of str\" but \"str\", because the gen() is a generator.","title":"Generator"},{"location":"examples/google_style/#class","text":"The google_style module also defines a simple class ExampleClass . Code 3 google_style.ExampleClass class ExampleClass: \"\"\"A normal class. Args: x: The first parameter. y: The second parameter. Raises: ValueError: If the length of `x` is equal to 0. \"\"\" def __init__(self, x: List[int], y: Tuple[str, int]): if len(x) == 0: raise ValueError() self.a: str = \"abc\" #: The first attribute. Comment *inline* with attribute. #: The second attribute. Comment *before* attribute. self.b: Dict[str, int] = {\"a\": 1} self.c = None \"\"\"int, optional: The third attribute. Docstring *after* attribute. Multiple paragraphs are supported.\"\"\" self.d = 100 # Not attribute description because ':' is missing. def message(self, n: int) -> List[str]: \"\"\"Returns a message list. Args: n: Repeatation. \"\"\" return [self.a] * n @property def readonly_property(self): \"\"\"str: Read-only property documentation.\"\"\" return \"readonly_property\" @property def readwrite_property(self) -> List[int]: \"\"\"Read-write property documentation.\"\"\" return [1, 2, 3] @readwrite_property.setter def readwrite_property(self, value): \"\"\"Docstring in setter is ignored.\"\"\" As usual, ![mkapi](google_style.ExampleClass) creates the documentation for the ExampleClass class. class google_style. ExampleClass ( x , y ) A normal class. Parameters x (list of int) \u2014 The first parameter. y (str, int) \u2014 The second parameter. Attributes a (str) \u2014 The first attribute. Comment inline with attribute. b (dict(str: int)) \u2014 The second attribute. Comment before attribute. c (int, optional) \u2014 The third attribute. Docstring after attribute. Multiple paragraphs are supported. readonly_property (str) \u2014 Read-only property documentation. readwrite_property (list of int) \u2014 Read-write property documentation. Raises ValueError \u2014 If the length of x is equal to 0. Methods message ( n ) (list of str) \u2014 Returns a message list. method message ( n ) \u2192 list of str Returns a message list. Parameters n (int) \u2014 Repeatation. In this example, note that: Type annotation using typing package ( List and Tuple in this case) is converted into readable style. Attributes section is inserted with type and description. These information is collected from the source code. If callable objects have neither Returns nor Yields, the type appears on the object signature line like type annotation. Properties are moved to the Attributes section with [RO] or [RW] prefix that indicates whether the property is read-only or read-write. Methods section is newly created that displays a list of methods defined in this class. Note that it has a hyperlink to the object. Note Although you can write the docstring for a class in the __init__() function, the attribute inspection only works when you write it as a class level docstring.","title":"Class"},{"location":"examples/google_style/#method","text":"You can select a method of class (or any other object that can have docstring) to generate the documentation. ![mkapi](google_style.ExampleClass.message) creates the documentation for the message() of ExampleClass class. method message ( n ) \u2192 list of str Returns a message list. Parameters n (int) \u2014 Repeatation.","title":"Method"},{"location":"examples/google_style/#data-class","text":"The google_style module also defines a simple data class ExampleDataClass . Code 4 google_style.ExampleDataClass @dataclass class ExampleDataClass: \"\"\"A dataclass. Args: x: The first parameter. Attributes: x: The first attribute. y: The second attribute. \"\"\" x: int = 0 y: int = field(default=1, init=False) Then, ![mkapi](google_style.ExampleDataClass) creates the documentation for the ExampleDataClass class. dataclass google_style. ExampleDataClass ( x=0 ) A dataclass. Parameters x (int, optional) \u2014 The first parameter. Attributes x (int) \u2014 The first attribute. y (int) \u2014 The second attribute. In this example, note that: A dataclass prefix instead of a class prefix. Attributes type inspection as well as parameters if they are data class fields. Note The Napoleon project provides complete examples: Example Google Style Python Docstrings Example NumPy Style Python Docstrings","title":"Data Class"},{"location":"examples/numpy_style/","text":"NumPy Style <!-- .mkapi-node { border: 2px dashed #88AA88; } --> Let's start concrete examples. Here, a sample Python file numpy_style.py is stored under the examples directory relative to the mkdocs.yml directory, so we would configure mkdocs.yml like below. In addition, we add an extension and extra javascript for Arithmatex . plugins: - search - mkapi: src_dirs: [examples] markdown_extensions: - pymdownx.arithmatex extra_javascript: # for pymdownx.arithmatex - https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML Function The numpy_style module defines a simple function add() . Code 5 numpy_style.add() def add(x: int, y: int = 1) -> int: \"\"\"Returns $x + y$. Parameters ---------- x The first parameter. y The second parameter. Default={default}. Returns ------- int Added value. !!! note The return type must be duplicated in the docstring to comply with the NumPy docstring style. Examples -------- Examples should be written in doctest format. >>> add(1, 2) 3 Note ---- MkApi doesn't check an underline that follows a section heading. Just skip one line. \"\"\" return x + y Then, write a tag anywhere in your Markdown source: ![mkapi](numpy_style.add) MkApi generates the API documentation for the add() function. function numpy_style. add ( x , y=1 ) Returns x + y x + y . Parameters x (int) \u2014 The first parameter. y (int, optional) \u2014 The second parameter. Default=1. Returns (int) Added value. Note The return type must be duplicated in the docstring to comply with the NumPy docstring style. Examples Examples should be written in doctest format. >>> add(1, 2) 3 Note MkApi doesn't check an underline that follows a section heading. Just skip one line. Note In the above example, green dashed border lines are just guide for the eye to show the region of the documentation generated by MkApi for convenience. In this simple example, you can see some features of MkApi. Use of type annotation for both Parameters and Returns sections. Add optional if parameters have default values. Default value replacement by the {default} keyword in the Parameters section. External hyperlink. Use of MkDocs extensions: MathJax rendering and admonition. Generator The numpy_style module also defines a simple generator gen() . Code 6 numpy_style.gen() def gen(n) -> Iterator[str]: \"\"\"Yields a numbered string. Parameters ---------- n : int The length of iteration. Yields ------ str A numbered string. \"\"\" for x in range(n): yield f\"a{x}\" Then, ![mkapi](numpy_style.gen) creates the documentation for the gen() generator. generator numpy_style. gen ( n ) Yields a numbered string. Parameters n (int) \u2014 The length of iteration. Yields (str) A numbered string. In this simple example, note that: Type inspection of gen() ( generator prefix is added before google_style.gen ). The parameter n has no type annotation but you can specify it in the Parameters section directly. Yields type is not \"iterator of str\" but \"str\", because the gen() is a generator. Class The numpy_style module also defines a simple class ExampleClass . Code 7 numpy_style.ExampleClass class ExampleClass: \"\"\"A normal class. Parameters ---------- x The first parameter. y The second parameter. Raises ------ ValueError If the length of `x` is equal to 0. \"\"\" def __init__(self, x: List[int], y: Tuple[str, int]): if len(x) == 0: raise ValueError() self.a: str = \"abc\" #: The first attribute. Comment *inline* with attribute. #: The second attribute. Comment *before* attribute. self.b: Dict[str, int] = {\"a\": 1} self.c = None \"\"\"int, optional: The third attribute. Docstring *after* attribute. Multiple paragraphs are supported.\"\"\" self.d = 100 # Not attribute description because ':' is missing. def message(self, n: int) -> List[str]: \"\"\"Returns a message list. Parameters ---------- n Repeatation. \"\"\" return [self.a] * n @property def readonly_property(self): \"\"\"str: Read-only property documentation.\"\"\" return \"readonly_property\" @property def readwrite_property(self) -> List[int]: \"\"\"Read-write property documentation.\"\"\" return [1, 2, 3] @readwrite_property.setter def readwrite_property(self, value): \"\"\"Docstring in setter is ignored.\"\"\" As usual, ![mkapi](numpy_style.ExampleClass) creates the documentation for the ExampleClass class. class numpy_style. ExampleClass ( x , y ) A normal class. Parameters x (list of int) \u2014 The first parameter. y (str, int) \u2014 The second parameter. Attributes a (str) \u2014 The first attribute. Comment inline with attribute. b (dict(str: int)) \u2014 The second attribute. Comment before attribute. c (int, optional) \u2014 The third attribute. Docstring after attribute. Multiple paragraphs are supported. readonly_property (str) \u2014 Read-only property documentation. readwrite_property (list of int) \u2014 Read-write property documentation. Raises ValueError \u2014 If the length of x is equal to 0. Methods message ( n ) (list of str) \u2014 Returns a message list. method message ( n ) \u2192 list of str Returns a message list. Parameters n (int) \u2014 Repeatation. In this example, note that: Type annotation using typing package ( List and Tuple in this case) is converted into readable style. Attributes section is inserted with type and description. These information is collected from the source code. If callable objects have neither Returns nor Yields, the type appears on the object signature line like type annotation. Properties are moved to the Attributes section with [RO] or [RW] prefix that indicates whether the property is read-only or read-write. Methods section is newly created that displays a list of methods defined in this class. Note that it has a hyperlink to the object. Note Although you can write the docstring for a class in the __init__() function, the attribute inspection only works when you write it as a class level docstring. Method You can select a method of class (or any other object that can have docstring) to generate the documentation. ![mkapi](numpy_style.ExampleClass.message) creates the documentation for the message() of ExampleClass class. method message ( n ) \u2192 list of str Returns a message list. Parameters n (int) \u2014 Repeatation. Data Class The numpy_style module also defines a simple data class ExampleDataClass . Code 8 numpy_style.ExampleDataClass @dataclass class ExampleDataClass: \"\"\"A dataclass. Parameters ---------- x The first parameter. Attributes ---------- x The first attribute. y The second attribute. \"\"\" x: int = 0 y: int = field(default=1, init=False) Then, ![mkapi](numpy_style.ExampleDataClass) creates the documentation for the ExampleDataClass class. dataclass numpy_style. ExampleDataClass ( x=0 ) A dataclass. Parameters x (int, optional) \u2014 The first parameter. Attributes x (int) \u2014 The first attribute. y (int) \u2014 The second attribute. In this example, note that: A dataclass prefix instead of a class prefix. Attributes type inspection as well as parameters if they are data class fields. Note The Napoleon project provides complete examples: Example Google Style Python Docstrings Example NumPy Style Python Docstrings","title":"NumPy Style"},{"location":"examples/numpy_style/#numpy-style","text":"<!-- .mkapi-node { border: 2px dashed #88AA88; } --> Let's start concrete examples. Here, a sample Python file numpy_style.py is stored under the examples directory relative to the mkdocs.yml directory, so we would configure mkdocs.yml like below. In addition, we add an extension and extra javascript for Arithmatex . plugins: - search - mkapi: src_dirs: [examples] markdown_extensions: - pymdownx.arithmatex extra_javascript: # for pymdownx.arithmatex - https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML","title":"NumPy Style"},{"location":"examples/numpy_style/#function","text":"The numpy_style module defines a simple function add() . Code 5 numpy_style.add() def add(x: int, y: int = 1) -> int: \"\"\"Returns $x + y$. Parameters ---------- x The first parameter. y The second parameter. Default={default}. Returns ------- int Added value. !!! note The return type must be duplicated in the docstring to comply with the NumPy docstring style. Examples -------- Examples should be written in doctest format. >>> add(1, 2) 3 Note ---- MkApi doesn't check an underline that follows a section heading. Just skip one line. \"\"\" return x + y Then, write a tag anywhere in your Markdown source: ![mkapi](numpy_style.add) MkApi generates the API documentation for the add() function. function numpy_style. add ( x , y=1 ) Returns x + y x + y . Parameters x (int) \u2014 The first parameter. y (int, optional) \u2014 The second parameter. Default=1. Returns (int) Added value. Note The return type must be duplicated in the docstring to comply with the NumPy docstring style. Examples Examples should be written in doctest format. >>> add(1, 2) 3 Note MkApi doesn't check an underline that follows a section heading. Just skip one line. Note In the above example, green dashed border lines are just guide for the eye to show the region of the documentation generated by MkApi for convenience. In this simple example, you can see some features of MkApi. Use of type annotation for both Parameters and Returns sections. Add optional if parameters have default values. Default value replacement by the {default} keyword in the Parameters section. External hyperlink. Use of MkDocs extensions: MathJax rendering and admonition.","title":"Function"},{"location":"examples/numpy_style/#generator","text":"The numpy_style module also defines a simple generator gen() . Code 6 numpy_style.gen() def gen(n) -> Iterator[str]: \"\"\"Yields a numbered string. Parameters ---------- n : int The length of iteration. Yields ------ str A numbered string. \"\"\" for x in range(n): yield f\"a{x}\" Then, ![mkapi](numpy_style.gen) creates the documentation for the gen() generator. generator numpy_style. gen ( n ) Yields a numbered string. Parameters n (int) \u2014 The length of iteration. Yields (str) A numbered string. In this simple example, note that: Type inspection of gen() ( generator prefix is added before google_style.gen ). The parameter n has no type annotation but you can specify it in the Parameters section directly. Yields type is not \"iterator of str\" but \"str\", because the gen() is a generator.","title":"Generator"},{"location":"examples/numpy_style/#class","text":"The numpy_style module also defines a simple class ExampleClass . Code 7 numpy_style.ExampleClass class ExampleClass: \"\"\"A normal class. Parameters ---------- x The first parameter. y The second parameter. Raises ------ ValueError If the length of `x` is equal to 0. \"\"\" def __init__(self, x: List[int], y: Tuple[str, int]): if len(x) == 0: raise ValueError() self.a: str = \"abc\" #: The first attribute. Comment *inline* with attribute. #: The second attribute. Comment *before* attribute. self.b: Dict[str, int] = {\"a\": 1} self.c = None \"\"\"int, optional: The third attribute. Docstring *after* attribute. Multiple paragraphs are supported.\"\"\" self.d = 100 # Not attribute description because ':' is missing. def message(self, n: int) -> List[str]: \"\"\"Returns a message list. Parameters ---------- n Repeatation. \"\"\" return [self.a] * n @property def readonly_property(self): \"\"\"str: Read-only property documentation.\"\"\" return \"readonly_property\" @property def readwrite_property(self) -> List[int]: \"\"\"Read-write property documentation.\"\"\" return [1, 2, 3] @readwrite_property.setter def readwrite_property(self, value): \"\"\"Docstring in setter is ignored.\"\"\" As usual, ![mkapi](numpy_style.ExampleClass) creates the documentation for the ExampleClass class. class numpy_style. ExampleClass ( x , y ) A normal class. Parameters x (list of int) \u2014 The first parameter. y (str, int) \u2014 The second parameter. Attributes a (str) \u2014 The first attribute. Comment inline with attribute. b (dict(str: int)) \u2014 The second attribute. Comment before attribute. c (int, optional) \u2014 The third attribute. Docstring after attribute. Multiple paragraphs are supported. readonly_property (str) \u2014 Read-only property documentation. readwrite_property (list of int) \u2014 Read-write property documentation. Raises ValueError \u2014 If the length of x is equal to 0. Methods message ( n ) (list of str) \u2014 Returns a message list. method message ( n ) \u2192 list of str Returns a message list. Parameters n (int) \u2014 Repeatation. In this example, note that: Type annotation using typing package ( List and Tuple in this case) is converted into readable style. Attributes section is inserted with type and description. These information is collected from the source code. If callable objects have neither Returns nor Yields, the type appears on the object signature line like type annotation. Properties are moved to the Attributes section with [RO] or [RW] prefix that indicates whether the property is read-only or read-write. Methods section is newly created that displays a list of methods defined in this class. Note that it has a hyperlink to the object. Note Although you can write the docstring for a class in the __init__() function, the attribute inspection only works when you write it as a class level docstring.","title":"Class"},{"location":"examples/numpy_style/#method","text":"You can select a method of class (or any other object that can have docstring) to generate the documentation. ![mkapi](numpy_style.ExampleClass.message) creates the documentation for the message() of ExampleClass class. method message ( n ) \u2192 list of str Returns a message list. Parameters n (int) \u2014 Repeatation.","title":"Method"},{"location":"examples/numpy_style/#data-class","text":"The numpy_style module also defines a simple data class ExampleDataClass . Code 8 numpy_style.ExampleDataClass @dataclass class ExampleDataClass: \"\"\"A dataclass. Parameters ---------- x The first parameter. Attributes ---------- x The first attribute. y The second attribute. \"\"\" x: int = 0 y: int = field(default=1, init=False) Then, ![mkapi](numpy_style.ExampleDataClass) creates the documentation for the ExampleDataClass class. dataclass numpy_style. ExampleDataClass ( x=0 ) A dataclass. Parameters x (int, optional) \u2014 The first parameter. Attributes x (int) \u2014 The first attribute. y (int) \u2014 The second attribute. In this example, note that: A dataclass prefix instead of a class prefix. Attributes type inspection as well as parameters if they are data class fields. Note The Napoleon project provides complete examples: Example Google Style Python Docstrings Example NumPy Style Python Docstrings","title":"Data Class"},{"location":"usage/custom/","text":"Customization Customization 'on_config'. MkApi has an option on_config to allow users to configure MkDocs/MkApi or user system environment. Here is an example directory structure and the corresponding mkdocs.yml : # Directory structure myproject: - docs: - index.md - examples: - custom.py - mkdocs.yml # mkdocs.yml plugins: - search - mkapi: src_dirs: [examples] on_config: custom.on_config Customization script is defined in examples/custom.py : File 6 examples/custom.py def on_config(): # Here you can do all you want. print(\"Called.\") def on_config_with_config(config): print(\"Called with config.\") print(config[\"docs_dir\"]) # You can change config, for example: # config['docs_dir'] = 'other_directory' # Optionally, you can return altered config to customize MkDocs. # return config def on_config_with_mkapi(config, mkapi): print(\"Called with config and mkapi.\") print(config[\"docs_dir\"]) print(mkapi) Let's build the documentation. $ mkdocs build INFO - [MkApi] Calling user 'on_config' with [] Called. INFO - Cleaning site directory ... on_config() can take config and/or mkapi arguments. # mkdocs.yml plugins: - search - mkapi: src_dirs: [examples] on_config: custom.on_config_with_config $ mkdocs build INFO - [MkApi] Calling user 'on_config' with ['config'] Called with config. C:\\Users\\daizu\\Documents\\github\\mkapi\\docs INFO - Cleaning site directory ... # mkdocs.yml plugins: - search - mkapi: src_dirs: [examples] on_config: custom.on_config_with_mkapi $ mkdocs build INFO - [MkApi] Calling user 'on_config' with ['config', 'mkapi'] Called with config and mkapi. C:\\Users\\daizu\\Documents\\github\\mkapi\\docs <mkapi.plugins.mkdocs.MkapiPlugin object at 0x000001DF712D0F08> INFO - Cleaning site directory ...","title":"Customization"},{"location":"usage/custom/#customization","text":"","title":"Customization"},{"location":"usage/custom/#customization-on_config","text":"MkApi has an option on_config to allow users to configure MkDocs/MkApi or user system environment. Here is an example directory structure and the corresponding mkdocs.yml : # Directory structure myproject: - docs: - index.md - examples: - custom.py - mkdocs.yml # mkdocs.yml plugins: - search - mkapi: src_dirs: [examples] on_config: custom.on_config Customization script is defined in examples/custom.py : File 6 examples/custom.py def on_config(): # Here you can do all you want. print(\"Called.\") def on_config_with_config(config): print(\"Called with config.\") print(config[\"docs_dir\"]) # You can change config, for example: # config['docs_dir'] = 'other_directory' # Optionally, you can return altered config to customize MkDocs. # return config def on_config_with_mkapi(config, mkapi): print(\"Called with config and mkapi.\") print(config[\"docs_dir\"]) print(mkapi) Let's build the documentation. $ mkdocs build INFO - [MkApi] Calling user 'on_config' with [] Called. INFO - Cleaning site directory ... on_config() can take config and/or mkapi arguments. # mkdocs.yml plugins: - search - mkapi: src_dirs: [examples] on_config: custom.on_config_with_config $ mkdocs build INFO - [MkApi] Calling user 'on_config' with ['config'] Called with config. C:\\Users\\daizu\\Documents\\github\\mkapi\\docs INFO - Cleaning site directory ... # mkdocs.yml plugins: - search - mkapi: src_dirs: [examples] on_config: custom.on_config_with_mkapi $ mkdocs build INFO - [MkApi] Calling user 'on_config' with ['config', 'mkapi'] Called with config and mkapi. C:\\Users\\daizu\\Documents\\github\\mkapi\\docs <mkapi.plugins.mkdocs.MkapiPlugin object at 0x000001DF712D0F08> INFO - Cleaning site directory ...","title":"Customization &#39;on_config&#39;."},{"location":"usage/inherit/","text":"Docstring Inheritance <!-- .mkapi-node { border: 2px dashed #88AA88; margin-left: 0px; margin-bottom: 20px; } --> Define two classes to explain Docstring inheritance . File 2 inherit.py from dataclasses import dataclass from mkapi.core.base import Type @dataclass class Base: \"\"\"Base class. Parameters: name: Object name. Attributes: name: Object name. \"\"\" name: str type: Type def set_name(self, name: str): \"\"\"Sets name. Args: name: A New name. \"\"\" self.name = name @dataclass class Item(Base): \"\"\"Item class. Parameters: markdown: Object markdown. Attributes: markdown: Object markdown. \"\"\" markdown: str def set_name(self, name: str): \"\"\"Sets name in upper case.\"\"\" self.name = name.upper() Taking a look at this example, you may notice that: In the Base , there is no description for type . In the Item , parameters inherited from the superclass are not written. In the Item.set_name() , Parameters section itself doesn't exist. Inheritance from Superclasses Since the docstring of the superclass Base describes the name , the Item class can inherit its description. ![mkapi](inherit.Item) dataclass inherit. Item ( name , type , markdown ) Bases inherit.Base Item class. Parameters name (str) \u2014 Object name. markdown (str) \u2014 Object markdown. Attributes markdown (str) \u2014 Object markdown. name (str) \u2014 Object name. Methods set_name ( name ) \u2014 Sets name in upper case. method set_name ( name ) Sets name in upper case. Parameters name (str) \u2014 A New name. By inheritance from superclasses, you don't need to write duplicated description. Inheritance from Signature Using strict filter, MkApi also adds parameters and attributes without description using its signature. Description is still empty but type is inspected. ![mkapi](inherit.Item|strict) dataclass inherit. Item ( name , type , markdown ) Bases inherit.Base Item class. Parameters name (str) \u2014 Object name. type ( Type ) \u2014 markdown (str) \u2014 Object markdown. Attributes markdown (str) \u2014 Object markdown. name (str) \u2014 Object name. type ( Type ) \u2014 Methods set_name ( name ) \u2014 Sets name in upper case. method set_name ( name ) Sets name in upper case. Parameters name (str) \u2014 A New name. Inheritance from signature has two benefits: You can find parameters and attributes that wait for description. Users can know their types at least if you use type annotation. Inheritance in Page Mode Inheritance in page mode is straightforward. For example, nav: - index.md - API: mkapi/api/mkapi|upper|strict Inheritance in Dataclass File 3 inherit_comment.py from dataclasses import dataclass from mkapi.core.base import Type @dataclass class Base: \"\"\"Base class.\"\"\" name: str #: Object name. type: Type #: Object type. def set_name(self, name: str): \"\"\"Sets name. Args: name: A New name. \"\"\" self.name = name @dataclass class Item(Base): \"\"\"Item class.\"\"\" markdown: str #: Object Markdown. def set_name(self, name: str): \"\"\"Sets name in upper case.\"\"\" self.name = name.upper() ![mkapi](inherit_comment.Item) dataclass inherit_comment. Item ( name , type , markdown ) Bases inherit_comment.Base Item class. Parameters name (str) \u2014 Object name. type ( Type ) \u2014 Object type. markdown (str) \u2014 Object Markdown. Attributes markdown (str) \u2014 Object Markdown. name (str) \u2014 Object name. type ( Type ) \u2014 Object type. Methods set_name ( name ) \u2014 Sets name in upper case. method set_name ( name ) Sets name in upper case. Parameters name (str) \u2014 A New name.","title":"Docstring Inheritance"},{"location":"usage/inherit/#docstring-inheritance","text":"<!-- .mkapi-node { border: 2px dashed #88AA88; margin-left: 0px; margin-bottom: 20px; } --> Define two classes to explain Docstring inheritance . File 2 inherit.py from dataclasses import dataclass from mkapi.core.base import Type @dataclass class Base: \"\"\"Base class. Parameters: name: Object name. Attributes: name: Object name. \"\"\" name: str type: Type def set_name(self, name: str): \"\"\"Sets name. Args: name: A New name. \"\"\" self.name = name @dataclass class Item(Base): \"\"\"Item class. Parameters: markdown: Object markdown. Attributes: markdown: Object markdown. \"\"\" markdown: str def set_name(self, name: str): \"\"\"Sets name in upper case.\"\"\" self.name = name.upper() Taking a look at this example, you may notice that: In the Base , there is no description for type . In the Item , parameters inherited from the superclass are not written. In the Item.set_name() , Parameters section itself doesn't exist.","title":"Docstring Inheritance"},{"location":"usage/inherit/#inheritance-from-superclasses","text":"Since the docstring of the superclass Base describes the name , the Item class can inherit its description. ![mkapi](inherit.Item) dataclass inherit. Item ( name , type , markdown ) Bases inherit.Base Item class. Parameters name (str) \u2014 Object name. markdown (str) \u2014 Object markdown. Attributes markdown (str) \u2014 Object markdown. name (str) \u2014 Object name. Methods set_name ( name ) \u2014 Sets name in upper case. method set_name ( name ) Sets name in upper case. Parameters name (str) \u2014 A New name. By inheritance from superclasses, you don't need to write duplicated description.","title":"Inheritance from Superclasses"},{"location":"usage/inherit/#inheritance-from-signature","text":"Using strict filter, MkApi also adds parameters and attributes without description using its signature. Description is still empty but type is inspected. ![mkapi](inherit.Item|strict) dataclass inherit. Item ( name , type , markdown ) Bases inherit.Base Item class. Parameters name (str) \u2014 Object name. type ( Type ) \u2014 markdown (str) \u2014 Object markdown. Attributes markdown (str) \u2014 Object markdown. name (str) \u2014 Object name. type ( Type ) \u2014 Methods set_name ( name ) \u2014 Sets name in upper case. method set_name ( name ) Sets name in upper case. Parameters name (str) \u2014 A New name. Inheritance from signature has two benefits: You can find parameters and attributes that wait for description. Users can know their types at least if you use type annotation.","title":"Inheritance from Signature"},{"location":"usage/inherit/#inheritance-in-page-mode","text":"Inheritance in page mode is straightforward. For example, nav: - index.md - API: mkapi/api/mkapi|upper|strict","title":"Inheritance in Page Mode"},{"location":"usage/inherit/#inheritance-in-dataclass","text":"File 3 inherit_comment.py from dataclasses import dataclass from mkapi.core.base import Type @dataclass class Base: \"\"\"Base class.\"\"\" name: str #: Object name. type: Type #: Object type. def set_name(self, name: str): \"\"\"Sets name. Args: name: A New name. \"\"\" self.name = name @dataclass class Item(Base): \"\"\"Item class.\"\"\" markdown: str #: Object Markdown. def set_name(self, name: str): \"\"\"Sets name in upper case.\"\"\" self.name = name.upper() ![mkapi](inherit_comment.Item) dataclass inherit_comment. Item ( name , type , markdown ) Bases inherit_comment.Base Item class. Parameters name (str) \u2014 Object name. type ( Type ) \u2014 Object type. markdown (str) \u2014 Object Markdown. Attributes markdown (str) \u2014 Object Markdown. name (str) \u2014 Object name. type ( Type ) \u2014 Object type. Methods set_name ( name ) \u2014 Sets name in upper case. method set_name ( name ) Sets name in upper case. Parameters name (str) \u2014 A New name.","title":"Inheritance in Dataclass"},{"location":"usage/library/","text":"Using MkApi within Python MkApi is a standalone library as well as a MkDocs plugin, so that you can use it within Python. First, import MkApi: <!-- .mkapi-node { border: 2px dashed #88AA88; } --> import mkapi [1] 2020-06-19 17:38:10 ( 84.0ms ) python3 ( 239ms ) Node object Define a simple class to show how MkApi works. class A: \"\"\"Class docstring. Note: Docstring of `__init__()` is deleted, if there is a class-level docstring. \"\"\" def __init__(self): \"\"\"Init docstring.\"\"\" self.a: int = 1 #: Integer **attribute**. def to_str(self, x: int) -> str: \"\"\"Converts `int` to `str`. Args: x: Input **value**. \"\"\" return str(x) [2] 2020-06-19 17:38:10 ( 4.00ms ) python3 ( 243ms ) mkapi.get_node() generates a Node object that has tree structure. node = mkapi.get_node(A) type(node) [3] 2020-06-19 17:38:10 ( 5.00ms ) python3 ( 248ms ) mkapi.core.node.Node Some attributes: node.object.kind, node.object.name [4] 2020-06-19 17:38:10 ( 3.00ms ) python3 ( 251ms ) ('class', 'A') docstring = node.docstring len(docstring.sections) [5] 2020-06-19 17:38:10 ( 3.00ms ) python3 ( 254ms ) 1 section = docstring.sections[0] section.name, section.markdown [6] 2020-06-19 17:38:10 ( 5.00ms ) python3 ( 259ms ) ('', 'Class docstring.\\n\\n!!! note \"Note\"\\n Docstring of `__init__()` is deleted, if there is\\n a class-level docstring.') section = docstring.sections[1] section.name, section.markdown [7] 2020-06-19 17:38:10 ( 77.0ms ) python3 ( 336ms ) IndexError: list index out of range IndexError Traceback (most recent call last) <ipython-input-41-d901a3af02a6> in <module> ----> 1 section = docstring.sections[1] 2 section.name, section.markdown The members attribute gives children, for example, bound methods of a class. len(node.members) [8] 2020-06-19 17:38:10 ( 105ms ) python3 ( 441ms ) 1 child = node.members[0] type(child) [9] 2020-06-19 17:38:10 ( 3.00ms ) python3 ( 444ms ) mkapi.core.node.Node Elements of Node.members are also Node objects, so this is a tree structure. child.object.kind, child.object.name [10] 2020-06-19 17:38:10 ( 4.00ms ) python3 ( 448ms ) ('method', 'to_str') docstring = child.docstring len(docstring.sections) [11] 2020-06-19 17:38:10 ( 3.00ms ) python3 ( 451ms ) 2 section = docstring.sections[0] section.name, section.markdown [12] 2020-06-19 17:38:10 ( 4.00ms ) python3 ( 455ms ) ('', 'Converts `int` to `str`.') section = docstring.sections[1] section.name, section.markdown [13] 2020-06-19 17:38:10 ( 4.00ms ) python3 ( 459ms ) ('Parameters', '') The above Parameters section has an empty markdown , while its items represents an argument list: item = section.items[0] print(item) print(item.type) print(item.description) [14] 2020-06-19 17:38:10 ( 4.00ms ) python3 ( 463ms ) Item('x', 'int') Type('int') Inline('Input **value**.') Node.get_markdown() creates a joint Markdown of this node. markdown = node.get_markdown() print(markdown) [15] 2020-06-19 17:38:10 ( 3.00ms ) python3 ( 466ms ) A <!-- mkapi:sep --> Class docstring. !!! note \"Note\" Docstring of `__init__()` is deleted, if there is a class-level docstring. <!-- mkapi:sep --> __main__.A.to_str <!-- mkapi:sep --> Converts `int` to `str`. <!-- mkapi:sep --> Input **value**. Where is Note or Parameters section heading, etc. ? No problem. The Node.get_markdown() divides docstrings into two parts. One is a plain Markdown that will be converted into HTML by any Markdown converter, for example, MkDocs. The other is the outline structure of docstrings such as sections or arguments that will be processed by MkApi itself. Converting Markdown For simplicity, we use Python-Markdown library instead of MkDocs. from markdown import Markdown converter = Markdown() html = converter.convert(markdown) print(html) [16] 2020-06-19 17:38:10 ( 4.00ms ) python3 ( 470ms ) <p><a href=\"!A\">A</a></p> <!-- mkapi:sep --> <p>Class docstring.</p> <p>!!! note \"Note\" Docstring of <code>__init__()</code> is deleted, if there is a class-level docstring.</p> <!-- mkapi:sep --> <p><a href=\"!__main__.A\"><strong>main</strong>.A</a>.<a href=\"!__main__.A.to_str\">to_str</a></p> <!-- mkapi:sep --> <p>Converts <code>int</code> to <code>str</code>.</p> <!-- mkapi:sep --> <p>Input <strong>value</strong>.</p> Distributing HTML Node.set_html() distributes HTML into docstring and members. node.set_html(html) [17] 2020-06-19 17:38:10 ( 3.00ms ) python3 ( 473ms ) Take a look at what happened. section = node.docstring.sections[0] section.markdown, section.html [18] 2020-06-19 17:38:10 ( 3.00ms ) python3 ( 476ms ) ('Class docstring.\\n\\n!!! note \"Note\"\\n Docstring of `__init__()` is deleted, if there is\\n a class-level docstring.', '<p>Class docstring.</p>\\n<p>!!! note \"Note\"\\n Docstring of <code>__init__()</code> is deleted, if there is\\n a class-level docstring.</p>') child = node.members[0] section = child.docstring.sections[0] section.markdown, section.html [19] 2020-06-19 17:38:10 ( 4.00ms ) python3 ( 480ms ) ('Converts `int` to `str`.', '<p>Converts <code>int</code> to <code>str</code>.</p>') section = child.docstring.sections[1] item = section.items[0] item.description.markdown, item.description.html # A <p> tag is deleted. [20] 2020-06-19 17:38:10 ( 4.00ms ) python3 ( 484ms ) ('Input **value**.', 'Input <strong>value</strong>.') Constructing HTML Finally, construct HTML calling Node.get_html() that internally uses Jinja library. html = node.get_html() print(html[:300].strip()) [21] 2020-06-19 17:38:10 ( 41.0ms ) python3 ( 525ms ) <div class=\"mkapi-node\" id=\"A\"> <div class='mkapi-object-container'> <div class=\"mkapi-object class code top\"> <div class=\"mkapi-object-kind class top\">class</div> <div class=\"mkapi-object-body class top\"><code class=\"mkapi-object-name\">A</code><code class=\"mkapi-object-parenthesis\">(</cod Jupyter allows us to see the rendered HTML. from IPython.display import HTML HTML(html) [22] 2020-06-19 17:38:10 ( 4.00ms ) python3 ( 529ms ) class A ( ) Class docstring. !!! note \"Note\" Docstring of __init__() is deleted, if there is a class-level docstring. method to_str ( x ) \u2192 str Converts int to str . Parameters x (int) \u2014 Input value . Summary All you need to get the documentation of an object is described by the following function. from markdown import Markdown import mkapi def get_html(obj) -> str: # Construct a node tree structure. node = mkapi.get_node(obj) # Create a joint Markdown from components of the node. markdown = node.get_markdown() # Convert it into HTML by any external converter. converter = Markdown() html = converter.convert(markdown) # Split and distribute the HTML into original components. node.set_html(html) # Render the node to create final HTML. return node.get_html() [23] 2020-06-19 17:38:10 ( 3.00ms ) python3 ( 532ms )","title":"Using MkApi within Python"},{"location":"usage/library/#using-mkapi-within-python","text":"MkApi is a standalone library as well as a MkDocs plugin, so that you can use it within Python. First, import MkApi: <!-- .mkapi-node { border: 2px dashed #88AA88; } --> import mkapi [1] 2020-06-19 17:38:10 ( 84.0ms ) python3 ( 239ms )","title":"Using MkApi within Python"},{"location":"usage/library/#node-object","text":"Define a simple class to show how MkApi works. class A: \"\"\"Class docstring. Note: Docstring of `__init__()` is deleted, if there is a class-level docstring. \"\"\" def __init__(self): \"\"\"Init docstring.\"\"\" self.a: int = 1 #: Integer **attribute**. def to_str(self, x: int) -> str: \"\"\"Converts `int` to `str`. Args: x: Input **value**. \"\"\" return str(x) [2] 2020-06-19 17:38:10 ( 4.00ms ) python3 ( 243ms ) mkapi.get_node() generates a Node object that has tree structure. node = mkapi.get_node(A) type(node) [3] 2020-06-19 17:38:10 ( 5.00ms ) python3 ( 248ms ) mkapi.core.node.Node Some attributes: node.object.kind, node.object.name [4] 2020-06-19 17:38:10 ( 3.00ms ) python3 ( 251ms ) ('class', 'A') docstring = node.docstring len(docstring.sections) [5] 2020-06-19 17:38:10 ( 3.00ms ) python3 ( 254ms ) 1 section = docstring.sections[0] section.name, section.markdown [6] 2020-06-19 17:38:10 ( 5.00ms ) python3 ( 259ms ) ('', 'Class docstring.\\n\\n!!! note \"Note\"\\n Docstring of `__init__()` is deleted, if there is\\n a class-level docstring.') section = docstring.sections[1] section.name, section.markdown [7] 2020-06-19 17:38:10 ( 77.0ms ) python3 ( 336ms ) IndexError: list index out of range IndexError Traceback (most recent call last) <ipython-input-41-d901a3af02a6> in <module> ----> 1 section = docstring.sections[1] 2 section.name, section.markdown The members attribute gives children, for example, bound methods of a class. len(node.members) [8] 2020-06-19 17:38:10 ( 105ms ) python3 ( 441ms ) 1 child = node.members[0] type(child) [9] 2020-06-19 17:38:10 ( 3.00ms ) python3 ( 444ms ) mkapi.core.node.Node Elements of Node.members are also Node objects, so this is a tree structure. child.object.kind, child.object.name [10] 2020-06-19 17:38:10 ( 4.00ms ) python3 ( 448ms ) ('method', 'to_str') docstring = child.docstring len(docstring.sections) [11] 2020-06-19 17:38:10 ( 3.00ms ) python3 ( 451ms ) 2 section = docstring.sections[0] section.name, section.markdown [12] 2020-06-19 17:38:10 ( 4.00ms ) python3 ( 455ms ) ('', 'Converts `int` to `str`.') section = docstring.sections[1] section.name, section.markdown [13] 2020-06-19 17:38:10 ( 4.00ms ) python3 ( 459ms ) ('Parameters', '') The above Parameters section has an empty markdown , while its items represents an argument list: item = section.items[0] print(item) print(item.type) print(item.description) [14] 2020-06-19 17:38:10 ( 4.00ms ) python3 ( 463ms ) Item('x', 'int') Type('int') Inline('Input **value**.') Node.get_markdown() creates a joint Markdown of this node. markdown = node.get_markdown() print(markdown) [15] 2020-06-19 17:38:10 ( 3.00ms ) python3 ( 466ms ) A <!-- mkapi:sep --> Class docstring. !!! note \"Note\" Docstring of `__init__()` is deleted, if there is a class-level docstring. <!-- mkapi:sep --> __main__.A.to_str <!-- mkapi:sep --> Converts `int` to `str`. <!-- mkapi:sep --> Input **value**. Where is Note or Parameters section heading, etc. ? No problem. The Node.get_markdown() divides docstrings into two parts. One is a plain Markdown that will be converted into HTML by any Markdown converter, for example, MkDocs. The other is the outline structure of docstrings such as sections or arguments that will be processed by MkApi itself.","title":"Node object"},{"location":"usage/library/#converting-markdown","text":"For simplicity, we use Python-Markdown library instead of MkDocs. from markdown import Markdown converter = Markdown() html = converter.convert(markdown) print(html) [16] 2020-06-19 17:38:10 ( 4.00ms ) python3 ( 470ms ) <p><a href=\"!A\">A</a></p> <!-- mkapi:sep --> <p>Class docstring.</p> <p>!!! note \"Note\" Docstring of <code>__init__()</code> is deleted, if there is a class-level docstring.</p> <!-- mkapi:sep --> <p><a href=\"!__main__.A\"><strong>main</strong>.A</a>.<a href=\"!__main__.A.to_str\">to_str</a></p> <!-- mkapi:sep --> <p>Converts <code>int</code> to <code>str</code>.</p> <!-- mkapi:sep --> <p>Input <strong>value</strong>.</p>","title":"Converting Markdown"},{"location":"usage/library/#distributing-html","text":"Node.set_html() distributes HTML into docstring and members. node.set_html(html) [17] 2020-06-19 17:38:10 ( 3.00ms ) python3 ( 473ms ) Take a look at what happened. section = node.docstring.sections[0] section.markdown, section.html [18] 2020-06-19 17:38:10 ( 3.00ms ) python3 ( 476ms ) ('Class docstring.\\n\\n!!! note \"Note\"\\n Docstring of `__init__()` is deleted, if there is\\n a class-level docstring.', '<p>Class docstring.</p>\\n<p>!!! note \"Note\"\\n Docstring of <code>__init__()</code> is deleted, if there is\\n a class-level docstring.</p>') child = node.members[0] section = child.docstring.sections[0] section.markdown, section.html [19] 2020-06-19 17:38:10 ( 4.00ms ) python3 ( 480ms ) ('Converts `int` to `str`.', '<p>Converts <code>int</code> to <code>str</code>.</p>') section = child.docstring.sections[1] item = section.items[0] item.description.markdown, item.description.html # A <p> tag is deleted. [20] 2020-06-19 17:38:10 ( 4.00ms ) python3 ( 484ms ) ('Input **value**.', 'Input <strong>value</strong>.')","title":"Distributing HTML"},{"location":"usage/library/#constructing-html","text":"Finally, construct HTML calling Node.get_html() that internally uses Jinja library. html = node.get_html() print(html[:300].strip()) [21] 2020-06-19 17:38:10 ( 41.0ms ) python3 ( 525ms ) <div class=\"mkapi-node\" id=\"A\"> <div class='mkapi-object-container'> <div class=\"mkapi-object class code top\"> <div class=\"mkapi-object-kind class top\">class</div> <div class=\"mkapi-object-body class top\"><code class=\"mkapi-object-name\">A</code><code class=\"mkapi-object-parenthesis\">(</cod Jupyter allows us to see the rendered HTML. from IPython.display import HTML HTML(html) [22] 2020-06-19 17:38:10 ( 4.00ms ) python3 ( 529ms ) class A ( ) Class docstring. !!! note \"Note\" Docstring of __init__() is deleted, if there is a class-level docstring. method to_str ( x ) \u2192 str Converts int to str . Parameters x (int) \u2014 Input value .","title":"Constructing HTML"},{"location":"usage/library/#summary","text":"All you need to get the documentation of an object is described by the following function. from markdown import Markdown import mkapi def get_html(obj) -> str: # Construct a node tree structure. node = mkapi.get_node(obj) # Create a joint Markdown from components of the node. markdown = node.get_markdown() # Convert it into HTML by any external converter. converter = Markdown() html = converter.convert(markdown) # Split and distribute the HTML into original components. node.set_html(html) # Render the node to create final HTML. return node.get_html() [23] 2020-06-19 17:38:10 ( 3.00ms ) python3 ( 532ms )","title":"Summary"},{"location":"usage/module/","text":"Module and Package <!-- .mkapi-node { border: 2px dashed #88AA88; } --> MkApi can create module and package documentation as well as function and class. Specify a package or module by its full path name. ![mkapi](mkapi.core) package mkapi . core Package level documentation is written in __init__.py . Module Level Components As class level attributes, module level attributes can be inspected. Here is the beginning part of google_style.py . File 1 google_style.py: line number 1-18 \"\"\"Module level docstring.\"\"\" from dataclasses import dataclass, field from typing import Dict, Iterator, List, Tuple #: The first module level attribute. Comment *before* attribute. first_attribute: int = 1 second_attribute = \"abc\" #: str: The second module level attribute. *Inline* style. third_attribute: List[int] = [1, 2, 3] \"\"\"The third module level attribute. Docstring *after* attribute. Multiple paragraphs are supported. \"\"\" not_attribute = 123 # Not attribute description because ':' is missing. def add(x: int, y: int = 1) -> int: \"\"\"Returns $x + y$. Although there is no Attributes section in docstring, MkApi automatically creates the section if attributes are correctly documented. ![mkapi](google_style) module google_style Module level docstring. Attributes first_attribute (int) \u2014 The first module level attribute. Comment before attribute. second_attribute (str) \u2014 The second module level attribute. Inline style. third_attribute (list of int) \u2014 The third module level attribute. Docstring after attribute. Multiple paragraphs are supported. Classes ExampleClass \u2014 A normal class. ExampleDataClass \u2014 A dataclass. Functions add ( x , y ) (int) \u2014 Returns x + y x + y . gen ( n ) (str) \u2014 Yields a numbered string. Furthermore, Classes and Functions sections are also created that display a list of members defined in the module and their short descriptions. The prefix [D] means dataclass and [G] means generator. Documentation with Heading The other method to create module documentation is heading. For example, ### ![mkapi](google_style) create a <h3> tag for the google_style module. module google_style Module level docstring. Attributes first_attribute (int) \u2014 The first module level attribute. Comment before attribute. second_attribute (str) \u2014 The second module level attribute. Inline style. third_attribute (list of int) \u2014 The third module level attribute. Docstring after attribute. Multiple paragraphs are supported. Classes ExampleClass \u2014 A normal class. ExampleDataClass \u2014 A dataclass. Functions add ( x , y ) (int) \u2014 Returns x + y x + y . gen ( n ) (str) \u2014 Yields a numbered string. If you prefer upper case heading, use the upper filter. ### ![mkapi](google_style|upper) MODULE GOOGLE_STYLE Module level docstring. Attributes first_attribute (int) \u2014 The first module level attribute. Comment before attribute. second_attribute (str) \u2014 The second module level attribute. Inline style. third_attribute (list of int) \u2014 The third module level attribute. Docstring after attribute. Multiple paragraphs are supported. Classes ExampleClass \u2014 A normal class. ExampleDataClass \u2014 A dataclass. Functions add ( x , y ) (int) \u2014 Returns x + y x + y . gen ( n ) (str) \u2014 Yields a numbered string. Display Members all filter generates entire module documentation including class and function members. Note that Classes and Functions sections have links to the members ### ![mkapi](google_style|upper|all) MODULE GOOGLE_STYLE Module level docstring. Attributes first_attribute (int) \u2014 The first module level attribute. Comment before attribute. second_attribute (str) \u2014 The second module level attribute. Inline style. third_attribute (list of int) \u2014 The third module level attribute. Docstring after attribute. Multiple paragraphs are supported. Classes ExampleClass \u2014 A normal class. ExampleDataClass \u2014 A dataclass. Functions add ( x , y ) (int) \u2014 Returns x + y x + y . gen ( n ) (str) \u2014 Yields a numbered string. function google_style. add ( x , y=1 ) Returns x + y x + y . Parameters x (int) \u2014 The first parameter. y (int, optional) \u2014 The second parameter. Default=1. Returns (int) Added value. Examples Examples should be written in doctest format. >>> add(1, 2) 3 Note You can use the Admonition extension of MkDocs . Note Note section is converted into the Admonition. generator google_style. gen ( n ) Yields a numbered string. Parameters n (int) \u2014 The length of iteration. Yields (str) A numbered string. class google_style. ExampleClass ( x , y ) A normal class. Parameters x (list of int) \u2014 The first parameter. y (str, int) \u2014 The second parameter. Attributes a (str) \u2014 The first attribute. Comment inline with attribute. b (dict(str: int)) \u2014 The second attribute. Comment before attribute. c (int, optional) \u2014 The third attribute. Docstring after attribute. Multiple paragraphs are supported. readonly_property (str) \u2014 Read-only property documentation. readwrite_property (list of int) \u2014 Read-write property documentation. Raises ValueError \u2014 If the length of x is equal to 0. Methods message ( n ) (list of str) \u2014 Returns a message list. method message ( n ) \u2192 list of str Returns a message list. Parameters n (int) \u2014 Repeatation. dataclass google_style. ExampleDataClass ( x=0 ) A dataclass. Parameters x (int, optional) \u2014 The first parameter. Attributes x (int) \u2014 The first attribute. y (int) \u2014 The second attribute.","title":"Module and Package"},{"location":"usage/module/#module-and-package","text":"<!-- .mkapi-node { border: 2px dashed #88AA88; } --> MkApi can create module and package documentation as well as function and class. Specify a package or module by its full path name. ![mkapi](mkapi.core) package mkapi . core Package level documentation is written in __init__.py .","title":"Module and Package"},{"location":"usage/module/#module-level-components","text":"As class level attributes, module level attributes can be inspected. Here is the beginning part of google_style.py . File 1 google_style.py: line number 1-18 \"\"\"Module level docstring.\"\"\" from dataclasses import dataclass, field from typing import Dict, Iterator, List, Tuple #: The first module level attribute. Comment *before* attribute. first_attribute: int = 1 second_attribute = \"abc\" #: str: The second module level attribute. *Inline* style. third_attribute: List[int] = [1, 2, 3] \"\"\"The third module level attribute. Docstring *after* attribute. Multiple paragraphs are supported. \"\"\" not_attribute = 123 # Not attribute description because ':' is missing. def add(x: int, y: int = 1) -> int: \"\"\"Returns $x + y$. Although there is no Attributes section in docstring, MkApi automatically creates the section if attributes are correctly documented. ![mkapi](google_style) module google_style Module level docstring. Attributes first_attribute (int) \u2014 The first module level attribute. Comment before attribute. second_attribute (str) \u2014 The second module level attribute. Inline style. third_attribute (list of int) \u2014 The third module level attribute. Docstring after attribute. Multiple paragraphs are supported. Classes ExampleClass \u2014 A normal class. ExampleDataClass \u2014 A dataclass. Functions add ( x , y ) (int) \u2014 Returns x + y x + y . gen ( n ) (str) \u2014 Yields a numbered string. Furthermore, Classes and Functions sections are also created that display a list of members defined in the module and their short descriptions. The prefix [D] means dataclass and [G] means generator.","title":"Module Level Components"},{"location":"usage/module/#documentation-with-heading","text":"The other method to create module documentation is heading. For example, ### ![mkapi](google_style) create a <h3> tag for the google_style module. module","title":"Documentation with Heading"},{"location":"usage/module/#google_style","text":"Module level docstring. Attributes first_attribute (int) \u2014 The first module level attribute. Comment before attribute. second_attribute (str) \u2014 The second module level attribute. Inline style. third_attribute (list of int) \u2014 The third module level attribute. Docstring after attribute. Multiple paragraphs are supported. Classes ExampleClass \u2014 A normal class. ExampleDataClass \u2014 A dataclass. Functions add ( x , y ) (int) \u2014 Returns x + y x + y . gen ( n ) (str) \u2014 Yields a numbered string. If you prefer upper case heading, use the upper filter. ### ![mkapi](google_style|upper) MODULE","title":"google_style"},{"location":"usage/module/#google_style_1","text":"Module level docstring. Attributes first_attribute (int) \u2014 The first module level attribute. Comment before attribute. second_attribute (str) \u2014 The second module level attribute. Inline style. third_attribute (list of int) \u2014 The third module level attribute. Docstring after attribute. Multiple paragraphs are supported. Classes ExampleClass \u2014 A normal class. ExampleDataClass \u2014 A dataclass. Functions add ( x , y ) (int) \u2014 Returns x + y x + y . gen ( n ) (str) \u2014 Yields a numbered string.","title":"google_style"},{"location":"usage/module/#display-members","text":"all filter generates entire module documentation including class and function members. Note that Classes and Functions sections have links to the members ### ![mkapi](google_style|upper|all) MODULE","title":"Display Members"},{"location":"usage/module/#google_style_2","text":"Module level docstring. Attributes first_attribute (int) \u2014 The first module level attribute. Comment before attribute. second_attribute (str) \u2014 The second module level attribute. Inline style. third_attribute (list of int) \u2014 The third module level attribute. Docstring after attribute. Multiple paragraphs are supported. Classes ExampleClass \u2014 A normal class. ExampleDataClass \u2014 A dataclass. Functions add ( x , y ) (int) \u2014 Returns x + y x + y . gen ( n ) (str) \u2014 Yields a numbered string. function","title":"google_style"},{"location":"usage/module/#google_styleadd","text":"Returns x + y x + y . Parameters x (int) \u2014 The first parameter. y (int, optional) \u2014 The second parameter. Default=1. Returns (int) Added value. Examples Examples should be written in doctest format. >>> add(1, 2) 3 Note You can use the Admonition extension of MkDocs . Note Note section is converted into the Admonition. generator","title":"google_style.add"},{"location":"usage/module/#google_stylegen","text":"Yields a numbered string. Parameters n (int) \u2014 The length of iteration. Yields (str) A numbered string. class","title":"google_style.gen"},{"location":"usage/module/#google_styleexampleclass","text":"A normal class. Parameters x (list of int) \u2014 The first parameter. y (str, int) \u2014 The second parameter. Attributes a (str) \u2014 The first attribute. Comment inline with attribute. b (dict(str: int)) \u2014 The second attribute. Comment before attribute. c (int, optional) \u2014 The third attribute. Docstring after attribute. Multiple paragraphs are supported. readonly_property (str) \u2014 Read-only property documentation. readwrite_property (list of int) \u2014 Read-write property documentation. Raises ValueError \u2014 If the length of x is equal to 0. Methods message ( n ) (list of str) \u2014 Returns a message list. method message ( n ) \u2192 list of str Returns a message list. Parameters n (int) \u2014 Repeatation. dataclass","title":"google_style.ExampleClass"},{"location":"usage/module/#google_styleexampledataclass","text":"A dataclass. Parameters x (int, optional) \u2014 The first parameter. Attributes x (int) \u2014 The first attribute. y (int) \u2014 The second attribute.","title":"google_style.ExampleDataClass"},{"location":"usage/page/","text":"Page Mode and Internal Links <!-- .mkapi-node { border: 2px dashed #88AA88; } --> Page Mode Page mode is a powerful feature that constructs a comprehensive API documentation for your project. To use the page mode, just add one line to mkdocs.yml : nav: - index.md - API: mkapi/api/mkapi MkApi scans the nav to find an entry that starts with 'mkapi/' . This entry must include two or more slashes ( '/' ). Second part ( 'api' ) splitted by slash is a directory name. MkApi automatically creates this directory in the docs directory at the beginning of the process and deletes it and its contents after the process. The rest ( 'mkapi' ) is a root package name, which is assumed to exist in the mkdocs.yml directory. However, if a root package is in src directory, for example, you can specify it like this: - API: mkapi/api/src/mkapi MkApi searches all packages and modules and create a Markdown source for one package or module, which is saved in the api directory. The rest work is done by MkDocs. You can see the documentation of MkApi in the left navigation menu. Note If a package or module has no package- or module-level docstring, MkApi doesn't process it. For upper case heading, use the upper filter. See Documentation with Heading . Internal Links Link from Markdown Once a project documentation is generated, you can use hyperlink to it using normal Markdown syntax. Go to [Section](mkapi.core.base.Section). The above line create a link to mkapi.core.base.Section object: Go to Section . Link from Docstring You can use this feature even in your docstring. For example, assume that func() is defined in a link.fullname module: File 4 link/fullname.py def func(): \"\"\"Internal link example. See Also: [a method](mkapi.core.base.Item.set_html) \"\"\" The link.fullname.func() is rendered as: function link.fullname. func ( ) Internal link example. See Also a method You can click the above \"a method\" to visit its documentation. Furthermore, if your module imports an object, you can refer it by its qualified name only. File 5 link/qualname.py from mkapi.core.base import Section from mkapi.core.docstring import get_docstring def func(): \"\"\"Internal link example. * [Section]() --- Imported object. * [](get_docstring) --- Imported object. * [Section.set_html]() --- Member of imported object. * [Section definition](Section) --- Alternative text. * Section_ --- reStructuredText style. \"\"\" return Section(), get_docstring(None) The link.qualname.func() is rendered as: function link.qualname. func ( ) Internal link example. Section --- Imported object. get_docstring --- Imported object. Section.set_html --- Member of imported object. Section definition --- Alternative text. Section --- reStructuredText style. Link from Embedding Mode Documentation created by the embedding mode has link to its project documentation. ![mkapi](mkapi.core.docstring.section_heading) creates the documentation of the section_heading() : function mkapi.core.docstring . section_heading ( line ) \u2192 (str, str) Returns a tuple of (section name, style name). Parameters line (str) \u2014 Docstring line. Examples >>> section_heading(\"Args:\") ('Args', 'google') >>> section_heading(\"Raises\") ('Raises', 'numpy') >>> section_heading(\"other\") ('', '') You can click the prefix ( mkapi.core.docstring ) or the function name ( section_heading ) to go to the project documentation. Link from Type Docstring class of MkApi has an attribute sections that is a list of Section class instance: # Mimic code of Docstring class. from dataclasses import dataclass from typing import List from mkapi.core.base import Section @dataclass class Docstring: \"\"\"Docstring ....\"\"\" sections: List[Section] = field(default_factory=list) type: str = \"\" Corresponding real documentation is displayed as below. Note that Section and Type are bold, which indicates that it is a link. Let's click. This link system using type annotation is useful to navigate users throughout the project documentation. dataclass mkapi.core.base . Docstring ( sections=<factory> , type=<factory> ) Docstring class represents a docstring of an object. Parameters sections (list of Section , optional) \u2014 List of Section instance. type ( Type , optional) \u2014 Type for Returns or Yields sections. Attributes sections (list of Section ) \u2014 List of Section instance. type ( Type ) \u2014 Type for Returns or Yields sections. Examples Empty docstring: >>> docstring = Docstring() >>> assert not docstring Docstring with 3 sections: >>> default = Section(\"\", markdown=\"Default\") >>> parameters = Section(\"Parameters\", items=[Item(\"a\"), Item(\"[b](!a)\")]) >>> returns = Section(\"Returns\", markdown=\"Results\") >>> docstring = Docstring([default, parameters, returns]) >>> docstring Docstring(num_sections=3) Docstring is iterable: >>> list(docstring) [Section('', num_items=0), Item('[b](!a)', ''), Section('Returns', num_items=0)] Indexing: >>> docstring[\"Parameters\"].items[0].name 'a' Section ordering: >>> docstring = Docstring() >>> _ = docstring[''] >>> _ = docstring['Todo'] >>> _ = docstring['Attributes'] >>> _ = docstring['Parameters'] >>> [section.name for section in docstring.sections] ['', 'Parameters', 'Attributes', 'Todo'] Methods __bool__ ( ) \u2014 Returns True if the number of sections is larger than 0. __contains__ ( name ) (bool) \u2014 Returns True if there is a Section instance whose name is equal to name . __getitem__ ( name ) ( Section ) \u2014 Returns a Section instance whose name is equal to name . __iter__ ( ) ( Base ) \u2014 Yields Base instance. set_section ( section , force , copy , replace ) \u2014 Sets a Section . method __bool__ ( ) Returns True if the number of sections is larger than 0. generator __iter__ ( ) \u2192 Base Yields Base instance. method __getitem__ ( name ) \u2192 Section Returns a Section instance whose name is equal to name . If there is no Section instance, a Section instance is newly created. Parameters name (str) \u2014 Section name. method __contains__ ( name ) \u2192 bool Returns True if there is a Section instance whose name is equal to name . Parameters name \u2014 Section name. method set_section ( section , force=False , copy=False , replace=False ) Sets a Section . Parameters section ( Section ) \u2014 Section instance. force (bool, optional) \u2014 If True, overwrite self regardless of existing seciton. Examples >>> items = [Item('x', 'int'), Item('y', 'str', 'y')] >>> s1 = Section('Attributes', items=items) >>> items = [Item('x', 'str', 'X'), Item('z', 'str', 'z')] >>> s2 = Section('Attributes', items=items) >>> doc = Docstring([s1]) >>> doc.set_section(s2) >>> doc['Attributes']['x'].to_tuple() ('x', 'int', 'X') >>> doc['Attributes']['z'].to_tuple() ('z', 'str', 'z') >>> doc.set_section(s2, force=True) >>> doc['Attributes']['x'].to_tuple() ('x', 'str', 'X') >>> items = [Item('x', 'X', 'str'), Item('z', 'z', 'str')] >>> s3 = Section('Parameters', items=items) >>> doc.set_section(s3) >>> doc.sections [Section('Parameters', num_items=2), Section('Attributes', num_items=3)]","title":"Page Mode and Internal Links"},{"location":"usage/page/#page-mode-and-internal-links","text":"<!-- .mkapi-node { border: 2px dashed #88AA88; } -->","title":"Page Mode and Internal Links"},{"location":"usage/page/#page-mode","text":"Page mode is a powerful feature that constructs a comprehensive API documentation for your project. To use the page mode, just add one line to mkdocs.yml : nav: - index.md - API: mkapi/api/mkapi MkApi scans the nav to find an entry that starts with 'mkapi/' . This entry must include two or more slashes ( '/' ). Second part ( 'api' ) splitted by slash is a directory name. MkApi automatically creates this directory in the docs directory at the beginning of the process and deletes it and its contents after the process. The rest ( 'mkapi' ) is a root package name, which is assumed to exist in the mkdocs.yml directory. However, if a root package is in src directory, for example, you can specify it like this: - API: mkapi/api/src/mkapi MkApi searches all packages and modules and create a Markdown source for one package or module, which is saved in the api directory. The rest work is done by MkDocs. You can see the documentation of MkApi in the left navigation menu. Note If a package or module has no package- or module-level docstring, MkApi doesn't process it. For upper case heading, use the upper filter. See Documentation with Heading .","title":"Page Mode"},{"location":"usage/page/#internal-links","text":"","title":"Internal Links"},{"location":"usage/page/#link-from-markdown","text":"Once a project documentation is generated, you can use hyperlink to it using normal Markdown syntax. Go to [Section](mkapi.core.base.Section). The above line create a link to mkapi.core.base.Section object: Go to Section .","title":"Link from Markdown"},{"location":"usage/page/#link-from-docstring","text":"You can use this feature even in your docstring. For example, assume that func() is defined in a link.fullname module: File 4 link/fullname.py def func(): \"\"\"Internal link example. See Also: [a method](mkapi.core.base.Item.set_html) \"\"\" The link.fullname.func() is rendered as: function link.fullname. func ( ) Internal link example. See Also a method You can click the above \"a method\" to visit its documentation. Furthermore, if your module imports an object, you can refer it by its qualified name only. File 5 link/qualname.py from mkapi.core.base import Section from mkapi.core.docstring import get_docstring def func(): \"\"\"Internal link example. * [Section]() --- Imported object. * [](get_docstring) --- Imported object. * [Section.set_html]() --- Member of imported object. * [Section definition](Section) --- Alternative text. * Section_ --- reStructuredText style. \"\"\" return Section(), get_docstring(None) The link.qualname.func() is rendered as: function link.qualname. func ( ) Internal link example. Section --- Imported object. get_docstring --- Imported object. Section.set_html --- Member of imported object. Section definition --- Alternative text. Section --- reStructuredText style.","title":"Link from Docstring"},{"location":"usage/page/#link-from-embedding-mode","text":"Documentation created by the embedding mode has link to its project documentation. ![mkapi](mkapi.core.docstring.section_heading) creates the documentation of the section_heading() : function mkapi.core.docstring . section_heading ( line ) \u2192 (str, str) Returns a tuple of (section name, style name). Parameters line (str) \u2014 Docstring line. Examples >>> section_heading(\"Args:\") ('Args', 'google') >>> section_heading(\"Raises\") ('Raises', 'numpy') >>> section_heading(\"other\") ('', '') You can click the prefix ( mkapi.core.docstring ) or the function name ( section_heading ) to go to the project documentation.","title":"Link from Embedding Mode"},{"location":"usage/page/#link-from-type","text":"Docstring class of MkApi has an attribute sections that is a list of Section class instance: # Mimic code of Docstring class. from dataclasses import dataclass from typing import List from mkapi.core.base import Section @dataclass class Docstring: \"\"\"Docstring ....\"\"\" sections: List[Section] = field(default_factory=list) type: str = \"\" Corresponding real documentation is displayed as below. Note that Section and Type are bold, which indicates that it is a link. Let's click. This link system using type annotation is useful to navigate users throughout the project documentation. dataclass mkapi.core.base . Docstring ( sections=<factory> , type=<factory> ) Docstring class represents a docstring of an object. Parameters sections (list of Section , optional) \u2014 List of Section instance. type ( Type , optional) \u2014 Type for Returns or Yields sections. Attributes sections (list of Section ) \u2014 List of Section instance. type ( Type ) \u2014 Type for Returns or Yields sections. Examples Empty docstring: >>> docstring = Docstring() >>> assert not docstring Docstring with 3 sections: >>> default = Section(\"\", markdown=\"Default\") >>> parameters = Section(\"Parameters\", items=[Item(\"a\"), Item(\"[b](!a)\")]) >>> returns = Section(\"Returns\", markdown=\"Results\") >>> docstring = Docstring([default, parameters, returns]) >>> docstring Docstring(num_sections=3) Docstring is iterable: >>> list(docstring) [Section('', num_items=0), Item('[b](!a)', ''), Section('Returns', num_items=0)] Indexing: >>> docstring[\"Parameters\"].items[0].name 'a' Section ordering: >>> docstring = Docstring() >>> _ = docstring[''] >>> _ = docstring['Todo'] >>> _ = docstring['Attributes'] >>> _ = docstring['Parameters'] >>> [section.name for section in docstring.sections] ['', 'Parameters', 'Attributes', 'Todo'] Methods __bool__ ( ) \u2014 Returns True if the number of sections is larger than 0. __contains__ ( name ) (bool) \u2014 Returns True if there is a Section instance whose name is equal to name . __getitem__ ( name ) ( Section ) \u2014 Returns a Section instance whose name is equal to name . __iter__ ( ) ( Base ) \u2014 Yields Base instance. set_section ( section , force , copy , replace ) \u2014 Sets a Section . method __bool__ ( ) Returns True if the number of sections is larger than 0. generator __iter__ ( ) \u2192 Base Yields Base instance. method __getitem__ ( name ) \u2192 Section Returns a Section instance whose name is equal to name . If there is no Section instance, a Section instance is newly created. Parameters name (str) \u2014 Section name. method __contains__ ( name ) \u2192 bool Returns True if there is a Section instance whose name is equal to name . Parameters name \u2014 Section name. method set_section ( section , force=False , copy=False , replace=False ) Sets a Section . Parameters section ( Section ) \u2014 Section instance. force (bool, optional) \u2014 If True, overwrite self regardless of existing seciton. Examples >>> items = [Item('x', 'int'), Item('y', 'str', 'y')] >>> s1 = Section('Attributes', items=items) >>> items = [Item('x', 'str', 'X'), Item('z', 'str', 'z')] >>> s2 = Section('Attributes', items=items) >>> doc = Docstring([s1]) >>> doc.set_section(s2) >>> doc['Attributes']['x'].to_tuple() ('x', 'int', 'X') >>> doc['Attributes']['z'].to_tuple() ('z', 'str', 'z') >>> doc.set_section(s2, force=True) >>> doc['Attributes']['x'].to_tuple() ('x', 'str', 'X') >>> items = [Item('x', 'X', 'str'), Item('z', 'z', 'str')] >>> s3 = Section('Parameters', items=items) >>> doc.set_section(s3) >>> doc.sections [Section('Parameters', num_items=2), Section('Attributes', num_items=3)]","title":"Link from Type"}]}