{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MkApi Documentation The MkApi plugin for MkDocs generates API documentation for Python code. The MkApi plugin supports the Google Python Style Guide only and partially. Features of the MkApi plugin are: Section syntax of the Goole style guide. Supported sections are Args , Arguments , Attributes , Example[s] , Note[s] , Raises , Returns , References , Todo , Warning[s] , Warns , and Yields . Type annotation. If you write your function such as def func(x: int) -> str: , you don't need write type(s) in Args , Returns , or Yields section again. You can overwrite the type annotation in the corresponding docstring. Object type inspection. The MkApi plugin creates CLASS , DATACLASS , FUNCTION , GENERATOR , METHOD , or PROPERTY prefix for each object. Installation Install the plugin using pip: pip install mkapi Configuration Add the following lines to mkdocs.yml : plugins: - search # necessary for search to work - mkapi Usage To generate the API documentation, add an exclamation mark (!), followed by mkapi in brackets, and the object qualname in parentheses. Yes, this is like adding an image. The object can be a package, module, function, class, etc . ![mkapi](<object.qualname>) The MkApi plugin imports objects that you specify. If they aren't in the sys.path , configure mkdocs.yml like below: plugins: - search - mkapi: src_dirs: [<path_1>, <path_2>, ...] Here, path_X s are inserted to sys.path . These path_X s are relative paths to the directory in which mkdocs.yml exists.","title":"MkApi"},{"location":"#mkapi-documentation","text":"The MkApi plugin for MkDocs generates API documentation for Python code. The MkApi plugin supports the Google Python Style Guide only and partially. Features of the MkApi plugin are: Section syntax of the Goole style guide. Supported sections are Args , Arguments , Attributes , Example[s] , Note[s] , Raises , Returns , References , Todo , Warning[s] , Warns , and Yields . Type annotation. If you write your function such as def func(x: int) -> str: , you don't need write type(s) in Args , Returns , or Yields section again. You can overwrite the type annotation in the corresponding docstring. Object type inspection. The MkApi plugin creates CLASS , DATACLASS , FUNCTION , GENERATOR , METHOD , or PROPERTY prefix for each object.","title":"MkApi Documentation"},{"location":"#installation","text":"Install the plugin using pip: pip install mkapi","title":"Installation"},{"location":"#configuration","text":"Add the following lines to mkdocs.yml : plugins: - search # necessary for search to work - mkapi","title":"Configuration"},{"location":"#usage","text":"To generate the API documentation, add an exclamation mark (!), followed by mkapi in brackets, and the object qualname in parentheses. Yes, this is like adding an image. The object can be a package, module, function, class, etc . ![mkapi](<object.qualname>) The MkApi plugin imports objects that you specify. If they aren't in the sys.path , configure mkdocs.yml like below: plugins: - search - mkapi: src_dirs: [<path_1>, <path_2>, ...] Here, path_X s are inserted to sys.path . These path_X s are relative paths to the directory in which mkdocs.yml exists.","title":"Usage"},{"location":"examples/","text":"Examples Let's start realistic examples. Here, a sample Python file example.py is stored under the examples directory relative to the mkdocs.yml directory, so you should configure mkdocs.yml like below. In addition, we add two extensions and an extra javascript for demonstration. plugins: - search - mkapi: src_dirs: [examples] markdown_extensions: - admonition - pymdownx.arithmatex extra_javascript: # for pymdownx.arithmatex - https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML Function The example module defines a simple function add() . Code 1 example.add() def add(x: int, y: int = 1) -> int: \"\"\"Returns $x + y$. Args: x: The first parameter. y: The second parameter. Default={default}. Returns: Added value. Examples: >>> add(1, 2) 3 !!! note You can use the [admonition extension of MkDocs](https://squidfunk.github.io/mkdocs-material/extensions/admonition/). Note: But you should use `Note` section instead for consistency. \"\"\" return x + y Then, you can write an entry to generate API for the function anywhere in your Markdown source: ![mkapi][example.add] MkApi generates the API documentation for the add() function. FUNCTION example.add (x, y=1) Returns x + y x + y . Parameters x (int) \u2014 The first parameter. y (int, optional) \u2014 The second parameter. Default=1. Returns (int) Added value. Examples >>> add(1, 2) 3 Note You can use the admonition extension of MkDocs . Note But you should use Note section instead for consistency. Note In the above example, green dashed border lines are just guide for the eye to show the region of the documentation generated by MkApi for convenience. In this simple example, you can see some features of MkApi. Type inspection of add (FUNCTION prefix is added before example.add ). Use of type annotation for both Parameters and Returns sections. Add optional if parameters have default values. Default value replacement by the {default} keyword in the Args section. External hyperlink. Use of MkDocs extensions: MathJax rendering and admonition. Generator The example module also defines a simple generator gen() . Code 2 example.gen() def gen(n) -> Iterator[str]: \"\"\"Yields a numbered string. Args: n (int): The length of iteration. Yields: A numbered string. \"\"\" for x in range(n): yield f\"a{x}\" Then, ![mkapi][example.gen] creates the API documentation for the gen() generator. GENERATOR example.gen (n) Yields a numbered string. Parameters n (int) \u2014 The length of iteration. Yields (str) A numbered string. In this simple example, notice that: A GENERATOR prefix instead of a FUNCTION prefix. The parameter n has no type annotation but you can specify it in the Args section directly. Yields type is not iterator of str but str , because gen() is a generator. Class The example module also defines a simple class ExampleClass . Code 3 example.ExampleClass class ExampleClass: def __init__(self, x: List[int], y: Tuple[str, int]): \"\"\"A normal class. Args: x: The first parameter. y: The second parameter. Attributes: z (str): The first attribute. Raises: ValueError: If the length of `x` is equal to 0. \"\"\" if len(x) == 0: raise ValueError() self.z = \"abc\" def message(self, n: int) -> List[str]: \"\"\"Returns a message list. Args: n: Repeatation. \"\"\" return [self.z] * n @property def readonly_property(self): \"\"\"str: Read-only property documentation.\"\"\" return \"readonly_property\" @property def readwrite_property(self) -> List[int]: \"\"\"Read-write property documentation.\"\"\" return [1, 2, 3] @readwrite_property.setter def readwrite_property(self, value): \"\"\"Docstring in setter is ignored.\"\"\" As usual, ![mkapi][example.ExampleClass] creates the API documentation for the ExampleClass class. CLASS example.ExampleClass (x, y) A normal class. Parameters x (list of int) \u2014 The first parameter. y (str, int) \u2014 The second parameter. Attributes z (str) \u2014 The first attribute. Raises ValueError \u2014 If the length of x is equal to 0. METHOD message (n) \u2192 list of str Returns a message list. Parameters n (int) \u2014 Repeatation. READONLY_PROPERTY readonly_property \u2192 str Read-only property documentation. READWRITE_PROPERTY readwrite_property \u2192 list of int Read-write property documentation. In this example, notice that: Docstring of __init__ function is treated as a class-level docstring. Type annotation using typing package ( List and Tuple in this case) is converted into readable style. So far, only List and Tuple are supported. Bound methods ( message in this case) have a METHOD prefix instead of a FUNCTION prefix. If callable objects have neither Returns nor Yields , the type appears on the object definition line like type annotation. For properties, the type can be written at the beginning of the docstring or type annotation as well as functions. Whether a property is read-only or read-write is inspected. Data Class The example module also defines a simple data class ExampleDataClass . Code 4 example.ExampleDataClass @dataclass class ExampleDataClass: \"\"\"A dataclass. Args: x: The first parameter. Attributes: x: The first attribute. y: The second attribute. \"\"\" x: int = 0 y: int = field(default=1, init=False) Then, ![mkapi][example.ExampleDataClass] creates the API documentation for the ExampleDataClass class. DATACLASS example.ExampleDataClass (x=0) A dataclass. Parameters x (int, optional) \u2014 The first parameter. Attributes x (int) \u2014 The first attribute. y (int) \u2014 The second attribute. In this example, notice that: A DATACLASS prefix instead of a CLASS prefix. Attributes type inspection as well as parameters if they are data class fields. Module Finally, let's generate the API documentation for the example module. The module has a module level docstring like below: File 1 example.py (line 1~10) \"\"\"Module level docstring.\"\"\" from dataclasses import dataclass, field from typing import Iterator, List, Tuple def add(x: int, y: int = 1) -> int: \"\"\"Returns $x + y$. Args: x: The first parameter. Then, ![mkapi][example] creates the API documentation for the entire example module. MODULE example Module level docstring. FUNCTION example. add (x, y=1) Returns x + y x + y . Parameters x (int) \u2014 The first parameter. y (int, optional) \u2014 The second parameter. Default=1. Returns (int) Added value. Examples >>> add(1, 2) 3 Note You can use the admonition extension of MkDocs . Note But you should use Note section instead for consistency. GENERATOR example. gen (n) Yields a numbered string. Parameters n (int) \u2014 The length of iteration. Yields (str) A numbered string. CLASS example. ExampleClass (x, y) A normal class. Parameters x (list of int) \u2014 The first parameter. y (str, int) \u2014 The second parameter. Attributes z (str) \u2014 The first attribute. Raises ValueError \u2014 If the length of x is equal to 0. METHOD message (n) \u2192 list of str Returns a message list. Parameters n (int) \u2014 Repeatation. READONLY_PROPERTY readonly_property \u2192 str Read-only property documentation. READWRITE_PROPERTY readwrite_property \u2192 list of int Read-write property documentation. DATACLASS example. ExampleDataClass (x=0) A dataclass. Parameters x (int, optional) \u2014 The first parameter. Attributes x (int) \u2014 The first attribute. y (int) \u2014 The second attribute.","title":"Examples"},{"location":"examples/#examples","text":"Let's start realistic examples. Here, a sample Python file example.py is stored under the examples directory relative to the mkdocs.yml directory, so you should configure mkdocs.yml like below. In addition, we add two extensions and an extra javascript for demonstration. plugins: - search - mkapi: src_dirs: [examples] markdown_extensions: - admonition - pymdownx.arithmatex extra_javascript: # for pymdownx.arithmatex - https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML","title":"Examples"},{"location":"examples/#function","text":"The example module defines a simple function add() . Code 1 example.add() def add(x: int, y: int = 1) -> int: \"\"\"Returns $x + y$. Args: x: The first parameter. y: The second parameter. Default={default}. Returns: Added value. Examples: >>> add(1, 2) 3 !!! note You can use the [admonition extension of MkDocs](https://squidfunk.github.io/mkdocs-material/extensions/admonition/). Note: But you should use `Note` section instead for consistency. \"\"\" return x + y Then, you can write an entry to generate API for the function anywhere in your Markdown source: ![mkapi][example.add] MkApi generates the API documentation for the add() function. FUNCTION example.add (x, y=1) Returns x + y x + y . Parameters x (int) \u2014 The first parameter. y (int, optional) \u2014 The second parameter. Default=1. Returns (int) Added value. Examples >>> add(1, 2) 3 Note You can use the admonition extension of MkDocs . Note But you should use Note section instead for consistency. Note In the above example, green dashed border lines are just guide for the eye to show the region of the documentation generated by MkApi for convenience. In this simple example, you can see some features of MkApi. Type inspection of add (FUNCTION prefix is added before example.add ). Use of type annotation for both Parameters and Returns sections. Add optional if parameters have default values. Default value replacement by the {default} keyword in the Args section. External hyperlink. Use of MkDocs extensions: MathJax rendering and admonition.","title":"Function"},{"location":"examples/#generator","text":"The example module also defines a simple generator gen() . Code 2 example.gen() def gen(n) -> Iterator[str]: \"\"\"Yields a numbered string. Args: n (int): The length of iteration. Yields: A numbered string. \"\"\" for x in range(n): yield f\"a{x}\" Then, ![mkapi][example.gen] creates the API documentation for the gen() generator. GENERATOR example.gen (n) Yields a numbered string. Parameters n (int) \u2014 The length of iteration. Yields (str) A numbered string. In this simple example, notice that: A GENERATOR prefix instead of a FUNCTION prefix. The parameter n has no type annotation but you can specify it in the Args section directly. Yields type is not iterator of str but str , because gen() is a generator.","title":"Generator"},{"location":"examples/#class","text":"The example module also defines a simple class ExampleClass . Code 3 example.ExampleClass class ExampleClass: def __init__(self, x: List[int], y: Tuple[str, int]): \"\"\"A normal class. Args: x: The first parameter. y: The second parameter. Attributes: z (str): The first attribute. Raises: ValueError: If the length of `x` is equal to 0. \"\"\" if len(x) == 0: raise ValueError() self.z = \"abc\" def message(self, n: int) -> List[str]: \"\"\"Returns a message list. Args: n: Repeatation. \"\"\" return [self.z] * n @property def readonly_property(self): \"\"\"str: Read-only property documentation.\"\"\" return \"readonly_property\" @property def readwrite_property(self) -> List[int]: \"\"\"Read-write property documentation.\"\"\" return [1, 2, 3] @readwrite_property.setter def readwrite_property(self, value): \"\"\"Docstring in setter is ignored.\"\"\" As usual, ![mkapi][example.ExampleClass] creates the API documentation for the ExampleClass class. CLASS example.ExampleClass (x, y) A normal class. Parameters x (list of int) \u2014 The first parameter. y (str, int) \u2014 The second parameter. Attributes z (str) \u2014 The first attribute. Raises ValueError \u2014 If the length of x is equal to 0. METHOD message (n) \u2192 list of str Returns a message list. Parameters n (int) \u2014 Repeatation. READONLY_PROPERTY readonly_property \u2192 str Read-only property documentation. READWRITE_PROPERTY readwrite_property \u2192 list of int Read-write property documentation. In this example, notice that: Docstring of __init__ function is treated as a class-level docstring. Type annotation using typing package ( List and Tuple in this case) is converted into readable style. So far, only List and Tuple are supported. Bound methods ( message in this case) have a METHOD prefix instead of a FUNCTION prefix. If callable objects have neither Returns nor Yields , the type appears on the object definition line like type annotation. For properties, the type can be written at the beginning of the docstring or type annotation as well as functions. Whether a property is read-only or read-write is inspected.","title":"Class"},{"location":"examples/#data-class","text":"The example module also defines a simple data class ExampleDataClass . Code 4 example.ExampleDataClass @dataclass class ExampleDataClass: \"\"\"A dataclass. Args: x: The first parameter. Attributes: x: The first attribute. y: The second attribute. \"\"\" x: int = 0 y: int = field(default=1, init=False) Then, ![mkapi][example.ExampleDataClass] creates the API documentation for the ExampleDataClass class. DATACLASS example.ExampleDataClass (x=0) A dataclass. Parameters x (int, optional) \u2014 The first parameter. Attributes x (int) \u2014 The first attribute. y (int) \u2014 The second attribute. In this example, notice that: A DATACLASS prefix instead of a CLASS prefix. Attributes type inspection as well as parameters if they are data class fields.","title":"Data Class"},{"location":"examples/#module","text":"Finally, let's generate the API documentation for the example module. The module has a module level docstring like below: File 1 example.py (line 1~10) \"\"\"Module level docstring.\"\"\" from dataclasses import dataclass, field from typing import Iterator, List, Tuple def add(x: int, y: int = 1) -> int: \"\"\"Returns $x + y$. Args: x: The first parameter. Then, ![mkapi][example] creates the API documentation for the entire example module. MODULE example Module level docstring. FUNCTION example. add (x, y=1) Returns x + y x + y . Parameters x (int) \u2014 The first parameter. y (int, optional) \u2014 The second parameter. Default=1. Returns (int) Added value. Examples >>> add(1, 2) 3 Note You can use the admonition extension of MkDocs . Note But you should use Note section instead for consistency. GENERATOR example. gen (n) Yields a numbered string. Parameters n (int) \u2014 The length of iteration. Yields (str) A numbered string. CLASS example. ExampleClass (x, y) A normal class. Parameters x (list of int) \u2014 The first parameter. y (str, int) \u2014 The second parameter. Attributes z (str) \u2014 The first attribute. Raises ValueError \u2014 If the length of x is equal to 0. METHOD message (n) \u2192 list of str Returns a message list. Parameters n (int) \u2014 Repeatation. READONLY_PROPERTY readonly_property \u2192 str Read-only property documentation. READWRITE_PROPERTY readwrite_property \u2192 list of int Read-write property documentation. DATACLASS example. ExampleDataClass (x=0) A dataclass. Parameters x (int, optional) \u2014 The first parameter. Attributes x (int) \u2014 The first attribute. y (int) \u2014 The second attribute.","title":"Module"}]}